MODULE Pricing;

REQUIRE EmployeeStock, PriceRoundStore, PricingOperation, PriceListCalc, PriceListLedger, StockTax, StockSkuDocument, PriceListStore, Item, SkuList;

//------------------------  derive or change ------------------------------------//

pricingBase 'Считать розничную цену от базовой в расценке' = DATA BOOLEAN (CalcPriceListType);
pricingDocument = CalcPriceListType p IS CalcPriceListType AND NOT pricingBase(p) MATERIALIZED;

EXTEND FORM calcPriceListType
    PROPERTIES(c) pricingBase
;

META deriveDocumentDetailBatchOnSessionPriceListType (idetail, prefix, prefixP, stockProp, form, prefixTime)
    @deriveDocumentDetailBatchOnSessionPriceListType (idetail, prefix, prefixP, stockProp, form, prefixTime, );
END

META deriveDocumentDetailBatchOnSessionPriceListType (idetail, prefix, prefixP, stockProp, form, prefixTime, prefixSku)

    skipChangePrice = ABSTRACT CASE BOOLEAN (###idetail);

    WHEN LOCAL 
        (CHANGED(prefix###priceListType(###idetail detail)) OR
         CHANGED(prefixP###price(detail)) OR
         CHANGED(prefixSku###sku(detail)) OR
         CHANGED(stockProp(detail)) OR
        (CHANGED(prefixTime###dateTime(detail)) AND NOT isPosted(detail)) OR
         CHANGED(value###prefix##VAT(detail)))
        AND prefixSku###sku(detail) AND CalcPriceListType priceListType == prefix###priceListType(detail) AND RoundCondition roundCondition == roundCondition(priceListType, prefixSku###sku(detail))
        AND NOT CHANGED(prefix###price(detail)) AND NOT skipChangePrice(detail)
        AND pricingDocument(priceListType) NOINLINE (priceListType, roundCondition) INLINE DO {
            prefix###markup(detail) <- markup(priceListType, prefixSku###sku(detail))
                                                         WHERE prefix###priceListType(detail) == priceListType;
            prefix###price(detail) <- round([ X*(Y+100)*(Z+100)/10000](
                                                                    prefixP###price(detail),
                                                                    prefix###markup(detail),
                                                                    value###prefix##VAT(detail)), roundCondition)
                                                         WHERE prefix###priceListType(detail) == priceListType;
        }
        
    WHEN LOCAL
        (CHANGED(prefix###priceListType(###idetail detail)) OR
         CHANGED(prefixP###price(detail)) OR
         CHANGED(prefixSku###sku(detail)) OR
         CHANGED(stockProp(detail)) OR
        (CHANGED(prefixTime###dateTime(detail)) AND NOT isPosted(detail)) OR
         CHANGED(batch(detail)) OR
         CHANGED(value###prefix##VAT(detail)))
        AND NOT CHANGED(prefix###price(detail)) AND NOT skipChangePrice(detail)
        AND prefixSku###sku(detail) AND PriceListType priceListType == prefix###priceListType(detail) AND NOT pricingDocument(priceListType) NOINLINE (priceListType) INLINE DO {

            prefix###price(detail) <- IF batch(detail) THEN prevPriceA(priceListType, batch(detail), stockProp(detail), prefixTime###dateTime(detail))
                                                      ELSE prevPriceA(priceListType, prefixSku###sku(detail), stockProp(detail), prefixTime###dateTime(detail))
                                                         WHERE prefix###priceListType(detail) == priceListType;
                                                         
            prefix###markup(detail) <- [ round2(min(((X/Z*100/(100+Y))-1)*100,99999))](
                                                               prefix###price(detail),
                                                               prefixP###price(detail),
                                                               value###prefix##VAT(detail))
                                                         WHERE prefix###priceListType(detail) == priceListType;
        }
    skipMarkup = ABSTRACT CASE BOOLEAN (###idetail);
    recalculate###prefix##Markup (###idetail detail)  { 
        prefix##Markup(detail) <- [ round2(min(((X/Z*100/(100+Y))-1)*100,99999))](
                                                           prefix###price(detail),
                                                           prefixP###price(detail),
                                                           value###prefix##VAT(detail));
    }
    WHEN LOCAL
        (CHANGED(prefixP###price(###idetail detail)) OR
         CHANGED(value###prefix##VAT(detail)))
        AND NOT prefix###priceListType(detail) AND NOT skipMarkup(detail) INLINE DO {
            recalculate###prefix##Markup(detail);
        }
END

META recalculateDocumentDetailBatchOnSessionPriceListType (idetail, prefix, prefixP, stockProp, form, prefixTime, cap, concrete)
    overRecalculate###prefix##Price  ABSTRACT LIST ( );

    recalculate###prefix##Price 'Пересчитать розн. цену'###cap ()  { 
        FOR sku(###idetail detail)  AND CalcPriceListType priceListType == prefix##PriceListType(detail) 
            AND RoundCondition roundCondition == roundCondition(priceListType, sku(detail))    
            AND pricingDocument(priceListType) AND [ FILTER form.concrete](detail) NOINLINE (priceListType, roundCondition) INLINE DO {
            
            prefix##Markup(detail) <- markup(priceListType, sku(detail))
                                                         WHERE prefix##PriceListType(detail) == priceListType;
            prefix##Price(detail) <- round([ X*(Y+100)*(Z+100)/10000](
                                                                    prefixP##Price(detail),
                                                                    prefix##Markup(detail),
                                                                    value###prefix##VAT(detail)), roundCondition)
                                                         WHERE prefix##PriceListType(detail) == priceListType;
        } 
           
        FOR sku(###idetail detail) AND PriceListType priceListType == prefix##PriceListType(detail) 
            AND NOT pricingDocument(priceListType) AND [ FILTER form.concrete](detail) NOINLINE (priceListType) INLINE DO {
    
            prefix##Price(detail) <- IF batch(detail) THEN prevPriceA(priceListType, batch(detail), stockProp(detail), prefixTime###dateTime(detail))
                                                    ELSE prevPriceA(priceListType, sku(detail), stockProp(detail), prefixTime###dateTime(detail))
                                                         WHERE prefix##PriceListType(detail) == priceListType;
                                                         
            prefix##Markup(detail) <- [ round2(min(((X/Z*100/(100+Y))-1)*100,99999))](
                                                               prefix##Price(detail),
                                                               prefixP##Price(detail),
                                                               value###prefix##VAT(detail))
                                                         WHERE prefix##PriceListType(detail) == priceListType;
        } 
        overRecalculate###prefix##Price();           
    } ASON CONTEXTMENU prefix##Price[###idetail];
END 

META changeDocumentDetailMarkupCustomPrefix(detail, prefixA, prefixB, prefixC, prefixD)
    skipCalc###prefixA##Markup = ABSTRACT BOOLEAN (###detail);
    calc###prefixD###markup(###detail detail)  = NUMERIC[8,3]([ round2(min(((X/Z*100/(100+Y))-1)*100,99999))](
        prefixA###price(detail),
        prefixB###price(detail),
        value###prefixD##VAT(detail))) IF NOT skipCalc###prefixA##Markup(detail);

    change###prefixA##Price(###detail detail)  { 
        INPUT n = NUMERIC[16,4] DO {
            prefixA###price(detail) <- n;
            prefixD###markup(detail) <- calc###prefixD##Markup(detail) WHERE calc###prefixD##Markup(detail);
        }
    }
END

META changeDocumentDetailPriceCustomPrefix(detail, prefixA, prefixB, prefixC, prefixD, prefixCondition)
    skipCalc###prefixA##Price = ABSTRACT BOOLEAN (###detail);
    calc###prefixA##Price(###detail detail)  = round(NUMERIC[16,4]([ X*(Y+100)*(Z+100)/10000](
        prefixB###price(detail),
        prefixD###markup(detail),
        value###prefixD##VAT(detail))), prefixCondition###roundCondition(detail)) IF NOT skipCalc###prefixA##Price(detail);

    change###prefixD##Markup(###detail detail)  { 
        INPUT n = NUMERIC[8,3] DO {
            prefixD###markup(detail) <- n;
            prefixA###price(detail) <- calc###prefixA##Price(detail) WHERE calc###prefixA##Price(detail);
        }
    }
END
META changeDocumentDetailPriceCustomPrefix(detail, prefixA, prefixB, prefixC, prefixD)
    @changeDocumentDetailPriceCustomPrefix(detail, prefixA, prefixB, prefixC, prefixD, );
END

//-- Для общего случая
META changeDocumentDetailMarkupPrefixInner(detail, prefixA, prefixB, prefixC, prefixD, prefixE, prefixF)
    calc###prefixB###markup###detail(detail)  = [ round2(((X/Z*100/(100+Y))-1)*100)](
        prefixC###price###detail(detail),
        prefixD###price###detail(detail) IF prefixD###price###detail(detail) != 0.0,
        value###prefixE###VAT###detail(detail));

    change###prefixA###price###detail = (detail) {
        INPUT n = NUMERIC[16,4] DO {
            prefixA###price###detail(detail) <- n;
            IF n THEN
                prefixF###markup###detail(detail) <- calc###prefixB###markup###detail(detail) WHERE calc###prefixB###markup###detail(detail);
        }
    }
END
//--

META changeDocumentDetailPricePrefix(detail, prefixA, prefixB, prefixC, prefixD, prefixE, prefixF)

    calc###prefixB##Price(###detail detail)  = round(NUMERIC[16,4]([ X*(Y+100)*(Z+100)/10000](
        prefixD##Price(detail),
        prefixE###markup(detail),
        value###prefixE##VAT(detail))), roundCondition(detail));

    change###prefixA##Price(###detail detail)  { 
        INPUT n = NUMERIC[16,4] DO {
            prefixA##Price(detail) <- n;
            IF n THEN
                prefixF##Price(detail) <- calc###prefixB##Price(detail) WHERE calc###prefixB##Price(detail);
        }
    }
END

//----------------------------------------------- Расценка ---------------------------------------------------//

CLASS ABSTRACT Pricing 'Акт расценки';
CLASS ABSTRACT PricingDetail 'Строка акта расценки';

CLASS UserPricing 'Акт расценки (польз.)' : Pricing;
CLASS UserPricingDetail 'Строка акта расценки (польз.)' : PricingDetail;

@defineDocumentInterface(pricing);
@deriveDocumentHeaderTimePrefix(UserPricing, );

@defineDocumentInterfaceNumber(pricing);
@defineNumeratedDefault(UserPricing, 'Расценки', 'РС');

@defineDocumentInterfaceDataStock(pricing, departmentStore, 'Склад');
@defineDocumentDialogStocks(userPricing, departmentStore, company, , );
@defineDocumentInterfacePosted(pricing);
@defineDocumentInterfaceClosed(pricing);
@defineDocumentClosedConstraint(UserPricing);

@defineDocumentInterfaceDescription(pricing, 'Акт расценки');

// Валюта
@defineDocumentInterfaceCurrency(pricing);
@deriveDocumentCurrency(userPricing, departmentStore);

// Sku
@defineDocumentInterfaceDetailSku(pricing, sku);

// Виды цен

@defineDocumentInterfaceHeaderPriceListType (pricing, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (pricing, pricingDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (userPricing, userPricingDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentInterfaceHeaderPriceListType (pricing, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (pricing, pricingDetail, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (userPricing, userPricingDetail, priceListType, calcRetail, ' (управленческий)');

@defineDocumentInterfaceDetailPriceListType (pricing, priceListType, retail, );

CONSTRAINT currency(UserPricing pricing) != currency[PriceListType](calcRetailCalcPriceListType(pricing))
           CHECKED BY calcRetailCalcPriceListType[UserPricing]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';
CONSTRAINT currency(UserPricing pricing) != currency(calcRetailPriceListType(pricing))
           CHECKED BY calcRetailPriceListType[UserPricing]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

CONSTRAINT currency(UserPricingDetail detail) != currency(retailPriceListType(detail))
           CHECKED BY retailPriceListType[UserPricingDetail]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';


// Округление
//roundConditionUserPricingDetail(userPricingDetail) =
//    IF roundConditionPriceListType(retailPriceListTypeUserPricingDetail(userPricingDetail))
//        THEN roundConditionPriceListType(retailPriceListTypeUserPricingDetail(userPricingDetail))
//        ELSE roundConditionDepartmentStore(departmentStoreUserPricingDetail(userPricingDetail));

overRoundCondition (UserPricingDetail d) = IF retailPriceListType(d) IS CalcPriceListType 
    THEN roundCondition(retailPriceListType(d), sku(d)) 
    ELSE roundCondition(retailPriceListType(d));

roundCondition(UserPricingDetail d) =  IF overRoundCondition(d)
        THEN overRoundCondition(d)              
        ELSE roundCondition(departmentStore(d));
                       
countPricingDetail 'Кол-во строк товара в документе'  = 
    GROUP SUM 1 BY sku(PricingDetail idetail), pricing(idetail);              
countUserPricingDetail 'Кол-во строк товара в документе'  = 
    GROUP SUM 1 BY sku(UserPricingDetail idetail), userPricing(idetail);              

// Поставщик
@defineDocumentInterfaceLegalEntity (pricing, supplier, 'Поставщик');
CONSTRAINT supplier(UserPricing userPricing) AND NOT isSeller(supplier(userPricing))
    CHECKED BY supplier[UserPricing] MESSAGE 'Для акта расценки выбрано в качестве поставщика организация, не являющаяся поставщиком или компанией';

// Цена поставщика
@defineDocumentInterfaceDetailPricePrefix(pricing, , ' поставщика');

overPrice(pricingDetail) = ABSTRACT CASE NUMERIC[16,4] (PricingDetail) MATERIALIZED;

// Цена базовая (от которой будет считаться надбавка)
overPricingPrice = ABSTRACT NUMERIC[16,4] (PricingDetail) MATERIALIZED;
overPricingPrice = ABSTRACT NUMERIC[16,4] (UserPricingDetail);
overPricingPrice (UserPricingDetail detail) += overPricingPrice(detail);

over1PricingPrice = ABSTRACT NUMERIC[16,4] (PricingDetail);

pricingPrice (UserPricingDetail detail) = OVERRIDE overPricingPrice(detail), price(detail) MATERIALIZED;
pricingPrice (PricingDetail detail) = OVERRIDE over1PricingPrice(detail), overPricingPrice(detail), price(detail) MATERIALIZED;

// Надбавка
@defineDocumentInterfaceDetailMarkupPrefix (pricing, retail, );

// НДС
@defineDocumentInterfaceDetailVAT(pricing, countryDepartmentStore, retail, );
@deriveDocumentDetailVAT(userPricing, retail);
@deriveDocumentDetailValueVAT(userPricing, retail);

@defineDocumentInterfaceDetailPricePrefix(pricing, retail, ' розничная');

disallowLinePricings 'Запретить строки без розничной цены в актах расценки' = DATA BOOLEAN ();

EXTEND FORM options
    PROPERTIES() disallowLinePricings
;

DESIGN options {
    pane {        
        NEW pricings {
            caption = 'Акты расценки';
            MOVE PROPERTY(disallowLinePricings());   
        }
    }
}

// Объявление действий, которые будут срабатывать по изменению надбавки и розничной цены
@changeDocumentDetailMarkupCustomPrefix(userPricingDetail, retail, pricing, retail, retail);
@changeDocumentDetailPriceCustomPrefix(userPricingDetail, retail, pricing, retail, retail);

// Основание
descriptionDocument 'Документы-основания' = ABSTRACT STRING[255] (Pricing) MATERIALIZED;
//документы основания для множеств
basisDoc 'Документы основания' = ABSTRACT BOOLEAN (Pricing, Document) MATERIALIZED;
basisDoc 'Документы основания' = ABSTRACT BOOLEAN (PricingDetail, Document) MATERIALIZED;

@defineMovementSku(pricingDetail, departmentStore); //-- показываем по нажатию правой клавиши движение товара
@defineMovementSku(userPricingDetail, departmentStore); //-- показываем по нажатию правой клавиши движение товара
@defineBalancesSku(pricingDetail); //-- показываем по нажатию правой клавиши остатки товара
@defineBalancesSku(userPricingDetail); //-- показываем по нажатию правой клавиши остатки товара

@defineMovementPriceSku(pricingDetail, departmentStore); //-- показываем по нажатию правой клавиши изменение цены товара
@defineMovementPriceSku(userPricingDetail, departmentStore); //-- показываем по нажатию правой клавиши  изменение цены товара

@defineBarcodeSku(pricingDetail); //-- показываем по нажатию правой клавиши все штрихкоды для товара
@defineBarcodeSku(userPricingDetail); //-- показываем по нажатию правой клавиши все штрихкоды для товара

@defineInfoSku(pricingDetail); //-- показываем по нажатию правой клавиши информацию по товару
@defineInfoSku(userPricingDetail); //-- показываем по нажатию правой клавиши информацию по товару

//-- Партии
@showDocumentInterfaceDetailBatch(pricing);
@defineDocumentInterfaceDetailBatch(pricing, batch);

changeBatch(UserPricingDetail detail)  { 
    DIALOG dialogBatchStockOut OBJECTS st = departmentStore(detail),
                             t = dateTime(detail),
                             sk = sku(detail),
                             bt = batch(detail) INPUT NULL NEWSESSION DO
        batch(detail) <- bt;
}

@defineBalancesBatch(pricingDetail); //-- показываем по нажатию правой клавиши остатки партии
@defineBalancesBatch(userPricingDetail); //-- показываем по нажатию правой клавиши остатки партии
@defineMovementBatch(pricingDetail, departmentStore); //-- показываем по нажатию правой клавиши движение по партии
@defineMovementBatch(userPricingDetail, departmentStore); //-- показываем по нажатию правой клавиши движение по партии

// --------------------------- Формы --------------------------------- //
backgroundRetail 'Цвет' (Pricing pricing) = RGB(224, 255, 255) IF pricing IS Pricing;
FORM userPricing 'Акт расценки'
    OBJECTS p = UserPricing PANEL
    PROPERTIES (p) isPosted, nameDepartmentStore ON CHANGE changeDepartmentStoreCompany(p), nameNumerator, number, series, date, time,
                   nameCurrency, note, nameCalcRetailPriceListType, nameCalcRetailCalcPriceListType,
                   countUserPricingDetail

    OBJECTS d = UserPricingDetail
    PROPERTIES (d) index, idBarcodeSku, idSku, nameSku, nameBatch, shortNameUOMSku,
                   nameRetailPriceListType, price
    PROPERTIES (d) BACKGROUND backgroundRetail(p)
                   retailMarkup ON CHANGE changeRetailMarkup(d), numberRetailVAT, valueRetailVAT, retailPrice ON CHANGE changeRetailPrice(d)
    PROPERTIES (d) NEW, deletepd=DELETE GRID
    ORDER index(d)

    PROPERTIES(p) DRAW d deleteUserPricingDetail
    FILTERS userPricing(d) == p

    EVENTS
        ON OK prePost(p)

    EDIT UserPricing OBJECT p
;

DESIGN userPricing {
    BOX {
        size = (1024, 768);
        NEW mainTabbed {
            fill = 1;
            type = TABBED;
            NEW documentBox {
                fill = 1;
                type = CONTAINERV;
                caption = 'Расценка';

                NEW header {
                    type = CONTAINERH;
        
                    NEW headerRow1 {
                        fill = 1;
        
        //                NEW p.documentHeader {
        //                    type = CONTAINERH;
        //                    NEW PROPERTY(isPostedUserPricing) { charWidth = 10; }
        //                    NEW PROPERTY(nameDepartmentStoreUserPricing);
        //                    NEW PROPERTY(nameNumeratorUserPricing);
        //                    NEW PROPERTY(numberUserPricing);
        //                    NEW PROPERTY(seriesUserPricing);
        //                    NEW PROPERTY(dateUserPricing);
        //                    NEW PROPERTY(timeUserPricing);
        //                }
                        MOVE GROUP(documentHeader,p) {
                            type = CONTAINERV;
                            NEW first {
                                type = CONTAINERH;
                                MOVE PROPERTY(isPosted(p));
                            }
                            NEW second { 
                                type = CONTAINERH;
                                MOVE PROPERTY(nameDepartmentStore(p));
                                MOVE PROPERTY(nameNumerator(p));
                                MOVE PROPERTY(number(p));
                                MOVE PROPERTY(series(p));
                                MOVE PROPERTY(date(p));
                                MOVE PROPERTY(time(p));
                            }    
                        } 
                        NEW params {
                            MOVE GROUP(documentPrm,p) {
                                columns = 2;
                            }
                        }
                    }
        
                    MOVE GROUP(documentSum,p) {
                        columns = 1;
                    }
                }
        
                NEW specificationBox {
                    fill = 1;
                    NEW details {
                        caption = 'Спецификация';
                        NEW addContainter {
                            type = CONTAINERH;
                        }
                        MOVE BOX(d);
                    }
                }
            }
        }
        MOVE TOOLBARBOX;

        PROPERTY(formOk()) {
            caption = 'Провести';
        }
    }
}

groupType (UserPricing p) = SystemGroupType.skuGroupType IF p IS UserPricing;

@defineDocumentSkuStockIn(userPricing, sku, departmentStore);
@extendFormDocumentSkuStockIn(UserPricing, userPricing, p);


isUserOpened(UserPricing p)=  isOpened[Pricing](p) AND is(p);

edit(UserPricingDetail d) + {  edit(userPricing(d)); }

skipChange = ABSTRACT VALUE BOOLEAN (Pricing);
overShowEditDelete = ABSTRACT VALUE BOOLEAN (Pricing);
showChange(Pricing p) = overShowEditDelete(p) AND NOT skipChange(p) AND isOpened(p);

FORM pricings 'Акты расценки' 
    OBJECTS p = Pricing LAST
    PROPERTIES (p) READONLYIF isReadonly() isClosed, isPosted, number, series, date, time,
                            nameDepartmentStore, nameCurrency, nameCalcRetailPriceListType, nameCalcRetailCalcPriceListType                              
    PROPERTIES (p) READONLY countPricingDetail
    
    PROPERTIES (p) READONLYIF isReadonly() note

    PROPERTIES (p) READONLY PANEL createdNameUser, createdTime, createdHostnameComputer, 
                                        postedNameUser, postedTime, postedHostnameComputer

    PROPERTIES (p) NEWSESSION NEW[UserPricing], EDIT SHOWIF showChange(p), deletep = DELETE SHOWIF showChange(p) 
    PROPERTIES(p)  close[UserPricing] SHOWIF isOpened[UserPricing](p), open SHOWIF isClosed[UserPricing](p)     

    OBJECTS d = PricingDetail
    PROPERTIES (d) READONLY index, idBarcodeSku, nameSku, nameBatch, shortNameUOMSku,
                   nameRetailPriceListType, price
    PROPERTIES (d) READONLY BACKGROUND backgroundRetail(p) retailMarkup, numberRetailVAT, valueRetailVAT,
                   retailPrice
    ORDER index(d)

    FILTERS pricing(d) == p

    LIST Pricing OBJECT p
;
@extendFormFilterAccessStock(Pricing, p, pricings, departmentStore, company);

DESIGN pricings {
    NEW pane {
        fill = 1;
        type = SPLITV;

        MOVE BOX(p) {
            fill = 2;
        }

        NEW documentDetail {
            fill = 1;
            type = TABBED;

            MOVE BOX(d) {
                caption = 'Спецификация';
            }
            NEW documentHistory {
                caption = 'История';

                MOVE GROUP(created,p);
                MOVE GROUP(posted,p);
            }
            NEW printTab {
                caption = 'Печатные формы';
            }
            NEW actionContainer {
                caption = 'Действия';
                type = CONTAINERV;
                NEW createdContainer {
                    caption = 'Создание на основе';
                }
                NEW machineryContainer {
                    caption = 'Загрузка';
                }
            }
        }
    }
    MOVE TOOLBARBOX;
}
@extendFormEditable(pricings);
@defineFilterIsOpened (pricing, pricings, p);

NAVIGATOR {
    retailNavigator {
        NEW FOLDER pricingNavigator 'Расценка' {
            NEW pricings;
            NEW operations;
        }
    }
}

WHEN LOCAL FORMS userPricing // цены берем на начало сессии, а не этого event'а
   (CHANGED(calcRetailPriceListType(UserPricingDetail detail)) OR
    CHANGED(calcRetailCalcPriceListType(detail)) OR
    CHANGED(sku(detail)) OR
    CHANGED(departmentStore(detail)) OR
    CHANGED(dateTime(detail))) AND PriceListType pt == calcRetailPriceListType(detail) NOINLINE (pt) DO
   retailPriceListType(detail) <- IF prevPriceB(pt,
                                                                                          sku(detail),
                                                                                          departmentStore(detail),
                                                                                          dateTime(detail))
                                                            THEN pt
                                                            ELSE calcRetailCalcPriceListType(detail);

// если не задана управленческая цена
WHEN LOCAL FORMS userPricing // цены берем на начало сессии, а не этого event'а
   (CHANGED(calcRetailPriceListType(UserPricingDetail detail)) OR
    CHANGED(calcRetailCalcPriceListType(detail)) OR
    CHANGED(sku(detail)) OR
    CHANGED(departmentStore(detail)) OR
    CHANGED(dateTime(detail))) AND NOT calcRetailPriceListType(detail) DO
    retailPriceListType(detail) <- calcRetailCalcPriceListType(detail);

// Проставление надбавки и розничной цены при изменении sku, склада, времени, вида цен, цены расценки, НДС в форме userPricing
//overLimitPriceUserPricingDetail = ABSTRACT NUMERIC[16,4] (UserPricingDetail);
//
//minRetailPriceUserPricingDetail 'Минимальная розничная цена' (detail)= MIN roundPriceRoundCondition([ X*(Y+100)*(Z+100)/10000](
//                                                                        pricingPriceUserPricingDetail(detail),
//                                                                        retailMarkupUserPricingDetail(detail),
//                                                                        valueRetailVATUserPricingDetail(detail)), roundConditionPriceListType(calcRetailCalcPriceListTypeUserPricingDetail(detail))),
//                                                                    overLimitPriceUserPricingDetail(detail);
//FORM userPricingDetail 'Строка расценки'
//    OBJECTS d = UserPricingDetail PANEL
//    PROPERTIES (d) minRetailPriceUserPricingDetail
//;
@deriveDocumentDetailBatchOnSessionPriceListType (userPricingDetail, retail, pricing, departmentStore, userPricing, );
@recalculateDocumentDetailBatchOnSessionPriceListType(userPricingDetail, retail, pricing, departmentStore, userPricing, , '', d);

WHEN LOCAL FORMS userPricing
    (CHANGED(calcRetailCalcPriceListType(UserPricingDetail detail)) OR
        CHANGED(sku(detail)) OR
        CHANGED(batch(detail)) OR
        CHANGED(departmentStore(detail)) OR
        CHANGED(dateTime(detail))) AND PriceListType priceListType == basePriceListType(calcRetailCalcPriceListType(detail)) NOINLINE (priceListType) INLINE DO {
            price (detail)  <- IF batch(detail)
        
                                                            THEN prevPriceA[PriceListType,Batch,Stock,DATETIME](priceListType,
                                                                                                           batch(detail),
                                                                                                           departmentStore(detail),
                                                                                                           dateTime(detail))
                                                            ELSE prevPriceA[PriceListType,Sku,Stock,DATETIME](priceListType,
                                                                                                         sku(detail),
                                                                                                         departmentStore(detail),
                                                                                                         dateTime(detail));
        }

WHEN LOCAL FORMS userPricing // по факту это дублирующее событие с тем, что в метакоде, но если его не делать, то при создании расценки из формы Расценка не будет заполняться надбавка из-за NOT CHANGED (retailPrice 
    CHANGED(price(UserPricingDetail detail)) AND NOT skipMarkup(detail) INLINE DO
        recalculateRetailMarkup(detail);

//----------------------------------------------- Операции -----------------------------------------------------//

// Вид цены для расценки для операции
pricingPriceListType = DATA PriceListType (Operation);
namePricingPriceListType 'Вид цен акт расценки (управленческий)' (Operation operation) = name(pricingPriceListType(operation));

pricingCalcPriceListType = DATA CalcPriceListType (Operation);
namePricingCalcPriceListType 'Вид цен акт расценки (надбавка)' (Operation operation) = name[PriceListType](pricingCalcPriceListType(operation));

useSupplierStock 'Использовать склад поставщика' = DATA BOOLEAN (Operation);
useShipmentQuantity 'Расценивать поставленное кол-во' = DATA BOOLEAN (Operation);

EXTEND FORM operation
    PROPERTIES(o) namePricingPriceListType, namePricingCalcPriceListType, useSupplierStock, useShipmentQuantity
;

DESIGN operation {
    paramsContainer {
        MOVE PROPERTY(namePricingPriceListType(o));
        MOVE PROPERTY(namePricingCalcPriceListType(o));
        MOVE PROPERTY(useSupplierStock(o));
        MOVE PROPERTY(useShipmentQuantity(o));
    }
}

@defineDocumentInterfaceOperation (pricing, Pricing, );
@extendFormFilterRoleAccess(pricing, p, pricings);
@defineDocumentOperationConstraint(pricing, 'акт расценки', Pricing);

@defineDocumentOperationRolePrefix(userPricing, );

@defineOperationChangesDocument(pricing, Pricing, preventChangesDocument, created);

overShowEditDelete(Pricing p) += showEditDeleteUser(p);
// Записываем тип цены по умолчанию из операции
skipSetPriceListTypesDepartmentStore 'Не подставлять виды цен магазина' = DATA BOOLEAN (Operation);

EXTEND FORM operation
    PROPERTIES (o) skipSetPriceListTypesDepartmentStore
;

DESIGN operation {
    paramsContainer{
        MOVE PROPERTY(skipSetPriceListTypesDepartmentStore(o));
    }    
}


calcRetailPriceListType (UserPricing p) <- IF pricingPriceListType(operation(p)) 
                THEN pricingPriceListType(operation(p))
                ELSE (retailPriceListType(departmentStore(p)) IF NOT skipSetPriceListTypesDepartmentStore(operation(p)))
                    WHEN (CHANGED(operation(p)) OR CHANGED(departmentStore(p))) AND operation(p);

calcRetailCalcPriceListType (UserPricing p) <- IF pricingCalcPriceListType(operation(p)) 
                THEN pricingCalcPriceListType(operation(p))
                ELSE (retailCalcPriceListType(departmentStore(p)) IF NOT skipSetPriceListTypesDepartmentStore(operation(p)))
                    WHEN (CHANGED(operation(p)) OR CHANGED(departmentStore(p))) AND operation(p);


EXTEND FORM userPricing
    PROPERTIES(p) nameOperation
//    PROPERTIES (d) overLimitPriceUserPricingDetail, overPricingPriceUserPricingDetail, pricingPriceUserPricingDetail, minRetailPriceUserPricingDetail
;
DESIGN userPricing{
    first{
        MOVE PROPERTY (nameOperation(p)) {charWidth = 30;}
    }
}

EXTEND FORM pricings
    PROPERTIES(p) READONLY nameOperation BEFORE nameCurrency(p)
;

// ---------------------------- Создание PriceList ----------------------------------- //

EXTEND CLASS SystemLedgerPriceListType {
    retailPricingPriceListType 'Розничная (расценка)'
}

retailPricingPriceB 'Розничная цена' (Sku sku, Stock stock, DATETIME dateTime) =
    priceB(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
retailPricingPriceB 'Розничная цена' (Sku sku, Stock stock, DATE date) = 
    retailPricingPriceB(sku, stock, toDateTime(date));    
retailPricingPriceB 'Розничная цена' = retailPricingPriceB(Sku sku, Stock stock, currentDateTime());  

retailPricingPriceB 'Розничная цена' (Batch batch, Stock stock, DATETIME dateTime) =
    priceB(SystemLedgerPriceListType.retailPricingPriceListType, batch, stock, dateTime);
retailPricingPriceB 'Розничная цена' (Batch batch, Stock stock, DATE date) = 
    retailPricingPriceB(batch, stock, toDateTime(date));    

prevRetailPricingPriceB 'Розничная цена' (Sku sku, Stock stock, DATETIME dateTime) =
    prevPriceB(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
prevRetailPricingPriceB 'Розничная цена' (Sku sku, Stock stock, DATE date) = 
    prevRetailPricingPriceB(sku, stock, toDateTime(date));    

retailPricingPriceA 'Розничная цена' (Sku sku, Stock stock, DATETIME dateTime) =
    priceA(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
retailPricingPriceA 'Розничная цена' (Sku sku, Stock stock, DATE date) = 
    retailPricingPriceA(sku, stock, toDateTime(date));    

currentRetailPricingPriceListLedger (Sku sku, Stock stock) =
    currentPriceListLedger(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock) MATERIALIZED INDEXED TABLE extraSkuStock;

currentRetailPricingPrice 'Розничная цена' (Sku sku, Stock stock) =
    price[PriceListLedger,LedgerPriceListType](currentRetailPricingPriceListLedger(sku, stock), SystemLedgerPriceListType.retailPricingPriceListType) MATERIALIZED TABLE extraSkuStock; 

currentRetailPricingDescription 'Описание' (Sku sku, Stock stock) =
    description(currentRetailPricingPriceListLedger(sku, stock)); 

retailPricingPriceA 'Розничная цена' (Sku sk, Stock st) = retailPricingPriceA(sk, st, currentDateTime());
retailPricingSumA 'Розничная сумма' (Sku sku,Stock stock)= retailPricingPriceA(sku,stock) * currentBalance(sku,stock);

retailPricingDescriptionA 'Описание' (Sku sku, Stock stock, DATETIME dateTime) =
    descriptionA(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
retailPricingDescriptionA 'Описание' (Sku sku, Stock stock, DATE date) = 
    retailPricingDescriptionA(sku, stock, toDateTime(date));    

retailPricingDescriptionA 'Описание' (Sku sk, Stock st) = retailPricingDescriptionA(sk, st, currentDateTime()); 

retailPricingFromDateTimeA 'Дата/время с' (Sku sku, Stock stock, DATETIME dateTime) =
    fromDateTimeA(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
    
retailPricingFromDateTimeA 'Дата/время с' (Sku sk, Stock st) = retailPricingFromDateTimeA(sk, st, currentDateTime());    

currentRetailPricingFromDateTime 'Дата/время с' (Sku sku, Stock stock) =
    fromDateTime(currentRetailPricingPriceListLedger(sku, stock)); 

retailPricingPriceA 'Розничная цена' (Batch batch, Stock stock, DATETIME dateTime) =
    priceA(SystemLedgerPriceListType.retailPricingPriceListType, batch, stock, dateTime);
retailPricingPriceA 'Розничная цена' (Batch batch, Stock stock, DATE date) = 
    retailPricingPriceA(batch, stock, toDateTime(date));    

prevRetailPricingPriceA 'Розничная цена' (Sku sku, Stock stock, DATETIME dateTime) =
    prevPriceA(SystemLedgerPriceListType.retailPricingPriceListType, sku, stock, dateTime);
prevRetailPricingPriceA 'Розничная цена' (Sku sku, Stock stock, DATE date) = 
    prevRetailPricingPriceA(sku, stock, toDateTime(date));    

includeVAT[SystemLedgerPriceListType] (SystemLedgerPriceListType priceListType) += WHEN priceListType == SystemLedgerPriceListType.retailPricingPriceListType THEN TRUE;

batch(SystemLedgerPriceListType type, Stock stock) += WHEN type == SystemLedgerPriceListType.retailPricingPriceListType AND isCompany(stock)
                                              THEN priceBatchLedger(stock);

EXTEND CLASS PricingDetail : PriceListLedger;

fromDateTime (PricingDetail ledger) += dateTime(ledger);

isPosted(PricingDetail ledger) += isPosted(ledger);

sku[PriceListLedger] (PricingDetail ledger) += sku(ledger);

operation (PricingDetail ledger) += operation(ledger);

description (PricingDetail ledger) += description(ledger);

in (PricingDetail ledger, SystemLedgerPriceListType type) += WHEN retailPrice(ledger) AND type == SystemLedgerPriceListType.retailPricingPriceListType THEN TRUE;
price (PricingDetail ledger, SystemLedgerPriceListType type) += WHEN retailPrice(ledger) AND type == SystemLedgerPriceListType.retailPricingPriceListType THEN retailPrice(ledger);

//inPriceListLedgerSystemLedgerPriceListType (ledger, type) += TRUE WHEN CLASS(retailPricePricingDetail(ledger)) AND type == SystemLedgerPriceListType.accountPriceListType;
//pricePriceListLedgerSystemLedgerPriceListType (ledger, type) += retailPricePricingDetail(ledger) WHEN CLASS(retailPricePricingDetail(ledger)) AND type == SystemLedgerPriceListType.accountPriceListType;

in (PricingDetail ledger, Batch batch) += batch(ledger) == batch; 

in (PricingDetail ledger, DepartmentStore stock) += departmentStore(ledger) == stock;


show 'Просмотреть'  ABSTRACT LIST  ( PricingDetail) TOOLBAR;
show(UserPricingDetail d)  { 
	NEWSESSION {
	    SHOW userPricing OBJECTS p = userPricing(d), d = d DOCKED READONLY ;
	}
}
show(UserPricingDetail d) + {  show(d); }    
show[PriceListLedger] (PricingDetail ledger) + { show(ledger);};

// ------ Расширяем форму остатков

EXTEND FORM currentBalanceSkuStock
    PROPERTIES(s, st) READONLY retailPricingPriceA, retailPricingSumA  
;
skipRetailPrice = ABSTRACT CASE BOOLEAN (PricingDetail);

CONSTRAINT  (SET(isPosted(PricingDetail d)) OR CHANGED(retailPrice(d))) AND isPosted(d) AND isRetailPrice(operation(d)) AND NOT skipRetailPrice(d) AND NOT retailPrice(d)
    MESSAGE 'Для строки акта расценки должна быть задана розничная цена'; 

@defineAddSkuLists(userPricing, userPricing, p);
@defineNewSkuList(pricing, userPricing, pricings, p);
DESIGN userPricing {
    addContainter {
        MOVE PROPERTY (addSkuLists(p));
        MOVE PROPERTY (newSkuList(p));
    }
}

DESIGN pricings {
    actionContainer {
        NEW listSku {
            caption = 'Списки SKU';
            MOVE PROPERTY (newSkuList(p));
        }
    }
}