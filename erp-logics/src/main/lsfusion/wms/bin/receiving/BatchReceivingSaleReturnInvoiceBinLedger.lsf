MODULE BatchReceivingSaleReturnInvoiceBinLedger;

REQUIRE ReceivingSaleReturnInvoiceBinLedger, BatchReceivingInvoiceBinLedger, SaleReturnCreditNoteSkuLedger,
        SaleReturnCreditNoteBinLedger;

NAMESPACE SaleReturn;

overCreateDetail(ReceivingDetail d, InvoiceDetail detail) + {
    expiryDate(d) <- expiryDate(detail);
    consolidationKey(d) <- consolidationKey(detail);
}

skipReceiving(Invoice r) += NOT createShipment(r);

CONSTRAINT userReceiving(Invoice invoice) IS UserReceiving AND (NOT createShipment(invoice))
    MESSAGE 'Для накладной приемки не задана поставка';

//Не провподим по ТО поставки, если по ним не завершена приёмка
overSkipStockDocumentLedger(Shipment s) += s IS Shipment AND NOT GRDate(invoice(s));

extraSetShipmentDateTime ABSTRACT (UserInvoice);
setShipmentDateTime(UserInvoice i) + {
    shipmentDate(i) <- GRDate(receiving(i));
    shipmentTime(i) <- GRTime(receiving(i));
    extraSetShipmentDateTime(i);
}

limitPartitionCreditNote = DATA LOCAL NUMERIC[16,5] (InvoiceDetail);

quantityVariance(InvoiceDetail detail) =
    PARTITION UNGROUP quantityVarianceToPartition LIMIT limitPartitionCreditNote(detail) ORDER detail 
        BY sku(detail), overConsolidationKey(detail), receiving(invoice(detail));

createCreditNoteQuantityVariance(Invoice i) + {
    IF NOT userCreditNote(i) THEN NEW c = UserCreditNote {
        invoice(c) <- i;
        operation(c) <- operation(i);
        executeLocalEvents('SaleReturn.userCreditNote');
        supplier(c) <- supplier(i);
        supplierStock(c) <- supplierStock(i);
        customer(c) <- customer(i);
        customerStock(c) <- customerStock(i);
        date(c) <- DATE(MAX currentDateTime(), GRDateTime(receiving(i)));
        time(c) <- TIME(MAX currentDateTime(), GRDateTime(receiving(i)));
        isPosted(c) <- TRUE;
    }

    limitPartitionCreditNote(InvoiceDetail d) <- (quantity(d) (-) prevQuantityUserCreditNote(d));    
    FOR quantityVariance(InvoiceDetail d) DO NEW dc = UserCreditNoteDetail {
        userCreditNote(dc) <- userCreditNote(invoice(d));
        invoiceDetail(dc) <- d;
        batch(dc) <- batch(d);
        sku(dc) <- sku(d);
        quantity (dc) <- quantityVariance(d);
        VAT(dc) <- VAT(d);
        valueVAT(dc) <- valueVAT(d);
        price(dc) <- price(d);
        invoicePrice(dc) <- invoicePrice(d);
    }
    executeLocalEvents('SaleReturn.userCreditNote');
}

hasBin[CreditNote.CreditNoteDetail](CreditNoteDetail d) += outBin(d) IS Bin;

quantityCreditNoteQualityVariance 'Кол-во в актах расхождений(по качеству)' (Bin bin, Sku s, STRING str, Receiving r) =
    [GROUP SUM quantity(CreditNoteDetail d) IF hasBin(d) BY outBin(d), sku(d), overConsolidationKey(d), receiving(invoice(invoiceDetail(d)))](bin, s, str, r);

qualityVarianceToPartition = DATA LOCAL NUMERIC[16,5] (Bin, Sku, STRING, Receiving);
limitPartitionCreditNote(InvoiceDetail detail, Bin bin) =
    PARTITION UNGROUP qualityVarianceToPartition LIMIT limitPartitionCreditNote(detail)
        BY bin, sku(detail), overConsolidationKey(detail), receiving(invoice(detail));
qualityVariance(InvoiceDetail detail, Bin bin) =
    PARTITION UNGROUP qualityVarianceToPartition LIMIT limitPartitionCreditNote(detail, bin) ORDER detail
        BY sku(detail), overConsolidationKey(detail), receiving(invoice(detail));

createCreditNoteQualityVariance(Invoice i) + {
    IF NOT userCreditNote(i) THEN NEW c = UserCreditNote {
        invoice(c) <- i;
        operation(c) <- operation(i);
        executeLocalEvents('Purchase.userCreditNote');
        supplier(c) <- supplier(i);
        supplierStock(c) <- supplierStock(i);
        customer(c) <- customer(i);
        customerStock(c) <- customerStock(i);
        date(c) <- currentDate();
        time(c) <- currentTime();
        useBins(c) <- TRUE;        
        isPosted(c) <- TRUE;
    }

    qualityVarianceToPartition(Bin bin, Sku s, STRING str, Receiving r) <-
        ((GROUP SUM quantity(ReceivingDetail rd) IF sku(rd)==s AND overConsolidationKey(rd)==str AND receiving(rd)==r AND
            orderLedger(inBin(rd)) AND NOT storage(inBin(rd)) AND inBin(rd)==bin) (-)
            quantityCreditNoteQualityVariance(bin, s, str, r)) WHERE qualityVarianceToPartition(s, str, r) AND r=receiving(i);
    limitPartitionCreditNote(InvoiceDetail d) <- (quantity(d) (-) prevQuantityUserCreditNote(d));
    FOR qualityVariance(InvoiceDetail d, Bin bin) DO NEW dc = UserCreditNoteDetail {
        userCreditNote(dc) <- userCreditNote(invoice(d));
        invoiceDetail(dc) <- d;
        batch(dc) <- batch(d);
        sku(dc) <- sku(d);
        quantity (dc) <- qualityVariance(d, bin);
        VAT(dc) <- VAT(d);
        valueVAT(dc) <- valueVAT(d);
        price(dc) <- price(d);
        invoicePrice(dc) <- invoicePrice(d);
        outBin(dc) <- bin;
    }
    executeLocalEvents('Purchase.userCreditNote');
}