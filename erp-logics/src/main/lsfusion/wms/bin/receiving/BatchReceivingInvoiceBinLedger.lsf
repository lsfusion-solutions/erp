MODULE BatchReceivingInvoiceBinLedger;

REQUIRE ReceivingInvoiceBinLedger, BatchReceivingBinLedger, SkuLedger, InvoiceShipment, CreditNote;

NAMESPACE Invoice;

quantityInvoiceDetail 'Кол-во товара в документе'  = 
    GROUP SUM quantity(InvoiceDetail ivoiceDetail) BY batch(ivoiceDetail), receiving(invoice(ivoiceDetail));

CONSTRAINT receivingQuantity(Batch batch, Receiving receiving)>quantityInvoiceDetail(batch, receiving)
    MESSAGE 'Нельзя принять по партии больше, чем кол-во в накладной';

consolidationKey 'Ключ группировки' = ABSTRACT STRING (Batch) CHARWIDTH 7;
overConsolidationKey(Batch bt) = OVERRIDE consolidationKey(bt), ('Не указан' IF bt IS Batch) MATERIALIZED;

clearInBin ABSTRACT (Receiving); //Очищаем ячейки в накладной    inBin(Purchase.InvoiceDetail detail) <- NULL WHERE detail = invoiceDetail(shipmentDetail(batch(d)));
overCompleteReceiving (Receiving r) + {
    clearInBin(r);
    
    status(r) <- PREV(status(r)); //возвращаем статус, что бы понимать какие строки уже обработаны
    
    FOR quantity(ReceivingDetail d) AND NOT batch(d) AND receiving(d)==r AND NOT completeStatus(d) ORDER quantity(d) NOINLINE DO {
        batch(d) <- GROUP LAST Batch bt IF sku(bt)==sku(d) AND overConsolidationKey(bt)==overConsolidationKey(d) AND quantityInvoiceDetail(bt, r) AND 
            (quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r)) >= quantity(d) ORDER DESC (quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r));
        dataStatus(d) <- ReceivingStatus.fullyReceived WHERE batch(d);
    }

    LOCAL rQuantity = NUMERIC[16,5] (Sku, STRING, Receiving);
    LOCAL bQuantity = NUMERIC[16,5] (Sku, STRING, Receiving);
    LOCAL bQuantity = NUMERIC[16,5] (Batch);
    LOCAL receiving = Receiving (Batch);

    receiving(Batch bt) <- r WHERE quantityInvoiceDetail(bt, r);
    rQuantity(Sku s, STRING consolidationKey, r) <- GROUP SUM quantity(ReceivingDetail detail) 
        IF sku(detail)==s AND overConsolidationKey(detail)==consolidationKey AND receiving(detail)==r AND NOT batch(detail) AND NOT completeStatus(detail);

    bQuantity(Batch bt) <-
        (PARTITION UNGROUP rQuantity
            LIMIT quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r)
            ORDER bt
            BY sku(bt), overConsolidationKey(bt), receiving(bt))
        WHERE receiving(bt)==r;

    bQuantity(Sku s, STRING consolidationKey, r) <- GROUP SUM bQuantity(Batch bt) IF sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND receiving(bt)==r;

    FOR bQuantity(Sku s, STRING consolidationKey, r) AND bQuantity(s, consolidationKey, r)==rQuantity(s, consolidationKey, r) DO {
        DELETE ReceivingDetail detail WHERE detail IS ReceivingDetail AND receiving(detail)==r AND NOT batch(detail) AND sku(detail)==s AND overConsolidationKey(detail)==consolidationKey AND NOT completeStatus(detail);   
    }

    FOR bQuantity(Sku s, STRING consolidationKey, r) AND NOT bQuantity(s, consolidationKey, r)==rQuantity(s, consolidationKey, r) DO {
        bQuantity(Batch bt) <- NULL WHERE bQuantity(bt) AND sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND receiving(bt)==r;
        dataStatus(ReceivingDetail d) <- NULL WHERE sku(d)==s AND overConsolidationKey(d)==consolidationKey AND receiving(d)==r;
        MESSAGE 'В партии приходной накладной не хватает кол-ва для распределения строк приёмки по товару: ' + name(s) + ' и строке группировки: ' + consolidationKey +'\n' NOWAIT;
        CANCEL;
        RETURN;
    }

    FOR bQuantity(Batch bt) INLINE NEW d=ReceivingDetail DO{
        receiving(d) <- r;
        sku(d) <- sku(bt);
        consolidationKey(d) <- consolidationKey(bt);
        batch(d) <- bt;
        quantity(d) <- bQuantity(bt);
        dataStatus(d) <- ReceivingStatus.fullyReceived;
    }

    IF (GROUP SUM 1 IF expectedQuantity(Sku sku, STRING key, r) == receivingQuantity(sku, key, r)) THEN {
        status(r) <- ReceivingStatus.fullyReceived;
    } ELSE {
        status(r) <- ReceivingStatus.partiallyReceived;
    }
}

overCompleteReceiving(Sku s, STRING consolidationKey, Receiving r) + {
    //возвращаем статус, что бы понимать какие строки уже обработаны
    dataStatus(ReceivingDetail d) <- PREV(dataStatus(d)) WHERE sku(d)==s AND overConsolidationKey(d)==consolidationKey AND receiving(d)==r;
    
    FOR quantity(ReceivingDetail d) AND NOT batch(d) AND sku(d)==s AND overConsolidationKey(d)==consolidationKey AND receiving(d)==r AND NOT completeStatus(d) ORDER quantity(d) NOINLINE DO {
        batch(d) <- GROUP LAST Batch bt IF sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND quantityInvoiceDetail(bt, r) AND 
            (quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r)) >= quantity(d) ORDER DESC (quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r));
        dataStatus(d) <- ReceivingStatus.fullyReceived WHERE batch(d);
    }

    LOCAL rQuantity = NUMERIC[16,5] (Sku, STRING, Receiving);
    LOCAL bQuantity = NUMERIC[16,5] (Sku, STRING, Receiving);
    LOCAL bQuantity = NUMERIC[16,5] (Batch);
    LOCAL receiving = Receiving (Batch);
    
    receiving(Batch bt) <- r WHERE quantityInvoiceDetail(bt, r);
    rQuantity(s, consolidationKey, r) <- GROUP SUM quantity(ReceivingDetail detail) 
        IF sku(detail)==s AND overConsolidationKey(detail)==consolidationKey AND receiving(detail)==r AND NOT batch(detail) AND NOT completeStatus(detail);
    
    bQuantity(Batch bt) <- 
        (PARTITION UNGROUP rQuantity
            LIMIT quantityInvoiceDetail(bt, r)(-)receivingQuantity(bt, r)
            ORDER bt
        BY sku(bt), overConsolidationKey(bt), receiving(bt)) 
    WHERE sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND receiving(bt)==r;

    bQuantity(s, consolidationKey, r) <- GROUP SUM bQuantity(Batch bt) IF sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND receiving(bt)==r;

    IF bQuantity(s, consolidationKey, r) AND bQuantity(s, consolidationKey, r)==rQuantity(s, consolidationKey, r) THEN {
        DELETE ReceivingDetail detail WHERE detail IS ReceivingDetail AND receiving(detail)==r AND NOT batch(detail) AND sku(detail)==s AND overConsolidationKey(detail)==consolidationKey AND NOT completeStatus(detail);
    }

    IF bQuantity(s, consolidationKey, r) AND NOT bQuantity(s, consolidationKey, r)==rQuantity(s, consolidationKey, r) THEN {
        bQuantity(Batch bt) <- NULL WHERE bQuantity(bt) AND sku(bt)==s AND overConsolidationKey(bt)==consolidationKey AND receiving(bt)==r;
        dataStatus(ReceivingDetail d) <- NULL WHERE sku(d)==s AND overConsolidationKey(d)==consolidationKey AND receiving(d)==r;
        MESSAGE 'В партии приходной накладной не хватает кол-ва для распределения строк приёмки по товару: ' + name(s) + ' и строке группировки: ' + consolidationKey +'\n' NOWAIT;
        CANCEL;
        RETURN;
    }
        
    FOR bQuantity(Batch bt) INLINE NEW d=ReceivingDetail DO{
        receiving(d) <- r;
        sku(d) <- s;
        consolidationKey(d) <- consolidationKey;
        batch(d) <- bt;
        quantity(d) <- bQuantity(bt);
        dataStatus(d) <- ReceivingStatus.fullyReceived;
    }
}

currentBalanceWithoutBatch 'Остаток в ячейке баз партий' (Sku sku, Bin bin) =
    currentBalance(sku, bin) (-) (GROUP SUM currentBalance(Batch batch, bin) IF sku(batch)==sku);

useWriteOffReserveQuantity() += TRUE;
writeOffReserveQuantity(Sku sku, Bin bin) += WHEN sku IS Sku AND bin IS Bin AND useWriteOffReserveQuantity() THEN currentBalanceWithoutBatch(sku, bin);

EXTEND FORM receiving
    FILTERS createShipment(invoice)
;

select 'Отм.' = DATA LOCAL NESTED BOOLEAN (Batch);

putawayBatch 'Разместить' (CustomUser u) {
    NEWSESSION NESTED(select[Batch], dataReceivingBin[CustomUser]) {
        select(Batch batch) <- NULL WHERE select(batch) AND NOT currentBalance(batch, receivingBin(u));
        IF NOT (GROUP MAX select(Batch batch)) THEN {
            select(Batch batch) <- TRUE WHERE currentBalance(batch, receivingBin(u));
        }
        IF NOT (GROUP MAX select(Batch batch)) THEN {
            MESSAGE 'Нечего размещать';
            RETURN;
        }
        IF NOT (GROUP MAX Bin bin IF storage(bin) AND stock(bin)==stock(receivingBin(u))) THEN {
            MESSAGE 'Для склада размещения нет ячеек хранения';
            RETURN;
        }
        IF NOT putawayExternalOperation() THEN {
            MESSAGE 'Не задана \'Операция размещения\' в настройках';
            RETURN;
        }
        FOR (GROUP MAX select(Batch batch) AND currentBalance(batch, receivingBin(u))) NEW o = UserBinTransfer DO {
            operation(o) <- putawayExternalOperation();
            date(o) <- currentDate();
            time(o) <- currentTime();
            stock(o) <- stock(receivingBin(u));
            FOR select(Batch batch) AND currentBalance(batch, receivingBin(u)) INLINE NEW d = UserBinTransferDetail DO {
                userBinTransfer(d) <- o;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- receivingBin(u);
                inBin(d) <- putawayBinOver(sku(batch), stock(receivingBin(u)), putawayExternalOperation(), u);
                quantity(d) <- currentBalance(batch, receivingBin(u));
            }
            DIALOG userBinTransfer OBJECTS o=o MANAGESESSION DO {
                select(Batch batch) <- NULL;
            }
        }
    }
}

putawayBin (Stock st, Bin.Operation o, CustomUser u, BinGroup bg)  = [GROUP LAST Bin bin IF inBin(bin, Bin.Operation o1) AND binGroup2(bin)== BinGroup bg1 AND accessCompany(CustomUser u1, bin) AND NOT prevCurrentBalance(bin) ORDER DESC order(bin), bin BY stock(bin), o1, u1, bg1](st, o, u, bg);
putawayBin  (Sku s, Stock st, Bin.Operation o, CustomUser u, BinGroup bg)  = [GROUP LAST Bin bin IF inBin(bin, Bin.Operation o1) AND binGroup2(bin)== BinGroup bg1 AND accessCompany(CustomUser u1, bin) AND NOT prevCurrentBalance(bin) AND in(Sku sku, bin) ORDER DESC order(bin), bin BY sku, stock(bin), o1, u1, bg1](s, st, o, u, bg);
putawayBinIgnoreBinBalance  (Sku s, Stock st, Bin.Operation o, CustomUser u, BinGroup bg)  = [GROUP LAST Bin bin IF inBin(bin, Bin.Operation o1) AND binGroup2(bin)== BinGroup bg1 AND accessCompany(CustomUser u1, bin) AND in(Sku sku, bin) ORDER DESC order(bin), bin BY sku, stock(bin), o1, u1, bg1](s, st, o, u, bg);
putawayBinIgnoreBinBalance  (Stock st, Bin.Operation o, CustomUser u, BinGroup bg)  = [GROUP LAST Bin bin IF inBin(bin, Bin.Operation o1) AND binGroup2(bin)== BinGroup bg1 AND accessCompany(CustomUser u1, bin) ORDER DESC order(bin), bin BY stock(bin), o1, u1, bg1](st, o, u, bg);

putawayBinOver (Sku sku, Stock stock, Bin.Operation o, CustomUser u, BinGroup bg) =
    OVERRIDE putawayBin(sku, stock, o, u, bg),
        putawayBinIgnoreBinBalance(sku, stock, o, u, bg) IF ignoreBinBalanceDuringPutaway(),
        putawayBin(stock, o, u, bg) IF sku IS Sku,
        putawayBinIgnoreBinBalance(stock, o, u, bg) IF sku IS Sku AND ignoreBinBalanceDuringPutaway();

overInternalBatchPutaway ABSTRACT LIST (CustomUser, UserBinTransfer);
internalBatchPutaway 'Разместить внутри группы ячеек' (CustomUser u) {
    NEWSESSION NESTED(select[Batch], dataReceivingBin[CustomUser]) {
        select(Batch batch) <- NULL WHERE select(batch) AND NOT currentBalance(batch, receivingBin(u));
        IF NOT (GROUP MAX select(Batch batch)) THEN {
            select(Batch batch) <- TRUE WHERE currentBalance(batch, receivingBin(u));
        }
        IF NOT (GROUP MAX select(Batch batch)) THEN {
            MESSAGE 'Нечего размещать';
            RETURN;
        }
        IF NOT (GROUP MAX Bin bin IF storage(bin) AND stock(bin)==stock(receivingBin(u))) THEN {
            MESSAGE 'Для склада размещения нет ячеек хранения';
            RETURN;
        }
        IF NOT putawayInternalOperation() THEN {
            MESSAGE 'Не задана \'Операция размещения(внутри группы ячеек)\' в настройках';
            RETURN;
        }
        FOR (GROUP MAX select(Batch batch) IF currentBalance(batch, receivingBin(u))) NEW o = UserBinTransfer DO {
            operation(o) <- putawayInternalOperation();
            date(o) <- currentDate();
            time(o) <- currentTime();
            stock(o) <- stock(receivingBin(u));
            overInternalBatchPutaway(u, o);
            FOR select(Batch batch) AND currentBalance(batch, receivingBin(u)) INLINE NEW d = UserBinTransferDetail DO {
                userBinTransfer(d) <- o;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- receivingBin(u);
                inBin(d) <- putawayBinOver(sku(batch), stock(receivingBin(u)), putawayInternalOperation(), u, binGroup2(receivingBin(u)));
                quantity(d) <- currentBalance(batch, receivingBin(u));
            }
            DIALOG userBinTransfer OBJECTS o=o MANAGESESSION DO {
                select(Batch batch) <- NULL;
            }
        }
    }
}

putawayReserveBatch 'Разместить' (CustomUser u) {
    NEWSESSION NESTED(select[Batch, Bin], dataReceivingBin[CustomUser]) {
        select(Batch batch, Bin bin) <- NULL WHERE select(batch, bin) AND NOT (currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin));
        IF NOT (GROUP MAX select(Batch batch, Bin bin)) THEN {
            select(Batch batch, Bin bin) <- TRUE WHERE currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin);
        }
        IF NOT (GROUP MAX select(Batch batch, Bin bin)) THEN {
            MESSAGE 'Нечего размещать';
            RETURN;
        }
        IF NOT (GROUP MAX Bin bin IF storage(bin) AND stock(bin)==stock(receivingBin(u))) THEN {
            MESSAGE 'Для склада размещения нет ячеек хранения';
            RETURN;
        }
        IF NOT putawayExternalOperation() THEN {
            MESSAGE 'Не задана \'Операция размещения\' в настройках';
            RETURN;
        }
        FOR (GROUP MAX select(Batch batch, Bin bin) IF currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin)) NEW o = UserBinTransfer DO {
            operation(o) <- putawayExternalOperation();
            date(o) <- currentDate();
            time(o) <- currentTime();
            stock(o) <- stock(receivingBin(u));
            FOR select(Batch batch, Bin bin) AND currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin) INLINE NEW d = UserBinTransferDetail DO {
                userBinTransfer(d) <- o;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- bin;
                inBin(d) <- putawayBinOver(sku(batch), stock(receivingBin(u)), putawayExternalOperation(), u);
                quantity(d) <- currentBalance(batch, bin);
            }
            DIALOG userBinTransfer OBJECTS o=o MANAGESESSION DO {
                select(Batch batch, Bin bin) <- NULL;
            }
        }
    }
}

writeOffReserveBatch 'Списать' (CustomUser u) {
    NEWSESSION NESTED(select[Batch, Bin], dataReceivingBin[CustomUser]) {
        select(Batch batch, Bin bin) <- NULL WHERE select(batch, bin) AND NOT (currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin));
        IF NOT (GROUP MAX select(Batch batch, Bin bin)) THEN {
            select(Batch batch, Bin bin) <- TRUE WHERE currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin);
        }
        IF NOT (GROUP MAX select(Batch batch, Bin bin)) THEN {
            MESSAGE 'Нечего размещать';
            RETURN;
        }
        IF NOT putawayWriteOffOperation() THEN {
            MESSAGE 'Не задана \'Операция списания при размещении\' в настройках';
            RETURN;
        }        
        FOR (GROUP MAX select(Batch batch, Bin bin) IF currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin)) NEW o = UserBinTransfer DO {
            operation(o) <- putawayWriteOffOperation();
            date(o) <- currentDate();
            time(o) <- currentTime();
            stock(o) <- stock(receivingBin(u));
            FOR select(Batch batch, Bin bin) AND currentBalance(batch, bin) AND binGroup2(bin)==binGroup2(receivingBin(u)) AND orderLedger(bin) NEW d = UserBinTransferDetail DO {
                userBinTransfer(d) <- o;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- bin;
                inBin(d) <- NULL;
                quantity(d) <- currentBalance(batch, bin);
            }
            DIALOG userBinTransfer OBJECTS o=o MANAGESESSION DO {
                select(Batch batch, Bin bin) <- NULL;
            }
        }
    }
}

EXTEND FORM receiving
    PROPERTIES(d) READONLY BACKGROUND RGB(255, 224, 255) idBatch, nameBatch 

    OBJECTS bt = Batch
    PROPERTIES(bt) select
    PROPERTIES(bt) READONLY nameSku, idBarcodeSku, overConsolidationKey, id, name, expiryDate
    PROPERTIES READONLY currentBalanceBatch 'Текущий остаток в ячейке' = currentBalance(bt, receivingBin(u))
    PROPERTIES putawayBatch(u) SHOWIF in(u, putawayExternalOperation()) DRAW bt PANEL TOOLBAR
    FILTERS currentBalance(bt, receivingBin(u))

    PROPERTIES READONLY currentBalanceWithoutBatch(rs, rb)
    FILTERS currentBalanceWithoutBatch(rs, rb)

    OBJECTS reserveB = (rsb=Batch, rbb=Bin)
    PROPERTIES select(rsb, rbb)
    PROPERTIES READONLY nameSku(rsb), idBarcodeSku(rsb), overConsolidationKey(rsb), name(rsb), expiryDate(rsb),
        order(rbb), canonicalId(rbb), name(rbb), currentBalance(rsb, rbb)
    ORDERS nameSku(rsb), order(rbb)
    
    PROPERTIES putawayReserveBatch(u) SHOWIF in(u, putawayExternalOperation()) DRAW reserveB PANEL TOOLBAR
    PROPERTIES writeOffReserveBatch(u) SHOWIF in(u, putawayWriteOffOperation()) DRAW reserveB PANEL TOOLBAR
    FILTERS currentBalance(rsb, rbb),
        binGroup2(rbb)==binGroup2(receivingBin(u)),
        orderLedger(rbb)

    OBJECTS putawayBatch = BinTransferDetail
    PROPERTIES(putawayBatch) READONLY dateTime, idBarcodeSku, nameSku, canonicalIdInBin, canonicalIdOutBin, quantity
    FILTERS dFrom<=date(putawayBatch) AND dTo>=date(putawayBatch),
        accessCompany(u, inBin(putawayBatch)),
        outBin(putawayBatch) = receivingBin(u),
        operation(putawayBatch) = putawayExternalOperation()
;

DESIGN receiving {
    tabContainer{
        putaway{
            REMOVE BOX(s);
            MOVE BOX(bt);
        }
        stocked{
            REMOVE BOX(putawaySku);
            MOVE BOX(putawayBatch);
        }
        REMOVE BOX(reserve); //удаляем, т.к. расписывание по партиям НЕ предполагает товара на приёмке, которого нет в накладной
        MOVE BOX(reserveB){
            caption = 'Брак/резерв (партии)';
        }
    }
}

FORM internalPutaway 'Размещение по группе ячеек'
    OBJECTS u=CustomUser PANEL
    PROPERTIES(u) READONLY name
    PROPERTIES(u) nameReceivingBin, nameBinGroup2ReceivingBin READONLY
    FILTERS u=currentUser()

    OBJECTS bt = Batch
    PROPERTIES(bt) select
    PROPERTIES(bt) READONLY nameSku, idBarcodeSku, name, expiryDate
    PROPERTIES READONLY currentBalanceBatch 'Текущий остаток в ячейке' = currentBalance(bt, receivingBin(u))
    PROPERTIES internalBatchPutaway(u) SHOWIF in(u, putawayInternalOperation()) DRAW bt PANEL TOOLBAR
    FILTERS currentBalance(bt, receivingBin(u))

    OBJECTS putawayBatch = BinTransferDetail
    PROPERTIES(putawayBatch) READONLY dateTime, idBarcodeSku, nameSku, canonicalIdInBin, canonicalIdOutBin
    PROPERTIES READONLY currentBalancePB 'Текущий остаток в ячейке' = currentBalance(batch(putawayBatch), inBin(putawayBatch))
    FILTERS currentBalance(batch(putawayBatch),
        inBin(putawayBatch)),
        accessCompany(u, inBin(putawayBatch)),
        outBin(putawayBatch) = receivingBin(u),
        operation(putawayBatch) = putawayInternalOperation()
;

DESIGN internalPutaway {
    MOVE BOX(u){
        PROPERTY(name(u)) {
            font = 'bold 24';
            panelCaptionVertical = TRUE;
            focusable = FALSE;
            charWidth = 30;
        }
        PROPERTY(nameReceivingBin(u)) {
            font = 'bold 24';
            panelCaptionVertical = TRUE;
            charWidth = 30;
        }
        PROPERTY(nameBinGroup2ReceivingBin(u)) {
            font = 'bold 24';
            panelCaptionVertical = TRUE;
            charWidth = 30;
        }
    }
    NEW tabContainer {
        tabbed = TRUE;
        fill = 1;
        NEW putaway {
            caption = 'Размещение';
            MOVE BOX(bt);
        }
        NEW stocked {
            caption = 'Размещенные';
            MOVE BOX(putawayBatch);
        }

    }
    MOVE TOOLBARBOX;
}

NAVIGATOR {
    WMSDashboardNavigator {
        NEW internalPutaway;
    }
}

afterCreateCreditNoteReceiving ABSTRACT (CreditNote);

diffCompleted 'Разница между обработанным количеством и количеством в документе прихода'(Sku s, STRING str, Receiving r) =
    expectedQuantity(s, str, r) (-) quantityCompleted(s, str, r);

countInvoiceDetail(Receiving r, CreditNote c) = [GROUP SUM 1 BY receiving(invoice(invoiceDetail(CreditNoteDetail d))), creditNote(d)](r, c);

quantityCreditNote 'Кол-во в актах расхождений' (Sku s, STRING str, Receiving r) =
    [GROUP SUM quantity(CreditNoteDetail d) BY sku(d), overConsolidationKey(d), receiving(invoice(invoiceDetail(d)))](s, str, r) MATERIALIZED;

diffInvoiceCreditNoteCompleted 'Разница между обработанным количеством и количеством в документе прихода с учетом актов расхождений'(Sku s, STRING str, Receiving r) =
    diffCompleted(s, str, r) (-) quantityCreditNote(s, str, r);

//расхождение по кол-ву
quantityVarianceToPartition = DATA LOCAL NUMERIC[16,5] (Sku, STRING, Receiving);
quantityVariance(InvoiceDetail detail) = 
    PARTITION UNGROUP quantityVarianceToPartition LIMIT quantity(detail) ORDER detail BY sku(detail), overConsolidationKey(detail), receiving(invoice(detail));

//расхождение по качеству
qualityVarianceToPartition = DATA LOCAL NUMERIC[16,5] (Sku, STRING, Receiving);
qualityVariance(InvoiceDetail detail) =
    PARTITION UNGROUP qualityVarianceToPartition LIMIT quantity(detail) ORDER detail BY sku(detail), overConsolidationKey(detail), receiving(invoice(detail));

showCreateCreditNote (Sku s, STRING str, Receiving r) =
    GROUP SUM 1 IF completeStatus(r) AND diffInvoiceCreditNoteCompleted(s, str, r); 

createCreditNoteQuantityVariance ABSTRACT (Invoice);
createCreditNoteQualityVariance ABSTRACT (Invoice);

extraCreateCreditNote ABSTRACT LIST (Receiving, Invoice);
createCreditNote 'Создать акт расхождения' (Receiving r) {
    quantityVarianceToPartition(Sku s, STRING str, r) <- diffInvoiceCreditNoteCompleted(s, str, r) WHERE expectedQuantity(s, str, r);
    qualityVarianceToPartition(Sku s, STRING str, r) <- 
        GROUP SUM quantity(ReceivingDetail rd) IF sku(rd)==s AND overConsolidationKey(rd)==str AND receiving(rd)==r AND orderLedger(inBin(rd)) AND receiving(inBin(rd));
    IF (GROUP SUM quantityVarianceToPartition(Sku s, STRING str, r)) THEN {
        FOR receiving(Invoice i) = r AND [GROUP SUM quantityVariance(InvoiceDetail d) BY invoice(d)](i) DO {
            createCreditNoteQuantityVariance(i);
        }
    }
    IF (GROUP SUM qualityVarianceToPartition(Sku s, STRING str, r)) THEN {
        FOR receiving(Invoice i) = r AND [GROUP SUM qualityVariance(InvoiceDetail d) BY invoice(d)](i) DO {
            createCreditNoteQualityVariance(i);
        }
    }
    IF (GROUP SUM quantityVarianceToPartition(Sku s, STRING str, r)) OR (GROUP SUM qualityVarianceToPartition(Sku s, STRING str, r)) THEN {
        FOR CreditNote c == userCreditNote(Invoice invoice) AND receiving(invoice) == r DO {
            afterCreateCreditNoteReceiving(c);
        }
        
        LOCAL qualityVariance = NUMERIC[16,5] (Batch, Bin);
        qualityVariance(Batch batch, Bin bin) <- GROUP SUM quantity(ReceivingDetail rd) IF batch(rd)==batch AND inBin(rd)==bin AND receiving(rd)==r AND orderLedger(inBin(rd)) AND receiving(inBin(rd));
        
        //todo: надо переделать на ячейки в строке акта расхождения
        FOR (GROUP SUM qualityVariance(Batch batch, Bin bin)) NEW o = UserBinTransfer DO {
            operation(o) <- putawayWriteOffOperation();
            date(o) <- currentDate();
            time(o) <- currentTime();
            stock(o) <- stock(GROUP MAX Bin bin IF qualityVariance(Batch batch, bin));
            FOR qualityVariance(Batch batch, Bin bin) NEW d = UserBinTransferDetail DO {
                userBinTransfer(d) <- o;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- bin;
                inBin(d) <- NULL;
                quantity(d) <- qualityVariance(batch, bin);
            }
        }
        APPLY;
    }
} TOOLBAR;

extraCompleteReceiving(Receiving r) + {
    IF (GROUP SUM 1 IF showCreateCreditNote(Sku s, STRING str, r)) THEN {
        ASK 'Создать акт расхождения?' DO {
            createCreditNote(r);    
        }
    }
}

quantityCreditNote 'Кол-во в актах расхождений' =
    GROUP SUM quantity(CreditNoteDetail d) BY sku(d), receiving(invoice(invoiceDetail(d)));

hasReceiving = GROUP SUM 1 BY receiving(invoice(invoiceDetail(CreditNoteDetail d))), creditNote(d);

descriptionCreditNotes 'Акты расхождения' =
    GROUP CONCAT seriesNumber(CreditNote creditNote) IF hasReceiving(Receiving receiving, creditNote), '; ' ORDER dateTime(creditNote), creditNote BY receiving;

EXTEND FORM receiving
    PROPERTIES READONLY descriptionCreditNotes(r) AFTER descriptionInvoices(r)
    PROPERTIES createCreditNote(r) SHOWIF (GROUP SUM 1 IF showCreateCreditNote(Sku sku, STRING str, r)) DRAW r
    PROPERTIES READONLY quantityCreditNote(sr1, str1, r)
    PROPERTIES READONLY quantityCreditNote(sr, r)

    OBJECTS c = CreditNote LAST
    PROPERTIES(c) READONLY BACKGROUND background(c) isClosed, isPosted, number, series, date, time, nameSupplier,
        nameSupplierStock, nameCustomer, nameCustomerStock, nameCurrency, seriesNumberContractSku, isCommission
    PROPERTIES(c) READONLY BACKGROUND background(c) countCreditNoteDetail, quantityCreditNoteDetail, sumCreditNoteDetail,
        VATSumCreditNoteDetail, invoiceSumCreditNoteDetail
    PROPERTIES(c) READONLY note
    PROPERTIES(c) EDIT

    PROPERTIES print(c)
;


DESIGN receiving {
    tabContainer {
        NEW creditNote {
            caption = 'Акты расхождений';
            MOVE BOX(c);
            NEW printContainer {
                caption = 'Печать';
                MOVE PROPERTY(print(c));
            }
        }
    }
}