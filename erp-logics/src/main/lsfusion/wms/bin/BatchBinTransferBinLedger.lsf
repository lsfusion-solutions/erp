MODULE BatchBinTransferBinLedger;

REQUIRE BatchBinSkuLedger, BinTransferBinLedger, BatchBinOrderBinLedger;

NAMESPACE Bin;

@defineDocumentInterfaceDetailBatch(binTransfer, batch);

//todo: вернуть метакод, когда починят баг с тремя ###
//@implementDocumentBatch(userBinTransfer);

batch[DocumentDetail](UserBinTransferDetail detail) += batch(detail);
skipFillBatch = ABSTRACT CASE BOOLEAN (UserBinTransferDetail);
overFillDocument (UserBinTransferDetail i, DocumentDetail d) + {
    IF NOT skipFillBatch(i) THEN {
        batch(i) <- batch(d);
    }
}


@implementDocumentBatchForm(bt);

EXTEND FORM userBinTransfer
    PROPERTIES(d) AFTER shortNameUOMSku(d) idBatch, nameBatch
;

overCopy(UserBinTransferDetail d, BinTransferDetail transferDetail) + {
    batch(d) <- batch(transferDetail);
}
overCopy[UserBinTransferDetail,UserBinTransferDetail](UserBinTransferDetail d, UserBinTransferDetail detail) + {
    batch(d) <- batch(detail);
}

EXTEND FORM binTransfers
    PROPERTIES(d) READONLY AFTER shortNameUOMSku(d) idBatch, nameBatch
;

CONSTRAINT isPosted(BinTransferDetail d) AND isBatch(operation(d)) AND sku(d) AND NOT skipFillBatch(d) AND NOT batch(d)
    MESSAGE 'Для строки перемещения по ячейкам должна быть задана партия';

@defineDocumentBatchStockPriceListTypeSystemLedger(userBinTransfer, );

@showDocumentInterfaceDetailBatch(binTransfer);

@extendFormDocumentBatchStock(userBinTransfer, userBinTransfer, o, , ); 

DESIGN userBinTransfer {
    REMOVE BOX(sts);   
}

bins 'Ячейки с остатком' (Batch batch, BinTransfer transfer) = bins(batch, stock(transfer));
prevCurrentBalanceOutBin 'Текущий остаток (ячейка из)' (Batch batch, BinTransfer transfer) = prevCurrentBalance(batch, outBin(transfer));
prevCurrentBalanceInBin 'Текущий остаток (ячейка в)' (Batch batch, BinTransfer transfer) = prevCurrentBalance(batch, inBin(transfer));

EXTEND FORM userBinTransfer
    PROPERTIES (b, o) READONLY AFTER prevCurrentBalance(b, sto) bins, prevCurrentBalanceOutBin, prevCurrentBalanceInBin
    FILTERGROUP filterBatch
        FILTER 'С остатком (ячейка из)' prevCurrentBalanceOutBin(b, o) 'F7' 
        FILTER 'С остатком' currentBalance(b, sto) 'F10' DEFAULT
        FILTER 'В документе' quantity(b, o, sto) 'F9'
;
    
@implementBatchBinLedger(binTransferDetail, stock);

skipSetInBin(UserBinTransferDetail d) += TRUE IF inBin(d);
skipSetOutBin(UserBinTransferDetail d) += TRUE IF outBin(d);

userBinTransferDetail (batch, userBinTransfer, bin, stock) =  
    GROUP MAX UserBinTransferDetail detail BY batch(detail), userBinTransfer(detail), outBin(detail), stock(detail);

userBinTransferDetail (batch, userBinTransfer, bin) =  
    GROUP MAX UserBinTransferDetail detail BY batch(detail), userBinTransfer(detail), outBin(detail);

quantity 'Кол-во товара в документе' (batch, userBinTransfer, bin, stock) = 
    GROUP SUM quantity(UserBinTransferDetail detail) BY batch(detail), userBinTransfer(detail), outBin(detail), stock(detail);

backgroundQuantity 'Цвет' (batch, userBinTransfer, bin, stock) = ABSTRACT CASE COLOR (Batch, UserBinTransfer, Bin, Stock);

changeQuantityValue(Batch batch, UserBinTransfer userBinTransfer, Bin bin, Stock stock, NUMERIC[16,5] n)  {
    IF userBinTransferDetail(batch, userBinTransfer, bin, stock) THEN {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            quantity(UserBinTransferDetail userBinTransferDetail) <- n WHERE userBinTransferDetail == userBinTransferDetail(batch, userBinTransfer, bin, stock);
            overChangeQuantityValueBatch(userBinTransferDetail(batch, userBinTransfer, bin, stock));
        } ELSE {
            FOR userBinTransferDetail(batch, userBinTransfer, bin, stock) == UserBinTransferDetail d DO
                DELETE d;
        }
    } ELSE {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            NEW d = UserBinTransferDetail {
                userBinTransfer(d) <- userBinTransfer;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                outBin(d) <- bin;
                quantity(d) <- n;
                overChangeQuantityValueBatch(d);
            }
        }
    }
}

changeQuantity(Batch batch, UserBinTransfer userBinTransfer, Bin bin, Stock stock)  {
    INPUT n = NUMERIC[16,5] DO
        changeQuantityValue(batch, userBinTransfer, bin, stock, n);
}

allQuantity 'Весь остаток' = DATA LOCAL BOOLEAN (Batch, UserBinTransfer, Bin, Stock);
changeAllQuantity(Batch batch, UserBinTransfer userBinTransfer, Bin bin, Stock stock) {
    INPUT b = BOOLEAN DO {
        allQuantity (batch, userBinTransfer, bin, stock) <- b;
        changeQuantityValue(batch, userBinTransfer, bin, stock, prevCurrentBalance(batch, bin) IF b);
    }
}

EXTEND FORM userBinTransfer
    OBJECTS bin = Bin GRID
    PROPERTIES(bin) order, canonicalId
    PROPERTIES quantity(b, o, bin, sto) ON CHANGE changeQuantity(b, o, bin, sto) BACKGROUND backgroundQuantity(b, o, bin, sto)
    PROPERTIES prevCurrentBalance(b, bin)
    ORDERS order(bin), canonicalId(bin)
    FILTERS stock(bin) == sto

    FILTERGROUP filterBatchBin
        FILTER 'С остатком' prevCurrentBalance(b, bin) DEFAULT
        FILTER 'В документе' quantity(b, o, bin, sto)        
;

DESIGN userBinTransfer {
    BOX(stb) { 
        GRID(stb) {
            fill = 3;            
        }
        MOVE BOX(bin) {
            fill = 1;
            caption = 'Ячейки';
            PROPERTY(prevCurrentBalance(b, bin)) { background = #FFEEEE; }
            PROPERTY(quantity(b, o, bin, sto)) { background = #D4FFD4; }
        }
    }
}
