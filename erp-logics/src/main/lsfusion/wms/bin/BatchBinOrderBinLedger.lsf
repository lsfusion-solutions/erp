MODULE BatchBinOrderBinLedger;

REQUIRE BinOrderBinLedger, BatchBinSkuLedger;

NAMESPACE Bin;

@defineDocumentInterfaceDetailBatch(binOrder, batch);

//todo: вернуть метакод, когда починят баг с тремя ###
//@implementDocumentBatch(userBinOrder);

batch[DocumentDetail](UserBinOrderDetail detail) += batch(detail);
skipFillBatch = ABSTRACT CASE BOOLEAN (UserBinOrderDetail);
overFillDocument (UserBinOrderDetail i, DocumentDetail d) + {
    IF NOT skipFillBatch(i) THEN {
        batch(i) <- batch(d);
    }
}

@implementDocumentBatchForm(bo);

idBatch 'Код партии' (BinOrderDetail detail) = id(batch(detail));
idBatch 'Код партии' (UserBinOrderDetail detail) = id(batch(detail));

EXTEND FORM userBinOrder
    PROPERTIES(d) AFTER shortNameUOMSku(d) idBatch, nameBatch
;

overCopy(UserBinOrderDetail d, BinOrderDetail binOrderDetail) + {
    batch(d) <- batch(binOrderDetail);
}
overCopy[UserBinOrderDetail,UserBinOrderDetail](UserBinOrderDetail d, UserBinOrderDetail binOrderDetail) + {
    batch(d) <- batch(binOrderDetail);
}

EXTEND FORM binOrders
    PROPERTIES(d) READONLY AFTER shortNameUOMSku(d) idBatch, nameBatch
;

@defineOperationProperty(isBatch, 'Должна быть задана партия', constraintContainer);

CONSTRAINT isPosted(BinOrderDetail d) AND isBatch(operation(d)) AND sku(d) AND NOT skipFillBatch(d) AND NOT batch(d)
    MESSAGE 'Для строки заказа на перемещения по ячейкам должна быть задана партия';

@defineDocumentBatchStockPriceListTypeSystemLedger(userBinOrder, );

@showDocumentInterfaceDetailBatch(binOrder);

@extendFormDocumentBatchStock(userBinOrder, userBinOrder, o, , );

DESIGN userBinOrder {
    REMOVE BOX(sts);
}

bins 'Ячейки с остатком' (Batch batch, BinOrder binOrder) = bins(batch, stock(binOrder));
prevCurrentBalanceOutBin 'Текущий остаток (ячейка из)' (Batch batch, BinOrder binOrder) = prevCurrentBalance(batch, outBin(binOrder));
prevCurrentBalanceInBin 'Текущий остаток (ячейка в)' (Batch batch, BinOrder binOrder) = prevCurrentBalance(batch, inBin(binOrder));

EXTEND FORM userBinOrder
    PROPERTIES (b, o) READONLY AFTER prevCurrentBalance(b, sto) bins, prevCurrentBalanceOutBin, prevCurrentBalanceInBin
    FILTERGROUP filterBatch
        FILTER 'С остатком (ячейка из)' prevCurrentBalanceOutBin(b, o) 'F7'
        FILTER 'С остатком ' currentBalance(b, sto) 'F10' DEFAULT
        FILTER 'В документе ' quantity(b, o, sto) 'F9'
;

skipSetInBin(UserBinOrderDetail d) += TRUE IF inBin(d);
skipSetOutBin(UserBinOrderDetail d) += TRUE IF outBin(d);

userBinOrderDetail (batch, userBinOrder, bin, stock) =  GROUP MAX UserBinOrderDetail detail
    BY batch(detail), userBinOrder(detail),  outBin(detail), stock(detail);

userBinOrderDetail (batch, userBinOrder, bin) =  GROUP MAX UserBinOrderDetail detail
    BY batch(detail), userBinOrder(detail), outBin(detail);

quantity 'Кол-во товара в документе' (batch, userBinOrder, bin, stock) = GROUP SUM quantity(UserBinOrderDetail detail)
    BY batch(detail), userBinOrder(detail), outBin(detail), stock(detail);

backgroundQuantity 'Цвет' (batch, userBinOrder, bin, stock) = ABSTRACT CASE COLOR (Batch, UserBinOrder, Bin, Stock);

changeQuantityValue(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock, NUMERIC[16,5] n)  {
    IF userBinOrderDetail(batch, userBinOrder, bin, stock) THEN {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            quantity(UserBinOrderDetail detail) <- n WHERE detail == userBinOrderDetail(batch, userBinOrder, bin, stock);
            overChangeQuantityValueBatch(userBinOrderDetail(batch, userBinOrder, bin, stock));
        } ELSE {
            FOR userBinOrderDetail(batch, userBinOrder, bin, stock) == UserBinOrderDetail d DO
                DELETE d;
        }
    } ELSE {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            NEW d = UserBinOrderDetail {
                userBinOrder(d) <- userBinOrder;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                quantity (d) <- n;
                outBin(d) <- bin;
                overChangeQuantityValueBatch(d);
            }
        }
    }
}

changeQuantity(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT n = NUMERIC[16,5] DO
        changeQuantityValue(batch, userBinOrder, bin, stock, n);
}

allQuantity 'Весь остаток' = DATA LOCAL BOOLEAN (Batch, UserBinOrder, Bin, Stock);
changeAllQuantity(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT b = BOOLEAN DO {
        allQuantity (batch, userBinOrder, bin, stock) <- b;
        changeQuantityValue(batch, userBinOrder, bin, stock, prevCurrentBalance(batch, stock) IF b);
    }
}

EXTEND FORM userBinOrder
    OBJECTS bin = Bin GRID
    PROPERTIES(bin) order, canonicalId
    PROPERTIES quantity(b, o, bin, sto) ON CHANGE changeQuantity(b, o, bin, sto) BACKGROUND backgroundQuantity(b, o, bin, sto)
    PROPERTIES prevCurrentBalance(b, bin)
    ORDERS order(bin), canonicalId(bin)
    FILTERS stock(bin) == sto

    FILTERGROUP filterBatchBin
        FILTER 'С остатком' prevCurrentBalance(b, bin) DEFAULT
        FILTER 'В документе' quantity(b, o, bin, sto)        
;

DESIGN userBinOrder {
    BOX(stb) {
        GRID(stb) {
            fill = 3;
        }
        MOVE BOX(bin) {
            fill = 1;
            caption = 'Ячейки';
            PROPERTY(prevCurrentBalance(b, bin)) { background = #FFEEEE; }
            PROPERTY(quantity(b, o, bin, sto)) { background = #D4FFD4; }
        }
    }
}