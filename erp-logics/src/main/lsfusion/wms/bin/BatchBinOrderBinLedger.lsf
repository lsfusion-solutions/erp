MODULE BatchBinOrderBinLedger;

REQUIRE BinOrderBinLedger, BatchBinSkuLedger;

NAMESPACE Bin;

@defineDocumentInterfaceDetailBatch(binOrder, batch);

//todo: вернуть метакод, когда починят баг с тремя ###
//@implementDocumentBatch(userBinOrder);

batch[DocumentDetail](UserBinOrderDetail detail) += batch(detail);
skipFillBatch = ABSTRACT CASE BOOLEAN (UserBinOrderDetail);
overFillDocument (UserBinOrderDetail i, DocumentDetail d) + {
    IF NOT skipFillBatch(i) THEN {
        batch(i) <- batch(d);
    }
}

@implementDocumentBatchForm(bo);

EXTEND FORM userBinOrder
    PROPERTIES(d) AFTER shortNameUOMSku(d) nameBatch
;

overCopy(UserBinOrderDetail d, BinOrderDetail binOrderDetail) + {
    batch(d) <- batch(binOrderDetail);
}
overCopy[UserBinOrderDetail,UserBinOrderDetail](UserBinOrderDetail d, UserBinOrderDetail binOrderDetail) + {
    batch(d) <- batch(binOrderDetail);
}

EXTEND FORM binOrders
    PROPERTIES(d) READONLY AFTER shortNameUOMSku(d) nameBatch
;

@defineOperationProperty(isBatch, 'Должна быть задана партия', constraintContainer);

CONSTRAINT isPosted(BinOrderDetail d) AND isBatch(operation(d)) AND sku(d) AND NOT skipFillBatch(d) AND NOT batch(d)
    MESSAGE 'Для строки заказа на перемещения по ячейкам должна быть задана партия';

@defineDocumentBatchStockPriceListTypeSystemLedger(userBinOrder, );

@showDocumentInterfaceDetailBatch(binOrder);

@extendFormDocumentBatchStock(userBinOrder, userBinOrder, o, , );

DESIGN userBinOrder {
    REMOVE BOX(sts);
}

bins 'Ячейки с остатком' (Batch batch, BinOrder binOrder) = bins(batch, stock(binOrder));
prevCurrentBalanceOutBin 'Текущий остаток (ячейка из)' (Batch batch, BinOrder binOrder) = prevCurrentBalance(batch, outBin(binOrder));
prevCurrentBalanceInBin 'Текущий остаток (ячейка в)' (Batch batch, BinOrder binOrder) = prevCurrentBalance(batch, inBin(binOrder));

EXTEND FORM userBinOrder
    PROPERTIES (b, o) READONLY AFTER prevCurrentBalance(b, sto) bins, prevCurrentBalanceOutBin, prevCurrentBalanceInBin
    FILTERGROUP filterBatch
        FILTER 'С остатком (ячейка из)' prevCurrentBalanceOutBin(b, o) 'F7'
        FILTER 'С остатком ' currentBalance(b, sto) 'F10' DEFAULT
        FILTER 'В документе ' quantity(b, o, sto) 'F9'
;

skipSetInBin(UserBinOrderDetail d) += TRUE IF inBin(d);
skipSetOutBin(UserBinOrderDetail d) += TRUE IF outBin(d);

userBinOrderDetail (batch, userBinOrder, bin, stock) =  GROUP MAX UserBinOrderDetail detail
    BY batch(detail), userBinOrder(detail),  outBin(detail), stock(detail);

userBinOrderDetail (batch, userBinOrder, bin) =  GROUP MAX UserBinOrderDetail detail
    BY batch(detail), userBinOrder(detail), outBin(detail);

quantity 'Кол-во товара в документе' (batch, userBinOrder, bin, stock) = GROUP SUM quantity(UserBinOrderDetail detail)
    BY batch(detail), userBinOrder(detail), outBin(detail), stock(detail);

backgroundQuantity 'Цвет' (batch, userBinOrder, bin, stock) = ABSTRACT CASE COLOR (Batch, UserBinOrder, Bin, Stock);

changeQuantityValue(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock, NUMERIC[16,5] n)  {
    IF userBinOrderDetail(batch, userBinOrder, bin, stock) THEN {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            quantity(UserBinOrderDetail detail) <- n WHERE detail == userBinOrderDetail(batch, userBinOrder, bin, stock);
            overChangeQuantityValueBatch(userBinOrderDetail(batch, userBinOrder, bin, stock));
        } ELSE {
            FOR userBinOrderDetail(batch, userBinOrder, bin, stock) == UserBinOrderDetail d DO
                DELETE d;
        }
    } ELSE {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            NEW d = UserBinOrderDetail {
                userBinOrder(d) <- userBinOrder;
                sku(d) <- sku(batch);
                batch(d) <- batch;
                quantity (d) <- n;
                outBin(d) <- bin;
                overChangeQuantityValueBatch(d);
            }
        }
    }
}

changeQuantity(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT n = NUMERIC[16,5] DO
        changeQuantityValue(batch, userBinOrder, bin, stock, n);
}

allQuantity 'Весь остаток' = DATA LOCAL BOOLEAN (Batch, UserBinOrder, Bin, Stock);
changeAllQuantity(Batch batch, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT b = BOOLEAN DO {
        allQuantity (batch, userBinOrder, bin, stock) <- b;
        changeQuantityValue(batch, userBinOrder, bin, stock, prevCurrentBalance(batch, stock) IF b);
    }
}

EXTEND FORM userBinOrder
    OBJECTS bin = Bin GRID
    PROPERTIES(bin) order, canonicalId
    PROPERTIES quantity(b, o, bin, sto) ON CHANGE changeQuantity(b, o, bin, sto) BACKGROUND backgroundQuantity(b, o, bin, sto)
    PROPERTIES prevCurrentBalance(b, bin)
    ORDERS order(bin), canonicalId(bin)

    FILTERS prevCurrentBalance(b, bin),
        stock(bin) == sto
;

DESIGN userBinOrder {
    BOX(stb) {
        GRID(stb) {
            fill = 3;
        }
        MOVE BOX(bin) {
            fill = 1;
            caption = 'Ячейки';
            PROPERTY(prevCurrentBalance(b, bin)) { background = #FFEEEE; }
            PROPERTY(quantity(b, o, bin, sto)) { background = #D4FFD4; }
        }
    }
}