MODULE BinOrderBinLedger;

REQUIRE Bin, Document, BinLedger, Operation, StockSkuDocument, PurchasePack;

NAMESPACE Bin;

CLASS ABSTRACT BinOrder 'Заказ на перемещение по ячейкам';
CLASS ABSTRACT BinOrderDetail 'Строка заказа на перемещение по ячейкам';

//--- !Необходимо для каждой реализации BinOrder и BinOrderDetail делать зависимость на Document и DocumentDetail! --// 
//Если наследовать в BinOrder и BinOrderDetail, то невозможно от них наследовать те классы, что уже наследованы от Document и DocumentDetail

CLASS UserBinOrder 'Заказ на перемещение по ячейкам (польз.)': BinOrder, Document;
CLASS UserBinOrderDetail 'Строка заказа на перемещение по ячейкам': BinOrderDetail, DocumentDetail;

selected 'Отм.' = DATA LOCAL BOOLEAN (BinOrder); 

@defineDocumentInterface(binOrder);

@defineAddDetailDialogBarcode(userBinOrder, sku);

@defineDocumentInterfaceDetailPrice(binOrder);

@deriveDocumentHeaderTimePrefix(UserBinOrder, );

@defineDocumentInterfaceNumber(binOrder, BPSTRING[2]);

@defineDocumentAbstractHeaderPosted(BinOrder);
@defineDocumentDetailPosted(binOrder, BinOrderDetail);

isPosted[BinOrder](UserBinOrder o) += o IS UserBinOrder; //Пользовательский документ всегда считаем проведеным

@defineDocumentInterfaceClosed(binOrder);

@defineDocumentInterfaceDataStock(binOrder, stock, 'Склад');

@defineDocumentInterfaceDescription(binOrder, 'Заказ на перемещение по ячейкам');

@defineDocumentInterfaceDetailSku(binOrder, sku);

INDEX sku(BinOrderDetail d), binOrder(d);

@defineDocumentInterfaceDetailQuantity(binOrder);

balanceB 'Остаток (до)' = ABSTRACT NUMERIC[16,5] (BinOrderDetail) MATERIALIZED;
balanceB 'Остаток (до)' = DATA NUMERIC[16,5] (UserBinOrderDetail);
balanceB (UserBinOrderDetail binOrderDetail) += balanceB(binOrderDetail);   

@defineDocumentDetailGrossWeight(binOrder, sku);

@defineDocumentHeaderSkuQuantity(binOrder, sku);

@defineDocumentHeaderQuantity(binOrder);

@defineDocumentBins(binOrder);

INDEX outBin(BinOrderDetail d), sku(d);

@defineBinDocumentConstraints(userBinOrder);

//todo: вернуть метакод, когда починят баг с тремя ###
//@implementDocument(userBinOrder);

isClosed[Document](UserBinOrder userBinOrder) += isClosed(userBinOrder);
isPosted[Document](UserBinOrder userBinOrder) += userBinOrder IS UserBinOrder;
number[Document](UserBinOrder userBinOrder) += number(userBinOrder);
series[Document](UserBinOrder userBinOrder) += series(userBinOrder);
date[Document](UserBinOrder userBinOrder) += date(userBinOrder);

index[DocumentDetail](UserBinOrderDetail detail) += index(detail);
sku[DocumentDetail](UserBinOrderDetail detail) += sku(detail);
quantity[DocumentDetail](UserBinOrderDetail detail) += quantity(detail);
price[DocumentDetail](UserBinOrderDetail detail) += price(detail);

document[DocumentDetail](UserBinOrderDetail detail) += userBinOrder(detail);

overFillDocument  ABSTRACT LIST (UserBinOrderDetail, DocumentDetail);
fillDocument 'Подбор документа'(UserBinOrder userBinOrder)  {
    DIALOG documents DO {
        FOR inSession(document(DocumentDetail documentDetail)) NEW i = UserBinOrderDetail DO {
            userBinOrder(i) <- userBinOrder;
            sku(i) <- sku(documentDetail);
            quantity(i) <- quantity(documentDetail);
            price(i) <- price(documentDetail) WHERE fillPriceDocuments();
            overFillDocument(i, documentDetail);
        }
    }
} TOOLBAR;
supplierStock[Document](UserBinOrder binOrder) += stock(binOrder);

@implementDocumentForm(binOrder, bo, 'Заказ на перемещение по ячейкам');

@defineAddDetailDialogSkuStock(userBinOrder, sku, stock, dialogSku);

//пользовательский заказ на перемещение
@defineExternalizable(userBinOrder, STRING[100]);

@defineExternalizable(userBinOrderDetail, STRING[100]);

@defineNumeratedDefault(UserBinOrder, 'Заказы на перемещение по ячейкам ', 'ЗП');

//вес заказа
sumGrossWeight 'Вес брутто, кг' = ABSTRACT NUMERIC[14,3] (BinOrderDetail);        
sumGrossWeight 'Вес брутто, кг' = DATA NUMERIC[14,3] (UserBinOrderDetail);
sumGrossWeight(UserBinOrderDetail d) += sumGrossWeight(d);
   
sumGrossWeight(UserBinOrderDetail d) <- grossWeight(sku(d)) * quantity(d)
    WHEN CHANGED(sku(d)) OR CHANGED(quantity(d));
              
@defineDocumentHeaderGrossWeightCustomPrefix (binOrder, binOrderDetail, sum, ', кг');
@defineDocumentHeaderGrossWeightCustomPrefix (userBinOrder, userBinOrderDetail, sum, ', кг'); 

@defineDocumentDialogStocks(userBinOrder, stock, company, , );

performer 'Исполнитель' = ABSTRACT Employee (BinOrder);
namePerformer 'Исполнитель' (BinOrder order) = name(performer(order));

performer 'Исполнитель' = DATA Employee (UserBinOrder);
namePerformer 'Исполнитель' (UserBinOrder order) = name(performer(order));

performer (UserBinOrder order) += performer(order);

startPerformDateTime 'Начало выполнения' = ABSTRACT DATETIME (BinOrder);
startPerformDateTime 'Начало выполнения' = DATA DATETIME (UserBinOrder);
startPerformDateTime (UserBinOrder order) += startPerformDateTime(order);

finishPerformDateTime 'Окончание выполнения' = ABSTRACT DATETIME (BinOrder);
finishPerformDateTime 'Окончание выполнения' = DATA DATETIME (UserBinOrder);
finishPerformDateTime (UserBinOrder order) += finishPerformDateTime(order);

//автоматическое закрытие заказов
closeDateTime 'Дата/время автоматического закрытия' = ABSTRACT DATETIME (BinOrder) IN documentPrm;
closeDateTime 'Дата/время автоматического закрытия' = DATA DATETIME (UserBinOrder) IN documentPrm;
closeDateTime(UserBinOrder order) += closeDateTime(order);

quantityMinutesCloseBinOrders 'Количество минут для автоматического закрытия заказа' = DATA INTEGER ();

closeDateTime(UserBinOrder order) <- sumMinutes(dateTime(order), quantityMinutesCloseBinOrders())
            WHEN CHANGED(dateTime(order));
            
EXTEND FORM options
    PROPERTIES () quantityMinutesCloseBinOrders
;
         
DESIGN options {
    pane {
        WMS {
            MOVE PROPERTY(quantityMinutesCloseBinOrders());    
        }
    }
}

autoCloseBinOrder 'Автоматическое закрытие заказов' ()  { 
    FOR closeDateTime(BinOrder order)<=currentDateTime() AND isOpened(order) DO {
        isClosed(order) <- TRUE;
    }
    APPLY {};
}
            
FORM userBinOrder 'Заказ на перемещение по ячейкам (польз.)'
    OBJECTS o = UserBinOrder PANEL
    PROPERTIES (o) nameStock ON CHANGE changeStockCompany(o), nameNumerator, number, series, date, time, note
    PROPERTIES (o) READONLY countUserBinOrderDetail, quantityBinOrderDetail, sumGrossWeightUserBinOrderDetail
    PROPERTIES (o) closeDateTime
    
    OBJECTS d = UserBinOrderDetail
    PROPERTIES (d) index, idBarcodeSku, idSku, nameSku, shortNameUOMSku, quantity, sumGrossWeight, balanceB READONLY 
    PROPERTIES (d) NEW, deleteod = DELETE GRID
    PROPERTIES(o) DRAW d fillDocument, addDetailDialogSkuStockUserBinOrderDetail,
                           addDetailInputBarcodeUserBinOrderDetail, deleteUserBinOrderDetail
    FILTERS binOrder(d)==o
    ORDERS index(d)
    EDIT UserBinOrder OBJECT o
;

DESIGN userBinOrder {

    BOX {
        size = (1024, 768);
        NEW mainTabbed {
            tabbed = TRUE;
            fill = 1;
            NEW documentBox{
                fill = 1;
                caption = 'Заказ';
                NEW headerBox {
                    horizontal = TRUE;
    
                    NEW headerRow1 {
                        fill = 1;
    
                        MOVE GROUP(documentHeader,o) {
                            lines = 1;
                            NEW first {
                                horizontal = TRUE;
                            }
                            NEW second { 
                                horizontal = TRUE;
                                MOVE PROPERTY(nameNumerator(o));
                                MOVE PROPERTY(number(o));
                                MOVE PROPERTY(series(o));
                                MOVE PROPERTY(date(o));
                                MOVE PROPERTY(time(o));
                                MOVE PROPERTY(nameStock(o));
                            }    
                        }                    
                        
                        NEW headerRow11 {
                            horizontal = TRUE;
                        }
                        NEW headerTabbedPane {
                            alignment = STRETCH;
                            tabbed = TRUE;
                            NEW headerMainParams {
                                caption = 'Основные параметры';
                                MOVE GROUP(documentPrm,o) {
                                    lines = 3;
                                }
                            }
                            NEW headerExtraParams {
                                caption = 'Дополнительные параметры';
                                horizontal = TRUE;
                                MOVE PROPERTY(closeDateTime(o));
                            }  
                        }  
                    }
    
                    MOVE GROUP(documentSum,o) {
                        lines = 1;
                    }
                }
                NEW specificationBox {
                    fill = 1;
                    tabbed = TRUE;
                    MOVE BOX(d) {
                        caption = 'Спецификация';
                    }
                }
            }
        }
        MOVE TOOLBARBOX;

        PROPERTY(formOk()) {
            caption = 'Провести';
        }                               
    }
}


overShowEdit = ABSTRACT BOOLEAN (BinOrder);
overShowDelete = ABSTRACT BOOLEAN (BinOrder); 

skipToShowEdit = ABSTRACT BOOLEAN (BinOrder);
skipToShowDelete = ABSTRACT BOOLEAN (BinOrder);

isUserOpened(UserBinOrder o)=  isOpened[BinOrder](o) AND is(o);

overCopy  ABSTRACT LIST (UserBinOrderDetail, BinOrderDetail);
overCopy  ABSTRACT LIST (BinOrder, UserBinOrder);
copy 'Копировать'(BinOrder order)  { 
	NEWSESSION {
	    NEW o = UserBinOrder {
	        inBin(o) <- inBin(order);
	        outBin(o) <- outBin(order);
	        note(o) <- note(order);
	        stock(o) <- stock(order);
            inBin(o) <- inBin(order);
            outBin(o) <- outBin(order);
	
	        overCopy(order, o);
	
	        FOR binOrder(BinOrderDetail orderDetail) == order DO {
	            NEW d=UserBinOrderDetail {
	                userBinOrder(d) <- o;
	                sku(d) <- sku(orderDetail);
	                quantity(d) <- quantity(orderDetail);
	                inBin(d) <- inBin(orderDetail);
	                outBin(d) <- outBin(orderDetail);
	                
	                overCopy(d, orderDetail);
	            }
	        }
	
	        SHOW userBinOrder OBJECTS o = o DOCKED;
	    }
	}
} TOOLBAR;
    
//-- Копирование строк     
overCopy  ABSTRACT LIST ( UserBinOrderDetail, UserBinOrderDetail);

copy 'Копировать'(UserBinOrderDetail detail)  { 
    NEW d = UserBinOrderDetail {          

        userBinOrder(d) <- userBinOrder(detail);
        sku(d) <- sku(detail);
        quantity(d) <- quantity(detail);
        outBin(d) <- outBin(detail);
        inBin(d) <- inBin(detail);
        
        EXEC overCopy(d, detail);                              
    }
} CHANGEKEY 'F6' TOOLBAR;

filterBinOrderDateFrom 'Дата с' = DATA LOCAL DATE ();
filterDateFrom (BinOrder o) = date(o) >= filterBinOrderDateFrom() OR (o IS BinOrder AND NOT filterBinOrderDateFrom());      

filterBinOrderDateTo 'Дата по' = DATA LOCAL DATE ();
filterDateTo (BinOrder o) = date(o) <= filterBinOrderDateTo() OR (o IS BinOrder AND NOT filterBinOrderDateTo());      

filterBinOrderStock  = DATA LOCAL Stock ();
nameFilterBinOrderStock 'Склад' = name(filterBinOrderStock()) CHARWIDTH 15;          
filterStock (BinOrder o) = stock(o) == filterBinOrderStock() OR (o IS BinOrder AND NOT filterBinOrderStock());

filterBinOrderCustomUser  = DATA LOCAL CustomUser ();
nameFilterBinOrderCustomUser 'Создан пользователем' = name[Contact](filterBinOrderCustomUser()) CHARWIDTH 15;          
filterBinCustomUser (BinOrder i) = createdUser[UserBinOrder](i) == filterBinOrderCustomUser() OR (i IS BinOrder AND NOT filterBinOrderCustomUser());  

filterBinOrderComputer = DATA LOCAL Computer ();
nameFilterBinOrderComputer 'Создан на компьютере' = hostname(filterBinOrderComputer()) CHARWIDTH 15;          
filterComputer (BinOrder i) = createdComputer(i) == filterBinOrderComputer() OR (i IS BinOrder AND NOT filterBinOrderComputer());

background 'Цвет' = ABSTRACT CASE COLOR (BinOrder);
    
FORM binOrders  'Заказы на перемещение по ячейкам'
    PROPERTIES() filterBinOrderDateFrom, filterBinOrderDateTo, nameFilterBinOrderStock, nameFilterBinOrderCustomUser, nameFilterBinOrderComputer
    
    OBJECTS o = BinOrder LAST
    PROPERTIES (o) READONLYIF isReadonly() BACKGROUND background(o) isClosed, isPosted, number, series, date, time, nameStock, nameOutBin, nameInBin, note, 
                            countBinOrderDetail, quantityBinOrderDetail, sumGrossWeightBinOrderDetail
    
    FILTERS filterDateFrom(o), filterDateTo(o), filterStock(o)
    
    OBJECTS d = BinOrderDetail
    PROPERTIES (d) READONLY index, idBarcodeSku, nameSku, shortNameUOMSku, nameOutBin, nameInBin, quantity, grossWeight, balanceB
    
    PROPERTIES (o) READONLY PANEL createdNameUser[UserBinOrder], createdTime, createdHostnameComputer

    PROPERTIES (o) NEWSESSION addUserBinOrder = NEW[UserBinOrder], EDIT SHOWIF overShowEdit(o) 
    PROPERTIES (o) copy
    PROPERTIES (o) close[UserBinOrder] SHOWIF isOpened[UserBinOrder](o), open SHOWIF isClosed[UserBinOrder](o)
    PROPERTIES     NEWSESSION deleteo=DELETE(o) SHOWIF overShowDelete(o) //isUserOpenedOrder(o)
            
    FILTERS binOrder(d)==o
    ORDERS index(d)
    LIST BinOrder OBJECT o
;

DESIGN binOrders 'Заказы на перемещение по ячейкам' {
    NEW documentContainer BEFORE TOOLBARBOX {
        fill = 1;
        NEW filtersBox {                       
            fill = 1;
            NEW topFilters {  
                caption = 'Фильтры';
                alignment = STRETCH;
                NEW topFilters1 {
                    horizontal = TRUE;
                    alignment = STRETCH;
                    MOVE PROPERTY(filterBinOrderDateFrom());
                    MOVE PROPERTY(filterBinOrderDateTo());                            
                    MOVE PROPERTY(nameFilterBinOrderStock());
                    MOVE PROPERTY(nameFilterBinOrderCustomUser());
                    MOVE PROPERTY(nameFilterBinOrderComputer());
                }
                NEW topFilters2 {
                    horizontal = TRUE;
                    alignment = STRETCH;
                }                
            }
            MOVE BOX(o) {
                fill = 1;
            }
        }
        NEW documentDetail {
            fill = 1;
            tabbed = TRUE;

            MOVE BOX(d) {
                fill = 1;
                caption = 'Спецификация';
            }
            NEW documentHistory {
                caption = 'История';
                MOVE GROUP(created,o);
            }
            NEW printTab {
                caption = 'Печатные формы';
                NEW printContainer {
                    caption = 'Печать';
                }
            }
            NEW actionContainer {
                caption = 'Действия';
                horizontal = TRUE;
                NEW createdContainer {
                    caption = 'Создание на основе';
                    MOVE PROPERTY(copy(o)) { 
                        caption = 'Заказ на перемещение'; 
                        alignment = STRETCH; 
                    }
                }
            }
        }
    }
}

@extendFormFilterAccessStock(o, binOrders, stock, company);

@extendFormEditable(binOrders);

@defineFilterIsOpened (binOrder, binOrders, o);

@defineDocumentLogForm(binOrders, o); 
 
//Операция
@defineOperation(' (перемещение по ячейкам)');

@defineOperationRole();

DESIGN operation {
    tabContainer{
        NEW showContainer {
            caption = 'Отображение свойств';
        }
        NEW createContainer {
            caption = 'Производные документы';
        }
        NEW constraintContainer {
            caption = 'Ограничения';
        }
        NEW paramsContainer {
            caption = 'Параметры';
        }
    }
}

defaultBinOperation = DATA Operation();
nameDefaultBinOperation 'Операция (перемещение по ячейкам) по умолчанию' = name(defaultBinOperation());

EXTEND FORM options PROPERTIES() nameDefaultBinOperation;
DESIGN options {
    WMS {
        MOVE PROPERTY(nameDefaultBinOperation());
    }
}

@defineDocumentOperationContainer(binOrder, o, isPostedBinOrder, nameStock, first, name, );

@defineOperationChangesDocument(binOrder, UserBinOrder, preventChangesDocument, created);

overShowEdit (BinOrder o) += showEditDeleteUser(o) AND isOpened(o) AND NOT skipToShowEdit(o);
overShowDelete (BinOrder o) += showEditDeleteUser(o) AND isUserOpened(o) AND NOT skipToShowDelete(o); 

overCopy(BinOrder order, UserBinOrder userOrder) + { 
    operation(userOrder) <- operation(order);    
}

@extendFormFilterRoleAccess(binOrder, o, binOrders);
@extendFormFilterAccessStock(BinOrder, o, binOrders, stock, company);
@defineDocumentStockAccess(UserBinOrder, stock, company);

@defineDocumentOperationConstraint(binOrder, 'заказ на перемещение по ячейкам', Bin);

@defineOperationFilterProperty(binOrder, o, binOrders, nameFilterBinOrderStock);

inBin 'Ячейка (в)' = DATA Bin (Operation, Stock);
nameInBin 'Ячейка (в)' (Operation operation, Stock stock) = name(inBin(operation, stock)) CHARWIDTH 10;

setInBin (Operation operation, Stock stock)  { 
    DIALOG dialogBinStock OBJECTS s = stock, b = inBin(operation, stock) CHANGE;
}

CONSTRAINT inBin(Operation o, Stock st) AND NOT stock(inBin(o, st)) == st
    CHECKED BY inBin[Operation, Stock] MESSAGE 'Ячейка недоступна для склада';
    
outBin 'Ячейка (из)' = DATA Bin (Operation, Stock);
nameOutBin 'Ячейка (из)' (Operation operation, Stock stock) = name(outBin(operation, stock)) CHARWIDTH 10;;

setOutBin (Operation operation, Stock stock)  { 
    DIALOG dialogBinStock OBJECTS s = stock, b = outBin(operation, stock) CHANGE;
}

CONSTRAINT outBin(Operation o, Stock st) AND NOT stock(outBin(o, st)) == st
    CHECKED BY outBin[Operation, Stock] MESSAGE 'Ячейка недоступна для склада';

TABLE stockOperation(Stock, Operation);
TABLE stockGroupOperation(StockGroup, Operation);
@defineOperationStock(, stc, 'Склады');

CONSTRAINT operation(BinOrder binOrder) AND stock(binOrder) 
           AND NOT in(stock(binOrder), operation(binOrder))
    CHECKED BY stock[UserBinOrder]
    MESSAGE 'Склад должен совпадать с отмеченными в операции';
CONSTRAINT operation(BinOrder binOrder) AND isPosted(binOrder) 
           AND NOT stock(binOrder) AND needStock(operation(binOrder))
    MESSAGE 'Склад должен быть задан для документа';

EXTEND FORM operation
    PROPERTIES(o, stc) nameInBin ON CHANGE setInBin(o, stc), nameOutBin ON CHANGE setOutBin(o, stc)
;

//ячейка в
inUsageType = DATA UsageType (Operation);
staticCaptionInUsageType 'Ограничение по типу использования использования (в)' (Operation o) = staticCaption(inUsageType(o));

// Отметка для групп
dataInBin 'Отм.' = DATA BOOLEAN (BinGroup, Operation);
levelParentInBin(Operation operation, BinGroup binGroup)  =
    GROUP MIN level(binGroup, BinGroup parent) IF dataInBin(parent, operation) MATERIALIZED;
nearestParentInBinGroup (Operation operation, BinGroup binGroup) = binGroup(binGroup, levelParentInBin(operation, binGroup));
nearestInBin (BinGroup binGroup, Operation operation) =
    dataInBin(nearestParentInBinGroup(operation, binGroup), operation) MATERIALIZED;

inBin 'Отм' (BinGroup binGroup, Operation operation) =
    OVERRIDE dataInBin(binGroup, operation),
        nearestInBin(binGroup, operation) MATERIALIZED;

// Отметка для ячеек
dataInBin 'Отм.' = DATA BOOLEAN (Bin, Operation);
inBin 'Отм' (Bin bin, Operation operation) =
    OVERRIDE in(bin, inUsageType(operation)),
        dataInBin(bin, operation) IF NOT inUsageType(operation),
        inBin(binGroup(bin), operation) IF NOT inUsageType(operation) MATERIALIZED ;

changeInBin (Bin bin, Operation operation) {
    INPUT b=BOOLEAN DO {
        dataInBin(bin, operation) <- b;
    }
}

CONSTRAINT inBin(Operation operation, Stock st) IS Bin AND NOT inBin(inBin(operation, st), operation)
    CHECKED BY inBin[Operation, Stock]
    MESSAGE '"Ячейка (в)" склада по умолчанию должна быть включена в операцию';

quantityChildWithInBin(BinGroup group, Operation operation)  = GROUP SUM 1 IF dataInBin(BinGroup childGroup, operation) AND isParent(childGroup, group) MATERIALIZED;
quantityParentWithInBin(BinGroup group, Operation operation)  = GROUP SUM 1 IF dataInBin(BinGroup parentGroup, operation) AND isParent(group, parentGroup) MATERIALIZED;

//ячейка из
outUsageType = DATA UsageType (Operation);
staticCaptionOutUsageType 'Ограничение по типу использования (из)' (Operation o) = staticCaption(outUsageType(o));

// Отметка для групп
dataOutBin 'Отм.' = DATA BOOLEAN (BinGroup, Operation);
levelParentOutBin(Operation operation, BinGroup binGroup)  =
    GROUP MIN level(binGroup, BinGroup parent) IF dataOutBin(parent, operation) MATERIALIZED;
nearestParentOutBinGroup (Operation operation, BinGroup binGroup) = binGroup(binGroup, levelParentOutBin(operation, binGroup));
nearestOutBin (BinGroup binGroup, Operation operation) =
    dataOutBin(nearestParentOutBinGroup(operation, binGroup), operation) MATERIALIZED;

outBin 'Отм' (BinGroup binGroup, Operation operation) =
    OVERRIDE dataOutBin(binGroup, operation),
        nearestOutBin(binGroup, operation) MATERIALIZED;

// Отметка для ячеек
dataOutBin 'Отм.' = DATA BOOLEAN (Bin, Operation);
outBin 'Отм' (Bin bin, Operation operation) =
    OVERRIDE in(bin, outUsageType(operation)),
        dataOutBin(bin, operation) IF NOT outUsageType(operation),
        outBin(binGroup(bin), operation) IF NOT outUsageType(operation) MATERIALIZED;

changeOutBin (Bin bin, Operation operation) {
    INPUT b=BOOLEAN DO {
        dataOutBin(bin, operation) <- b;
    }
}

CONSTRAINT outBin(Operation operation, Stock st) IS Bin AND NOT outBin(outBin(operation, st), operation)
    CHECKED BY outBin[Operation, Stock]
    MESSAGE '"Ячейка (из)" склада по умолчанию должна быть включена в операцию';

levelBinGroup 'Общий родитель заданного уровня' = DATA INTEGER (Operation);
needIn '"Ячейка (в)" обязательна' = DATA BOOLEAN (Operation);
needOut '"Ячейка (из)" обязательна' = DATA BOOLEAN (Operation);

EXTEND FORM operation
    PROPERTIES(o) levelBinGroup, staticCaptionOutUsageType, staticCaptionInUsageType, needIn, needOut

    TREE inGroupTree inbing = BinGroup PARENT parent(inbing)
    PROPERTIES READONLY inbingTreeName = name(inbing)
    PROPERTIES inBin(inbing, o)
    FILTERS in(stock(inbing), o)

    OBJECTS inbin = Bin
    PROPERTIES(inbin, o) READONLYIF inUsageType(o) inBin ON CHANGE changeInBin(inbin, o)
    PROPERTIES(inbin) READONLY order, canonicalId, nameBinGroup, name, id SHOWIF showIDs()
    ORDERS order(inbin), canonicalId(inbin), name(inbin)
    FILTERS isParent(inbing, inbin)
    FILTERGROUP inBinFilters3
        FILTER 'Показывать отмеченные' inBin(inbin, o)

    TREE outGroupTree outbing = BinGroup PARENT parent(outbing)
    PROPERTIES READONLY outbingTreeName = name(outbing)
    PROPERTIES outBin(outbing, o)
    FILTERS in(stock(outbing), o)

    OBJECTS outbin = Bin
    PROPERTIES(outbin, o) READONLYIF outUsageType(o) outBin ON CHANGE changeOutBin(outbin, o)
    PROPERTIES(outbin) READONLY order, canonicalId, nameBinGroup, name, id SHOWIF showIDs()
    ORDERS order(outbin), canonicalId(outbin), name(outbin)
    FILTERS isParent(outbing, outbin)
    FILTERGROUP outBinFilters3
        FILTER 'Показывать отмеченные' outBin(outbin, o)
;

DESIGN operation {
    tabContainer {
        NEW binContainer{
            caption = 'Ячейки';
            fill = 1;
            NEW outBinContainer {
                fill = 1;
                caption = 'Ячейки (из)';
                MOVE PROPERTY(staticCaptionOutUsageType(o));
                NEW splitOutBinContainer{
                    horizontal = TRUE;
                    fill = 1;
                    MOVE BOX(TREE outGroupTree);
                    MOVE BOX(outbin) {
                        fill = 3;
                    }
                }
            }
            NEW inBinContainer {
                caption = 'Ячейки (в)';
                MOVE PROPERTY(staticCaptionInUsageType(o));
                fill = 1;
                NEW splitInBinContainer{
                    horizontal = TRUE;
                    fill = 1;
                    MOVE BOX(TREE inGroupTree);
                    MOVE BOX(inbin) {
                        fill = 3;
                    }
                }
            }
            constraintContainer {
                NEW additionalContainer {
                    MOVE PROPERTY(levelBinGroup(o));
                    NEW additionalInOutContainer {
                        horizontal = TRUE;
                        MOVE PROPERTY(needOut(o));
                        MOVE PROPERTY(needIn(o));
                    }
                }
            }
        }
    }
}

CONSTRAINT (CHANGED(operation(BinOrderDetail d)) OR CHANGED(inBin(d)) OR CHANGED(outBin(d))) AND levelBinGroup(operation(d)) AND NOT
    binGroupRoot(binGroup(inBin(d)), levelBinGroup(operation(d))) == binGroupRoot(binGroup(outBin(d)), levelBinGroup(operation(d))) AND
    inBin(d) AND outBin(d)
    MESSAGE 'Несовпадение общего уровня группы ячеек заданного для операции';

CONSTRAINT (CHANGED(operation(BinOrder t)) OR CHANGED(inBin(t)) OR CHANGED(outBin(t))) AND levelBinGroup(operation(t)) AND NOT
    binGroupRoot(binGroup(inBin(t)), levelBinGroup(operation(t))) == binGroupRoot(binGroup(outBin(t)), levelBinGroup(operation(t))) AND
    inBin(t) AND outBin(t)
    MESSAGE 'Несовпадение общего уровня группы ячеек заданного для операции';

CONSTRAINT (CHANGED(operation(BinOrderDetail d)) OR CHANGED(inBin(d))) AND inBin(d) AND NOT inBin(inBin(d), operation(d))
    MESSAGE '"Ячейка (в)" строки перемещения по ячейкам  должна совпадать с отмеченными в операции';

CONSTRAINT (CHANGED(operation(BinOrder t)) OR CHANGED(inBin(t))) AND inBin(t) AND NOT inBin(inBin(t), operation(t))
    MESSAGE '"Ячейка (в)" документа перемещение по ячейкам  должна совпадать с отмеченными в операции';

CONSTRAINT (CHANGED(operation(BinOrderDetail d)) OR CHANGED(outBin(d))) AND outBin(d) AND NOT outBin(outBin(d), operation(d))
    MESSAGE '"Ячейка (из)" строки перемещения по ячейкам должна совпадать с отмеченными в операции';

CONSTRAINT (CHANGED(operation(BinOrder t)) OR CHANGED(outBin(t))) AND outBin(t) AND NOT outBin(outBin(t), operation(t))
    MESSAGE '"Ячейка (из)" документа перемещения по ячейкам должна совпадать с отмеченными в операции';

CONSTRAINT (CHANGED(operation(BinOrderDetail d)) OR DROPPED(outBin(d)) OR SET(d IS BinOrderDetail)) AND NOT outBin(d) AND needOut(operation(d))
    MESSAGE '"Ячейка (из)" обязательна для заданной операции перемещения между ячейками';

CONSTRAINT (CHANGED(operation(BinOrderDetail d)) OR DROPPED(inBin(d)) OR SET(d IS BinOrderDetail)) AND NOT inBin(d) AND needIn(operation(d))
    MESSAGE '"Ячейка (в)" обязательна для заданной операции перемещения между ячейками';

extraBinFilter (Bin b, UserBinOrder t) =
    (levelBinGroup(operation(t)) AND inBin(t) AND binGroupRoot(binGroup(inBin(t)), levelBinGroup(operation(t))) = binGroupRoot(binGroup(b), levelBinGroup(operation(t))) OR
        levelBinGroup(operation(t)) AND outBin(t) AND binGroupRoot(binGroup(b), levelBinGroup(operation(t))) == binGroupRoot(binGroup(outBin(t)), levelBinGroup(operation(t))) OR
        t IS UserBinOrder AND b IS Bin AND (NOT levelBinGroup(operation(t)) OR (NOT inBin(t) AND NOT outBin(t))));

overExtraInBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrder);
needExtraInBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrder);
extraInBinFilter (Bin b, UserBinOrder t) =
    needExtraInBinFilter(b, t) AND overExtraInBinFilter(b, t) OR t IS UserBinOrder AND b IS Bin AND NOT needExtraInBinFilter(b, t);

overExtraOutBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrder);
needExtraOutBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrder);
extraOutBinFilter (Bin b, UserBinOrder t) =
    needExtraOutBinFilter(b, t) OR overExtraOutBinFilter(b, t) OR t IS UserBinOrder AND b IS Bin AND NOT needExtraOutBinFilter(b, t);

extraBinFilter (Bin b, UserBinOrderDetail d) =
    (levelBinGroup(operation(d)) AND inBin(d) AND binGroupRoot(binGroup(inBin(d)), levelBinGroup(operation(d))) = binGroupRoot(binGroup(b), levelBinGroup(operation(d))) OR
        levelBinGroup(operation(d)) AND outBin(d) AND binGroupRoot(binGroup(b), levelBinGroup(operation(d))) == binGroupRoot(binGroup(outBin(d)), levelBinGroup(operation(d))) OR
        d IS UserBinOrderDetail AND b IS Bin AND (NOT levelBinGroup(operation(d)) OR (NOT inBin(d) AND NOT outBin(d))));

overExtraInBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrderDetail);
needExtraInBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrderDetail);
extraInBinFilter (Bin b, UserBinOrderDetail d) =
    needExtraInBinFilter(b, d) AND overExtraInBinFilter(b, d) OR d IS UserBinOrderDetail AND b IS Bin AND NOT needExtraInBinFilter(b, d);

overExtraOutBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrderDetail);
needExtraOutBinFilter = ABSTRACT BOOLEAN (Bin, UserBinOrderDetail);
extraOutBinFilter (Bin b, UserBinOrderDetail d) =
    needExtraOutBinFilter(b, d) AND overExtraOutBinFilter(b, d) OR d IS UserBinOrderDetail AND b IS Bin AND NOT needExtraOutBinFilter(b, d);


@setBinDocumentWithfilter(UserBinOrder, stock);

EXTEND FORM userBinOrder
    PROPERTIES(o) AFTER note(o) nameInBin ON CHANGE setInBin(o), nameOutBin ON CHANGE setOutBin(o)
    PROPERTIES(d) AFTER shortNameUOMSku(d) nameOutBin ON CHANGE setOutBin(d), nameInBin ON CHANGE setInBin(d)
;

@deriveDocumentBins (userBinOrder, userBinOrder, inBin, inBin, outBin, outBin, stock);

useBins(UserBinOrder order) <- TRUE WHEN SET(order IS UserBinOrder);

@defineDocumentSkuStockPriceListTypeSystemLedger(userBinOrder, );

@extendFormDocumentSkuStock(userBinOrder, userBinOrder, o, , );

prevCurrentBalanceOutBin 'Текущий остаток (ячейка из)' (Sku sku, BinOrder order) = prevCurrentBalance(sku, outBin(order));
prevCurrentBalanceInBin 'Текущий остаток (ячейка в)' (Sku sku, BinOrder order) = prevCurrentBalance(sku, inBin(order));

backgroundOutBin (Sku sku, BinOrder order) = RGB(240, 240, 224) IF sku IS Sku AND order IS BinOrder;
backgroundInBin (Sku sku, BinOrder order) = RGB(244, 255, 189) IF sku IS Sku AND order IS BinOrder;

allOutBinQuantityUserBinOrder 'Весь остаток (ячейка из)' = DATA LOCAL BOOLEAN (Sku, Stock);
changeAllOutBinQuantity(Sku sku, UserBinOrder userBinOrder, Stock stock)  { 
    INPUT b = BOOLEAN DO {
        allOutBinQuantityUserBinOrder (sku,stock) <- b;
        changeQuantityValue(sku, userBinOrder, stock, prevCurrentBalanceOutBin(sku,userBinOrder) IF b);
    }
}

EXTEND FORM userBinOrder
    PROPERTIES AFTER quantity(ks, o, st) prevCurrentBalanceOutBin (ks, o) BACKGROUND backgroundOutBin(ks, o) READONLY,
               allOutBinQuantityUserBinOrder(ks, st) BACKGROUND backgroundOutBin(ks, o) ON CHANGE changeAllOutBinQuantity(ks, o, st),   
               prevCurrentBalanceInBin (ks, o) BACKGROUND backgroundInBin(ks, o) READONLY
               
    FILTERGROUP filter
        FILTER 'С остатком (ячейка из)' prevCurrentBalanceOutBin(ks, o) 'F7' DEFAULT
        FILTER 'С остатком ' currentBalance(ks,st) 'F10'
        FILTER 'В документе ' quantity(ks, o, st) 'F9'
;

DESIGN userBinOrder {
    PROPERTY(prevCurrentBalance(ks, st)) {
        hide = TRUE;
    }
    PROPERTY(allQuantityUserBinOrder(ks, st)) {
        hide = TRUE;    
    }
}

//упаковка
@defineDocumentPack(binOrder, o);

packQuantity 'Кол-во упаковок в документе' (sku, userBinOrder, stock) = GROUP SUM packQuantity(UserBinOrderDetail userBinOrderDetail)
    BY sku(userBinOrderDetail), userBinOrder(userBinOrderDetail), stock(userBinOrderDetail);

changePackQuantity(Sku sku, UserBinOrder userBinOrder, Stock stock)  { 
    INPUT n = NUMERIC[16,5] DO
        IF userBinOrderDetail(sku, userBinOrder, stock) THEN {
            IF n THEN {
                packQuantity(UserBinOrderDetail userBinOrderDetail) <- n WHERE userBinOrderDetail == userBinOrderDetail(sku, userBinOrder, stock);
                quantity(UserBinOrderDetail userBinOrderDetail) <- NUMERIC[16,5](packQuantity(userBinOrderDetail)*(OVERRIDE amountPack(userBinOrderDetail), 1.0)) 
                                        WHERE userBinOrderDetail == userBinOrderDetail(sku, userBinOrder, stock) AND NOT skipChangeQuantity(userBinOrderDetail(sku, userBinOrder, stock));
            } ELSE {
                FOR userBinOrderDetail(sku, userBinOrder, stock) == UserBinOrderDetail d DO
                    DELETE d;
            }
        } ELSE {
            IF n THEN  {
                NEW d = UserBinOrderDetail {
                   userBinOrder(d) <- userBinOrder;
                   sku(d) <- sku;
                   packQuantity (d) <- n;
                   quantity(d) <- NUMERIC[16,5](packQuantity(d) * (OVERRIDE amountPack(d), 1.0));
                }
            }
        }
}

changeAmountPack(Sku sku, UserBinOrder userBinOrder, Stock stock)  { 
    INPUT n = NUMERIC[14,3] DO {
        IF userBinOrderDetail(sku, userBinOrder, stock) THEN {
            IF n THEN {
                amountPack(UserBinOrderDetail userBinOrderDetail) <- n WHERE userBinOrderDetail == userBinOrderDetail(sku, userBinOrder, stock);
                quantity(UserBinOrderDetail userBinOrderDetail) <- NUMERIC[16,5](packQuantity(userBinOrderDetail)*(OVERRIDE amountPack(userBinOrderDetail), 1.0)) 
                                        WHERE userBinOrderDetail == userBinOrderDetail(sku, userBinOrder, stock) AND packQuantity(userBinOrderDetail) AND NOT skipChangeQuantity(userBinOrderDetail(sku, userBinOrder, stock));
            } ELSE {
                amountPack(UserBinOrderDetail userBinOrderDetail) <- NULL WHERE userBinOrderDetail == userBinOrderDetail(sku, userBinOrder, stock);
            }
    
        }
        changeValuePack(sku, n);
    }
}

@extendFormDocumentPackSkuStock(userBinOrder, userBinOrder, o, );

@defineOperationProperty(showPack, 'Упаковка', showContainer);

@deriveDocumentOperationProperty(UserBinOrder, showPack);

NAVIGATOR {
    WMSNavigator {
         WMSDocument {
            NEW binOrders;
         }
         NEW FOLDER WMSMasterData 'Справочники'  {
            NEW operations;   
         }
    }
}

userBinOrderDetail (sku, userBinOrder, bin, stock) =  GROUP MAX UserBinOrderDetail detail
    BY sku(detail), userBinOrder(detail), outBin(detail), stock(detail);

quantity 'Кол-во товара в документе' (sku, userBinOrder, bin, stock) = GROUP SUM quantity(UserBinOrderDetail detail)
    BY sku(detail), userBinOrder(detail), outBin(detail), stock(detail) CHARWIDTH 7;

backgroundQuantity 'Цвет' (sku, userBinOrder, bin, stock) = ABSTRACT CASE COLOR (Sku, UserBinOrder, Bin, Stock);

changeQuantityValue(Sku sku, UserBinOrder userBinOrder, Bin bin, Stock stock, NUMERIC[14,3] n)  {
    IF userBinOrderDetail(sku, userBinOrder, stock) THEN {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            quantity(UserBinOrderDetail detail) <- n WHERE detail == userBinOrderDetail(sku, userBinOrder, bin, stock);
            overChangeQuantityValueSku(userBinOrderDetail(sku, userBinOrder, bin, stock));
        } ELSE {
            FOR userBinOrderDetail(sku, userBinOrder, bin, stock) == UserBinOrderDetail d DO
                DELETE d;
        }

    } ELSE {
        IF (n AND NOT deleteNullDetail()) OR (deleteNullDetail() AND n != 0) THEN {
            NEW d = UserBinOrderDetail {
                userBinOrder(d) <- userBinOrder;
                sku(d) <- sku;
                quantity (d) <- n;
                outBin(d) <- bin;
                overChangeQuantityValueSku(d);
            }
        }
    }
}
changeQuantity(Sku sku, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT n = NUMERIC[16,5] DO
        changeQuantityValue(sku, userBinOrder, bin, stock, n);
}

allQuantityUserBinOrder 'Весь остаток' = DATA LOCAL BOOLEAN (Sku, Bin, Stock);
changeAllQuantity(Sku sku, UserBinOrder userBinOrder, Bin bin, Stock stock)  {
    INPUT b = BOOLEAN DO {
        allQuantityUserBinOrder (sku, bin, stock) <- b;
        changeQuantityValue(sku, userBinOrder, bin, stock, prevCurrentBalance(sku,stock) IF b);
    }
}

EXTEND FORM userBinOrder
    OBJECTS sbin = Bin GRID
    PROPERTIES(sbin) order, canonicalId
    PROPERTIES quantity(ks, o, sbin, st) ON CHANGE changeQuantity(ks, o, sbin, st) BACKGROUND backgroundQuantity(ks, o, sbin, st)
    PROPERTIES prevCurrentBalance(ks, sbin)
    ORDERS order(sbin), canonicalId(sbin)

    FILTERS prevCurrentBalance(ks, sbin),
        stock(sbin) == st
;

DESIGN userBinOrder {
    BOX(sts) {
        GRID(sts) {
            fill = 3;
        }
        MOVE BOX(sbin) {
            fill = 1;
            caption = 'Ячейки';
            PROPERTY(prevCurrentBalance(ks, sbin)) { background = #FFEEEE; }
            PROPERTY(quantity(ks, o, sbin, st)) { background = #D4FFD4; }
        }
    }
}

// ------------------------------------- Печать заказа на перемещение ---------------------------------------

FORM printBinOrder 'Заказ на перемещение'
    OBJECTS o = BinOrder PANEL SUBREPORT
    PROPERTIES(o) READONLY  number, series, date, time, nameStock, nameOutBin, nameInBin, note, nameOperation

    OBJECTS d = BinOrderDetail
    PROPERTIES(d) READONLY index, idBarcodeSku, nameSku, nameOutBin, nameInBin, packQuantity, quantity, grossWeight
    FILTERS binOrder(d) == o
;

printBinOrder 'Печать заказа' (BinOrder order)  { 
    PRINT printBinOrder OBJECTS o = order;
} IMAGE 'print.png' IN print;

EXTEND FORM binOrders
    PROPERTIES (o) TOOLBAR printBinOrder  
;

DESIGN binOrders {
    printContainer {
        MOVE PROPERTY(printBinOrder(o));
    }
}
