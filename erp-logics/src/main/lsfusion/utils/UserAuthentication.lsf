MODULE UserAuthentication;

REQUIRE Authentication, Security, Utils;

NAMESPACE Authentication;

changePassOnFirstLogin '{authentication.password.change.first.login}' = DATA BOOLEAN (UserRole);
changePassOnFirstLogin (CustomUser user) = GROUP MAX UserRole role IF in(user, role);

// Оценка надежности паролей 
pwLength (STRING[30] pass) = length(pass);
pwNumeric (STRING[30] pass) = length(regexpReplace (pass, '\\D', '', 'g'));
pwNumsymbols (STRING[30] pass) = length(regexpReplace(pass, '[A-Z,a-z,а-я,А-Я,0-9]', '', 'g'));
pwUpper (STRING[30] pass) = length(regexpReplace(pass, '[^A-Z,А-Я]', '', 'g'));

passStrength (STRING[30] pass) = min(max(min(pwLength(pass), 5) * 10 (-) 20 (+) min(pwNumeric(pass), 3) * 10 (+) min(pwNumsymbols(pass), 3) * 15 (+) min(pwUpper(pass), 3) * 10, 0), 100);

passBack (STRING[30] pass) = CASE
    WHEN passStrength(pass) < 70 THEN #FFC0C0
    WHEN passStrength(pass) < 80 THEN #FFFFC0
    WHEN passStrength(pass) < 90 THEN #F0FFF0
    ELSE #C0FFC0 IF pass IS STRING
;
    
// {authentication.password.policy.strength.pass}
GROUP policyStrengthPass '{authentication.password.requirements}';
 
minPassLength '{authentication.password.minimum.length}' () = DATA INTEGER () IN policyStrengthPass;
passHasContainDigits '{authentication.password.must.contain.digits}' = DATA BOOLEAN () IN policyStrengthPass;
passHasContaintSymbols '{authentication.password.must.contain.special.symbols}' = DATA BOOLEAN () IN policyStrengthPass;
passHasContaintUpper '{authentication.password.must.contain.upcase.letters}' = DATA BOOLEAN () IN policyStrengthPass;

stringStrengthPass '{authentication.password.requirements}' (STRING[30] pass) = TEXT(
    CONCAT ';\n',
        '{authentication.password.minimum.length} - ' + minPassLength() + '{authentication.password.symbols}' IF pwLength(pass) < minPassLength(),
        '{authentication.password.must.contain.digits}' IF passHasContainDigits() AND NOT pwNumeric(pass) > 0,
        '{authentication.password.must.contain.special.symbols}' IF passHasContaintSymbols() AND NOT pwNumsymbols(pass) > 0,
        '{authentication.password.must.contain.upcase.letters}' IF passHasContaintUpper() AND NOT pwUpper(pass) > 0
); 

passRequirement '{authentication.password.requirements}' () = stringStrengthPass('' AS STRING[30]);

passValid (STRING[30] pass) = NOT stringStrengthPass(pass);

check (BOOLEAN b) = IF b THEN '✔' ELSE ' ';
check '' (STRING[30] pass) = check(NOT stringStrengthPass(pass)) CHARWIDTH 2;
check '' (STRING[30] new1, STRING[30] new2) = check(new1 = new2 AND NOT stringStrengthPass(new1)) CHARWIDTH 2;

EXTEND FORM securityPolicy
    PROPERTIES () PANEL minPassLength, passHasContainDigits, passHasContaintSymbols, passHasContaintUpper
;

DESIGN securityPolicy {
    rolePolicyContainer {
        NEW policyStrengthPass {
            caption = '{authentication.password.policy.strength.pass}';
            MOVE GROUP (policyStrengthPass);
        }
    }
}

firstLogin (CustomUser u) = NOT [GROUP MAX Connection c IF NOT c = currentConnection() BY user(c)](u);

copy (UserRole from, UserRole to) + {
    changePassOnFirstLogin(to) <- changePassOnFirstLogin(from);
}

changePasswordOnNextLogin '{authentication.password.change.next.login}' = DATA BOOLEAN (CustomUser);

overChangePasswordOnNextLogin (CustomUser u) = OVERRIDE changePasswordOnNextLogin(u), (changePassOnFirstLogin(u) OR changePassOnFirstLogin(mainRole(u))) IF firstLogin(u); 

EXTEND FORM securityPolicy
    PROPERTIES (ur) changePassOnFirstLogin
    
    PROPERTIES (u) changePasswordOnNextLogin
;

changePasswordOnLogin = DATA LOCAL NESTED BOOLEAN ();

checkPass (CustomUser customUser, STRING[30] old, STRING[30] new1, STRING[30] new2) {
    beforeCanceled() <- NULL;    
    calculateBase64Hash('SHA-256', old);
    IF calculatedHash() != sha256Password(customUser) THEN {
        MESSAGE '{authentication.change.password.incorrect.old}' NOWAIT;
        beforeCanceled() <- TRUE;    
    }
    IF old = new1 THEN {
        MESSAGE '{authentication.password.must.different.old}' NOWAIT;
        beforeCanceled() <- TRUE;    
    }
    IF stringStrengthPass(new1) THEN {
        MESSAGE '{authentication.password.must.meet.complexity.requirements}:\n' + stringStrengthPass(new1) NOWAIT;
        beforeCanceled() <- TRUE;    
    }
    IF new1 != new2 THEN {
        MESSAGE '{authentication.change.password.do.not.match}' NOWAIT;
        beforeCanceled() <- TRUE;
    }
    IF NOT beforeCanceled() THEN {
        changePasswordOnLogin() <- NULL;
        NEWSESSION {
            changePasswordOnNextLogin(currentUser()) <- NULL;
            APPLY;
        }
    }
}

changePasswordOnLogin() {
    IF changePasswordOnLogin() THEN {
        changePassword();
    }
}

EXTEND FORM changePasswordUser
    PROPERTIES () READONLY passRequirement SHOWIF passRequirement()
    PROPERTIES checkNew1 = check(new1) READONLY FOREGROUND passBack(new1), checkNew2 = check(new1, new2) READONLY FOREGROUND #C0FFC0
    EVENTS
        ON OK BEFORE { checkPass(u, old, new1, new2); },
        ON CLOSE { changePasswordOnLogin(); }
;

DESIGN changePasswordUser {
    changePassword {
        MOVE PROPERTY (passRequirement()) FIRST {
            fill = 1;
            fontSize = 14;
        }
        NEW newPass1 {
            type = CONTAINERH;
            fill = 1;
            MOVE PROPERTY (valueNew1);
            MOVE PROPERTY (checkNew1) {
                fontSize = 36;
                charWidth = 2;
                focusable = FALSE;
            }
        }
        NEW newPass2 {
            type = CONTAINERH;
            fill = 1;
            MOVE PROPERTY (valueNew2);
            MOVE PROPERTY (checkNew2) {
                fontSize = 36;
                charWidth = 2;
                focusable = FALSE;
            }
        }
    }
}

onClientStarted() + {
    changePasswordOnLogin() <- overChangePasswordOnNextLogin(currentUser()) AND NOT useLDAP(); 
    changePasswordOnLogin();
}