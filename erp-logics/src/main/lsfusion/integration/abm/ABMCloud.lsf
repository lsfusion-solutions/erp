MODULE ABMCloud;

REQUIRE SkuLedger, Barcode, Range, PricingPurchase, PurchaseDemand, PurchaseScheduleOrder, SaleShipment, WriteOff, KVI,
        ProductionOutput, ProductionConsumption, PurchaseSeparation, PurchaseOrderStatus, PurchaseOrderEDI, PurchaseAutoOrder;

NAMESPACE Integration;


connectionStringABM 'Строка подключения (ftp://username:password@host:port/path/)' = DATA STRING[250]();
exportPostABMPath 'POST запрос' = DATA STRING[250] ();

EXTEND FORM integrationData
    PROPERTIES() connectionStringABM, exportPostABMPath
    
    OBJECTS single = BOOLEAN PANEL
    EVENTS ON INIT { SEEK integrationData.single = TRUE; }
    
    OBJECTS d = DATE PANEL, dToABM = DATE PANEL
    PROPERTIES date 'Дата' = VALUE(d), dateTo 'Дата по'= VALUE(dToABM)
;

DESIGN integrationData {
    pane {
        NEW ABMInventory {
            caption = 'ABMCloud';
            MOVE PROPERTY(connectionStringABM());
            MOVE PROPERTY(exportPostABMPath());
            NEW paneABM {
                type = TABBED;
                fill = 1;
                NEW tab1 {
                    caption = 'Файлы';
                    type = CONTAINERH;
                    NEW buttons {
                        fill = 1;
                        NEW datesAbm {
                            type = CONTAINERH;
                            MOVE PROPERTY(date);
                            MOVE PROPERTY(dateTo);
                        }
                    }
                }
            }
        }
    }
}


toDateYYYYMMDD = FORMULA STRING[8] 'to_char(($1),\'YYYYMMDD\')';
toDateYYYYMMDD2 = FORMULA STRING[10] 'to_char(($1),\'YYYY.MM.DD\')';
toDateYYYYMMDD3 = FORMULA STRING[10] 'to_char(($1),\'YYYY-MM-DD\')';
//toDateYYYYMM = FORMULA STRING[8] 'to_char(($1),\'YYYYMM\')';
toTimeHHMISS = FORMULA STRING[10] 'to_char(($1),\'HH24MISS\')';
//toDateTimeYYYYMMDDHHMM = FORMULA STRING[14] 'to_char(($1),\'YYYYMMDDHH24MI\')';
toTimeHHMI = FORMULA STRING[5] 'to_char(($1),\'HH24MI\')';

//barcodes (Sku s) = GROUP CONCAT id(Barcode b) IF id(b) AND amount(b) == 1.0 AND active(b) AND sku(b) == s, ',' ORDER b;
selectABM 'Вкл.' = DATA LOCAL BOOLEAN (Stock);
countSelectABM () = GROUP SUM 1 IF selectABM(Stock st);

filterABM = DATA LOCAL BOOLEAN (Sku);
filterABM = DATA LOCAL BOOLEAN (Stock);
filterABM = DATA LOCAL BOOLEAN (Sku, Stock);
filterABM = DATA LOCAL BOOLEAN (SkuGroup);
filterABM = DATA LOCAL BOOLEAN (LegalEntity);
filterABMSuppliers = DATA LOCAL BOOLEAN (Stock);
filterABM = DATA LOCAL BOOLEAN (Stock, LegalEntity, Separation);
filterABM = DATA LOCAL BOOLEAN (Stock, Stock, Separation);
filterABM = DATA LOCAL BOOLEAN (Purchase.Invoice);
filterABM = DATA LOCAL BOOLEAN (Purchase.InvoiceDetail);
filterABM = DATA LOCAL BOOLEAN (Purchase.Order);
filterABM = DATA LOCAL BOOLEAN (Purchase.OrderDetail);
filterABM = DATA LOCAL BOOLEAN (PriceList);
filterABM = DATA LOCAL BOOLEAN (PriceList, Stock, Sku);
filterABMClose = DATA LOCAL BOOLEAN (Purchase.Order);

resetFilterABM(){
    filterABM(Sku s)<- NULL;
    filterABM(Stock st) <- NULL;
    filterABM(Sku s, Stock st) <- NULL;
    filterABM(SkuGroup s) <- NULL;
    filterABM(LegalEntity s) <- NULL;
    filterABMSuppliers(Stock s) <- NULL;
    filterABM(Stock st, LegalEntity l, Separation s) <- NULL;
    filterABM(Stock st, Stock l, Separation s) <- NULL;
    filterABM(Purchase.Invoice d) <- NULL;
    filterABM(Purchase.InvoiceDetail d) <- NULL;
    filterABM(Purchase.Order d) <- NULL;
    filterABM(Purchase.OrderDetail d) <- NULL;
    filterABM(PriceList s) <- NULL;
    filterABM(PriceList d, Stock s, Sku sk) <- NULL;
    filterABMClose(Purchase.Order d) <- NULL;
}

chr = FORMULA TEXT 'chr($1)';
trimChr10 (STRING s) = rtrim(ltrim(s, chr(10)), chr(10));

//Статусы товара
//MTS – (make to stock) товар, который всегда должен быть в наличии на месте хранения, регулярно
//заказывается и продается, покупатель всегда надеется найти этот товар на полке. Такой товар
//попадает в регулярные заказы системы.
//MTO – (make to order) товар, который везется по специальному заказу. Есть в ассортименте, но не
//поддерживается на месте хранения постоянно. По умолчанию все товары, вошедшие в систему,
//считаются новыми на протяжении 3-х месяцев (настраиваемый параметр). Новый товар имеет статус
//MТО и буфер = 0 (необработанная карточка). Для того, чтобы товар начал попадать в регулярные
//заказы системы, ему нужно установить статус MTS и рассчитать буфер в системе Leafio.
//NА – (not active) неактивный товар в системе Leafio, который был выведен из ассортимента. Данные
//этого товара не обновляются, остатки по всей сети = 0. Если для такого товара передался остаток, он
//попадет в необработанные карточки.
//NМ (HM) – (not management) товар, который не управляется в системе АВМ. Товарные запасы и продажи,
//помеченные этим статусом, включаются в общие запасы и продажи предприятия.
CLASS State 'Статус выгрузки ABM' {
    MTS 'MTS', 
    MTO 'MTO',
    NA 'NA', //неактивный
    NM 'NM'
}
name 'Наименование' (State s) = staticCaption(s);
// Помечаем статус выгрузки
// используем везде один статус. Кроме товаров везде имеет значение только NA или любой другой 
stateABM = DATA State (Sku, Stock) TABLE extraSkuStock;
nameStateABM 'Статус в ABM'(Sku s, Stock st)  = name(stateABM(s,st)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Sku, Stock) TABLE extraSkuStock;
stateABMSent (Sku s, Stock st) = stateABM(s,st)!=State.NA;

stateABM = DATA State (Sku);
nameStateABM 'Статус в ABM'(Sku s)  = name(stateABM(s)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Sku);
stateABMSent (Sku s) = stateABM(s)!=State.NA;

stateABM = DATA State (Stock);
nameStateABM 'Статус в ABM'(Stock st)  = name(stateABM(st)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Stock);
stateABMSent (Stock s) = stateABM(s)!=State.NA;

stateABM = DATA State (SkuGroup);
nameStateABM 'Статус в ABM'(SkuGroup st)  = name(stateABM(st)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(SkuGroup);
stateABMSent (SkuGroup s) = stateABM(s)!=State.NA;

stateABM = DATA State (LegalEntity);
nameStateABM 'Статус в ABM'(LegalEntity st)  = name(stateABM(st)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(LegalEntity);
stateABMSent (LegalEntity s) = stateABM(s)!=State.NA;

stateABMSupplier = DATA State (Stock);
nameStateABMSupplier 'Статус в ABM'(Stock st)  = name(stateABMSupplier(st)) CHARWIDTH 7;
stateABMTimeSupplier 'Время статуса' = DATA  DATETIME(Stock);
stateABMSentSupplier (Stock s) = stateABMSupplier(s)!=State.NA;

TABLE scheduleOrderABM (Stock, LegalEntity, Separation); 
stateABM = DATA State (Stock, LegalEntity, Separation) TABLE scheduleOrderABM;
nameStateABM 'Статус в ABM'(Stock st, LegalEntity l, Separation s)  = name(stateABM(st,l,s)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Stock, LegalEntity, Separation)  TABLE scheduleOrderABM;
stateABMSent (Stock st, LegalEntity l, Separation s) = stateABM(st,l,s)!=State.NA;
scheduleOrder = DATA  Purchase.ScheduleOrder(Stock, LegalEntity, Separation) TABLE scheduleOrderABM;

TABLE scheduleOrderABMSupplier (Stock, Stock, Separation);//склад-склад поставщика-признак разделения
stateABM = DATA State (Stock, Stock, Separation) TABLE scheduleOrderABMSupplier;
nameStateABM 'Статус в ABM'(Stock st, Stock supplier, Separation s)  = name(stateABM(st,supplier,s)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Stock, Stock, Separation)  TABLE scheduleOrderABMSupplier;
stateABMSent (Stock st, Stock supplier, Separation s) = stateABM(st,supplier,s)!=State.NA;
scheduleOrder = DATA  Purchase.ScheduleOrder(Stock, Stock, Separation) TABLE scheduleOrderABMSupplier;

TABLE ABMInvoiceShipments (Purchase.Invoice);
stateABMTime 'Время статуса' = DATA  DATETIME(Purchase.Invoice) TABLE ABMInvoiceShipments;
TABLE shipmentsABMInvoice (Purchase.InvoiceDetail); 
quantityABM = DATA NUMERIC[16,5] (Purchase.InvoiceDetail) TABLE shipmentsABMInvoice;
stateABMTime 'Время статуса' = DATA  DATETIME(Purchase.InvoiceDetail) TABLE shipmentsABMInvoice;

TABLE orderedABM(Purchase.Order); 
stateABM = DATA State (Purchase.Order) TABLE orderedABM;
nameStateABM 'Статус в ABM'(Purchase.Order o)  = name(stateABM(o)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(Purchase.Order) TABLE orderedABM;

stateABMTimeClose 'Время статуса Close' = DATA  DATETIME(Purchase.Order) TABLE orderedABM;

stateABM = DATA State (PriceList);
nameStateABM 'Статус в ABM'(PriceList st)  = name(stateABM(st));
stateABMTime 'Время статуса' = DATA  DATETIME(PriceList);
stateABMSent (PriceList s) = stateABM(s)!=State.NA;

TABLE promobodyABMPriceList (PriceList,Stock,Sku); 
stateABM = DATA State (PriceList,Stock,Sku) TABLE promobodyABMPriceList;
nameStateABM 'Статус в ABM'(PriceList p,Stock st,Sku s)  = name(stateABM(p,st,s)) CHARWIDTH 7;
stateABMTime 'Время статуса' = DATA  DATETIME(PriceList,Stock,Sku);
stateABMSent (PriceList p,Stock st,Sku s) = stateABM(p,st,s)!=State.NA;

//-- todo: Параметры, которые надо перегрузить в логике 
skipSentABM = ABSTRACT VALUE BOOLEAN (Sku);
toSentABM 'Выгружать' = ABSTRACT VALUE BOOLEAN (Stock);
toSentABM 'Выгружать' = ABSTRACT VALUE BOOLEAN (Sku, Stock, DATE);
toSentABM 'Выгружать' = ABSTRACT VALUE BOOLEAN (SkuGroup);
toSentABM 'Выгружать' = ABSTRACT VALUE BOOLEAN (LegalEntity);
toSentABMSuppliers 'Выгружать' = ABSTRACT VALUE BOOLEAN (Stock);
toSentABM 'Выгружать' = ABSTRACT VALUE BOOLEAN (PriceList,DATE);
//
sentABM ABSTRACT LIST(DATE,BOOLEAN);
sendABMSelected 'Отмеченные файлы за период' ABSTRACT LIST(DATE, DATE, BOOLEAN);

TABLE abmSelected() NODEFAULT;
META sendABM(action)
    skipABM###action = ABSTRACT BOOLEAN ();
    sentABM(DATE d, BOOLEAN single)+{
        IF NOT skipABM###action() THEN {
            action(d,single);
        }
    } 
    toSend###action '' = DATA BOOLEAN () TABLE abmSelected;
    sendABMSelected(DATE df, DATE dt, BOOLEAN single)+{
        IF toSend###action() THEN {
            IF NOT skipABM###action() THEN {
                FOR iterate(DATE d, df, dt) DO {
                    action(d,single);
                }
            }
        }
    }
    EXTEND FORM integrationData
        PROPERTIES SHOWIF (NOT skipABM###action()) toSend###action(), action(d, single) ;
    DESIGN integrationData {
        buttons{
            NEW action###button{
                type = CONTAINERH;
                MOVE PROPERTY (toSend###action());
                MOVE PROPERTY (action(d, single));
            }
        }
    }
END

sentDateTime = DATA LOCAL STRING ();
// null0_null1_null2_null3_null4 для подмены на просто null
replaceRN(){
    fileToString(exportFile());
    resultString()<- replace(resultString(),'\r\n','\n');
    resultString()<- replace(resultString(),'\n','\r\n');
    //resultString()<- replace(resultString(),'null0_null1_null2_null3_null4','');
    stringToFile(resultString());
    exportFile() <- resultFile();
}
dateTimeFormulasentABM (DATE date, DATETIME dt) = toDateYYYYMMDD(date)+'_'+toTimeHHMISS(dt);


toSent 'Пометить что выгрузили данные' = DATA LOCAL NESTED BOOLEAN (STRING);
fillSentTime ABSTRACT LIST (STRING);
resetSentTime ABSTRACT LIST();
deleteZippingPath(){
    FOR toSent(STRING str) DO{
        fillSentTime(str);    
    }
    toSent(STRING str)<- NULL;
    resetSentTime();
    FOR zippingPath(STRING name) ==STRING patch DO {
        TRY{delete(patch);}
    }
    zippingPath(STRING[1000] s) <- NULL;

}

sentABMCustom (DATE d, BOOLEAN single, DATETIME  time, STRING package, Stock ts){    
    IF single THEN {
        WRITE exportFile() TO '/tmp/'+ package + dateTimeFormulasentABM(d,time)+ '.csv';
        zippingPath(STRING name) <- '/tmp/' + package + dateTimeFormulasentABM(d,time) + '.csv' WHERE name ==  (package + dateTimeFormulasentABM(d,time) + '.csv');

        makeZipFile();
        WRITE zipped() TO connectionStringABM() + package+dateTimeFormulasentABM(d,time);                
        deleteZippingPath(); 

    } ELSE {
        WRITE exportFile() TO '/tmp/' + package + toDateYYYYMMDD(d)+ '.csv';
        zippingPath(STRING name) <- '/tmp/' + package + toDateYYYYMMDD(d) + '.csv' WHERE name ==  (package + toDateYYYYMMDD(d) + '.csv');
    } 
}
sentABM(DATE d, BOOLEAN single, DATETIME  time, STRING package, Stock ts, STRING packageEx){
    replaceRN();
    sentABMCustom(d,single,time,(CONCAT '', package, packageEx+'_',GLN(ts)+'_'),ts);
    exportFile() <- NULL;
}
///////////////////////////////// Таблица 1 products
//Данные о товарах 
product_uid = DATA LOCAL STRING (Sku);
name_ABM = DATA LOCAL STRING (Sku);
category_uid = DATA LOCAL STRING (Sku);
dimension_name = DATA LOCAL STRING (Sku);
volume_ABM =  DATA LOCAL NUMERIC[16,5] (Sku);
weight_ABM = DATA LOCAL NUMERIC[16,5] (Sku);
kvi_ABM = DATA LOCAL INTEGER (Sku);
cda_ABM = DATA LOCAL INTEGER (Sku);
fresh_ABM = DATA LOCAL INTEGER (Sku);
additional_1 = DATA LOCAL STRING (Sku);
additional_2 = DATA LOCAL STRING (Sku);
additional_3 = DATA LOCAL STRING (Sku);
additional_4 = DATA LOCAL STRING (Sku);       
additional_5 = DATA LOCAL STRING (Sku);
additional_6 = DATA LOCAL STRING (Sku);
additional_7 = DATA LOCAL STRING (Sku);
additional_8 = DATA LOCAL STRING (Sku);   
additional_9 = DATA LOCAL STRING (Sku);
additional_10 = DATA LOCAL STRING (Sku);

resetProducts(){
    product_uid (Sku s)<- NULL;
    name_ABM (Sku s)<- NULL;
    category_uid (Sku s)<- NULL;
    dimension_name (Sku s)<- NULL;
    volume_ABM (Sku s)<- NULL;
    weight_ABM (Sku s)<- NULL;
    kvi_ABM (Sku s)<- NULL;
    cda_ABM (Sku s)<- NULL;
    fresh_ABM (Sku s)<- NULL;
    additional_1 (Sku s)<- NULL;
    additional_2 (Sku s)<- NULL;
    additional_3 (Sku s)<- NULL;
    additional_4 (Sku s)<- NULL;    
    additional_5 (Sku s)<- NULL;
    additional_6 (Sku s)<- NULL;
    additional_7 (Sku s)<- NULL;
    additional_8 (Sku s)<- NULL; 
    additional_9 (Sku s)<- NULL;
    additional_10 (Sku s)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillProducts ABSTRACT (DATE);

products 'products' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
        filterABM(Sku s, Stock st) <- toSentABM(s,st,d);
        filterABM(Sku s) <- TRUE WHERE ( (GROUP SUM 1 IF filterABM(s, Stock st)) OR stateABMSent(s));        
    }    
    resetProducts();
    fillProducts(d);
    
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM  
        product_uid =product_uid(Sku s), 
        name =name_ABM(s), 
        category_uid = category_uid(s),
        dimension_name = dimension_name(s), 
        volume = volume_ABM(s),
        weight = weight_ABM(s),
        kvi = kvi_ABM(s),
        cda = cda_ABM(s),
        fresh = fresh_ABM(s),
        additional_1 = additional_1(s),
        additional_2 = additional_2(s),
        additional_3 = additional_3(s),
        additional_4 = additional_4(s),        
        additional_5 = additional_5(s),
        additional_6 = additional_6(s),
        additional_7 = additional_7(s),
        additional_8 = additional_8(s),       
        additional_9 = additional_9(s),    
        additional_10 = additional_10(s),   
        additional_11 = '' IF s IS Sku,
        additional_12 = '' IF s IS Sku,
        additional_13 = '' IF s IS Sku,
        additional_14 = '' IF s IS Sku         
                           
        WHERE filterABM(s);
        
    sentABM(d,single,currentDateTime(),'products_', NULL, NULL);  
}
@sendABM(products);
///////////////////////////////// Таблица 2 items
//Данные о наличии товара в ассортименте магазина, цене закупки, розничной цене и количестве остатка товара в магазине

product_uid = DATA LOCAL STRING (Sku,Stock);
store_uid = DATA LOCAL STRING (Sku,Stock);
order_available = DATA LOCAL INTEGER (Sku,Stock);
purchase_price = DATA LOCAL NUMERIC[16,4] (Sku,Stock);
sale_price =  DATA LOCAL NUMERIC[16,4] (Sku,Stock);
supplier_uid = DATA LOCAL STRING (Sku,Stock);
moq = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
usq = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
split_mark = DATA LOCAL STRING (Sku,Stock);
user_code = DATA LOCAL STRING (Sku,Stock);       
stateClass = DATA LOCAL State (Sku,Stock);
state(Sku s,Stock st) = name(stateClass(s,st));
sb_1 = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
sb_2 = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
sb_3 = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
rsl = DATA LOCAL INTEGER (Sku,Stock);
item_additional_1 = DATA LOCAL STRING (Sku,Stock);
item_additional_2 = DATA LOCAL STRING (Sku,Stock);
item_additional_3 = DATA LOCAL STRING (Sku,Stock);

resetItems(){
    product_uid (Sku s, Stock st)<- NULL;
    store_uid (Sku s, Stock st)<- NULL;
    order_available (Sku s, Stock st)<- NULL;
    purchase_price (Sku s, Stock st)<- NULL;
    sale_price (Sku s, Stock st)<- NULL;
    supplier_uid (Sku s, Stock st)<- NULL;
    moq (Sku s, Stock st)<- NULL;
    usq (Sku s, Stock st)<- NULL;
    split_mark (Sku s, Stock st)<- NULL;
    user_code (Sku s, Stock st)<- NULL;
    stateClass (Sku s, Stock st)<- NULL;
    sb_1 (Sku s, Stock st)<- NULL;
    sb_2 (Sku s, Stock st)<- NULL;    
    sb_3 (Sku s, Stock st)<- NULL;
    rsl (Sku s, Stock st)<- NULL;
    item_additional_1 (Sku s, Stock st)<- NULL;
    item_additional_2 (Sku s, Stock st)<- NULL; 
    item_additional_3 (Sku s, Stock st)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillItems ABSTRACT (Stock,DATE);

items 'items' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();      
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
        filterABM(Sku s, Stock st) <- toSentABM(s,st,d);
    }    

    FOR filterABM(Stock st) DO {
        resetItems();
        fillItems(st,d);    
        EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
            product_uid = product_uid(Sku s,st), 
            store_uid = store_uid(s,st), 
            order_available = order_available(s,st), 
            purchase_price = purchase_price(s,st), 
            sale_price = sale_price(s,st),    
            supplier_uid = supplier_uid(s,st), 
            moq = (OVERRIDE STRING(moq(s,st)), ''), 
            usq = (OVERRIDE STRING(usq(s,st)),''), 
            split_mark = split_mark(s,st), 
            user_code = user_code(s,st), 
            buffer = '',
            max_buffer = '',
            min_buffer = '',
            state = state(s,st), 
            sb_1 = sb_1(s,st), 
            sb_2 = sb_2(s,st), 
            sb_3 = '',//sb_3(s,st), на время попросили передавать пусто
            sb_4 = '', 
            sb_5 = '', 
            rsl = (OVERRIDE STRING(rsl(s,st)), ''),    
            item_additional_1 = item_additional_1(s,st),             
            item_additional_2 = item_additional_2(s,st),                        
            item_additional_3 = item_additional_3(s,st),                                                                               
            item_additional_4 = '',
            shelf = ''                                                                          
            WHERE filterABM(s, st);                            
        sentABM(d,single,currentDateTime(),'items_', st, NULL);  
    }
}
@sendABM(items);

//-- todo: Параметры, которые надо перегрузить в логике 

///////////////////////////////// Таблица 3
//Данные о движении товаров на каждой точке хранения

//product_uid = DATA LOCAL STRING (Sku,Stock);
//store_uid = DATA LOCAL STRING (Sku,Stock);
date = DATA LOCAL STRING (Sku,Stock);
balance = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
out_sale = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
in_return = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
out_return =  DATA LOCAL NUMERIC[16,5] (Sku,Stock);
in_purchase = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
in_move = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
out_move = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
in_manufacture = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
out_manufacture = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
out_write_off = DATA LOCAL NUMERIC[16,5] (Sku,Stock);
season_erp = DATA LOCAL INTEGER (Sku,Stock);
out_dsale = DATA LOCAL NUMERIC[16,5] (Sku,Stock);

resetFacts(){
    product_uid (Sku s, Stock st)<- NULL;
    store_uid (Sku s, Stock st)<- NULL;
    date (Sku s, Stock st)<- NULL;
    balance (Sku s, Stock st)<- NULL;
    out_sale (Sku s, Stock st)<- NULL;
    in_return (Sku s, Stock st)<- NULL;
    out_return (Sku s, Stock st)<- NULL;
    in_purchase (Sku s, Stock st)<- NULL;
    in_move (Sku s, Stock st)<- NULL;
    out_move (Sku s, Stock st)<- NULL;
    in_manufacture (Sku s, Stock st)<- NULL;
    out_manufacture (Sku s, Stock st)<- NULL;
    out_write_off (Sku s, Stock st)<- NULL;
    season_erp (Sku s, Stock st)<- NULL; 
    out_dsale  (Sku s, Stock st)<- NULL;   
}
//-- todo: действие, которое надо перегрузить в логике 
fillFacts ABSTRACT (Stock,DATE);


facts 'facts' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();        
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());        
        filterABM(Sku s, Stock st) <- toSentABM(s,st,d);
    }
    
    FOR filterABM(Stock st) DO {
        resetFacts();
        fillFacts(st,d);
        EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
            product_uid = product_uid(Sku s,st), 
            store_uid = store_uid(s,st), 
            date = date(s,st), 
            balance = (MAX balance(s,st),0.0), 
            out_sale = (MAX out_sale(s,st),0.0), 
            in_return = (MAX in_return(s,st),0.0), 
            out_return =  (MAX out_return(s,st),0.0), 
            in_purchase = (MAX in_purchase(s,st),0.0), 
            in_move = (MAX in_move(s,st),0.0), 
            out_move = (MAX out_move(s,st),0.0), 
            in_manufacture = (MAX in_manufacture(s,st),0.0), 
            out_manufacture = (MAX out_manufacture(s,st),0.0), 
            out_write_off = (MAX out_write_off(s,st),0.0), 
            pto = 0,
            season_erp = season_erp(s,st),
            out_dsale = out_dsale(s,st)           
            WHERE filterABM(s, st);
        sentABM(d,single,currentDateTime(),'facts_', st, NULL);  
    }
}
@sendABM(facts);
// Таблица 4
//Данные о поставщиках

supplier_uid = DATA LOCAL STRING (LegalEntity);
name_ABM = DATA LOCAL STRING (LegalEntity);
active_ABM = DATA LOCAL INTEGER (LegalEntity);

supplier_uidSuppliers = DATA LOCAL STRING (Stock);
name_ABMSuppliers = DATA LOCAL STRING (Stock);
active_ABMSuppliers = DATA LOCAL INTEGER (Stock);

fillSuppliers ABSTRACT (DATE);

resetSuppliers(){
    supplier_uid (LegalEntity l)<- NULL;
    name_ABM (LegalEntity l)<- NULL;
    active_ABM (LegalEntity l)<- NULL;

    supplier_uidSuppliers (Stock l)<- NULL;
    name_ABMSuppliers (Stock l)<- NULL;
    active_ABMSuppliers (Stock l)<- NULL;
}

suppliers 'suppliers' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(LegalEntity s) <- TRUE WHERE toSentABM(s);
        filterABMSuppliers(Stock s) <- TRUE WHERE toSentABMSuppliers(s);
    } 
    resetSuppliers();    
    fillSuppliers(d);

//    LOCAL a = STRING(INTEGER);
//    LOCAL b = STRING(INTEGER);
//    LOCAL c = STRING(INTEGER);
//    
//    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM
//        supplier_uid = a(INTEGER i),
//        name = b(i),
//        active = c(i);
//
//    WRITE exportFile() TO '/tmp/temp_suppliers';
    
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        supplier_uid = supplier_uid(LegalEntity l), 
        name = name_ABM(l), 
        active = active_ABM(l)
    WHERE filterABM(l);
    WRITE exportFile() TO '/tmp/temp_suppliers' APPEND;
    
    EXPORT CSV ',' ESCAPE CHARSET 'UTF-8' FROM
        supplier_uid = supplier_uidSuppliers(Stock l),
        name = name_ABMSuppliers(l),
        active = active_ABMSuppliers(l)
        WHERE filterABMSuppliers(l);
    WRITE exportFile() TO '/tmp/temp_suppliers' APPEND;
    
    READ '/tmp/temp_suppliers.csv' TO exportFile;
    delete('/tmp/temp_suppliers.csv');
    
    sentABM(d,single,currentDateTime(),'suppliers_', NULL, NULL);          
}
@sendABM(suppliers);
// Таблица 5 stores
//Данные о магазинах
store_uid = DATA LOCAL STRING (Stock);
name_ABM = DATA LOCAL STRING (Stock);
address_ABM = DATA LOCAL STRING (Stock);
group_name = DATA LOCAL STRING (Stock);
active_ABM = DATA LOCAL INTEGER (Stock);
central = DATA LOCAL INTEGER (Stock);

resetStores(){
    store_uid (Stock s)<- NULL;
    name_ABM (Stock s)<- NULL;
    address_ABM (Stock s)<- NULL;
    group_name (Stock s)<- NULL;
    active_ABM (Stock s)<- NULL;
    central (Stock s)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillStores ABSTRACT (DATE);

stores 'stores' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    }
    resetStores();
    fillStores(d);
    
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        store_uid = store_uid(Stock l), 
        name = name_ABM(l), 
        address = address_ABM(l), 
        group_name = group_name(l),
        active = active_ABM(l),
        central = central(l)
    WHERE filterABM(l);
    sentABM(d,single,currentDateTime(),'stores_', NULL, NULL);          
}
@sendABM(stores);
// Таблица 6
//Данные о графиках формирования заказов поставщиков
store_uid = DATA LOCAL STRING (Stock,LegalEntity,Separation);
supplier_uid = DATA LOCAL STRING (Stock,LegalEntity,Separation);
split_mark = DATA LOCAL STRING (Stock,LegalEntity,Separation);
active = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_mo = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_tu = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_we = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_th = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_fr = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_sa = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
olt_su = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
period = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
frequency = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
begin_date = DATA LOCAL STRING (Stock,LegalEntity,Separation);
auto_send = DATA LOCAL INTEGER (Stock,LegalEntity,Separation);
comment = DATA LOCAL STRING (Stock,LegalEntity,Separation);
//--
store_uid = DATA LOCAL STRING (Stock,Stock,Separation);
supplier_uid = DATA LOCAL STRING (Stock,Stock,Separation);
split_mark = DATA LOCAL STRING (Stock,Stock,Separation);
active = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_mo = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_tu = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_we = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_th = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_fr = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_sa = DATA LOCAL INTEGER (Stock,Stock,Separation);
olt_su = DATA LOCAL INTEGER (Stock,Stock,Separation);
period = DATA LOCAL INTEGER (Stock,Stock,Separation);
frequency = DATA LOCAL INTEGER (Stock,Stock,Separation);
begin_date = DATA LOCAL STRING (Stock,Stock,Separation);
auto_send = DATA LOCAL INTEGER (Stock,Stock,Separation);
comment = DATA LOCAL STRING (Stock,Stock,Separation);

resetSchedules(){
    store_uid (Stock st,LegalEntity l,Separation s)<- NULL;
    supplier_uid (Stock st,LegalEntity l,Separation s)<- NULL;
    split_mark (Stock st,LegalEntity l,Separation s)<- NULL;
    active (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_mo (Stock st,LegalEntity l,Separation s)<- NULL;    
    olt_tu (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_we (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_th (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_fr (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_sa (Stock st,LegalEntity l,Separation s)<- NULL;
    olt_su (Stock st,LegalEntity l,Separation s)<- NULL;                                  
    period (Stock st,LegalEntity l,Separation s)<- NULL;
    frequency (Stock st,LegalEntity l,Separation s)<- NULL;  
    begin_date (Stock st,LegalEntity l,Separation s)<- NULL;      
    auto_send (Stock st,LegalEntity l,Separation s)<- NULL;   
    comment (Stock st,LegalEntity l,Separation s)<- NULL;   
    //
    store_uid (Stock st,Stock l,Separation s)<- NULL;
    supplier_uid (Stock st,Stock l,Separation s)<- NULL;
    split_mark (Stock st,Stock l,Separation s)<- NULL;
    active (Stock st,Stock l,Separation s)<- NULL;
    olt_mo (Stock st,Stock l,Separation s)<- NULL;
    olt_tu (Stock st,Stock l,Separation s)<- NULL;
    olt_we (Stock st,Stock l,Separation s)<- NULL;
    olt_th (Stock st,Stock l,Separation s)<- NULL;
    olt_fr (Stock st,Stock l,Separation s)<- NULL;
    olt_sa (Stock st,Stock l,Separation s)<- NULL;
    olt_su (Stock st,Stock l,Separation s)<- NULL;
    period (Stock st,Stock l,Separation s)<- NULL;
    frequency (Stock st,Stock l,Separation s)<- NULL;
    begin_date (Stock st,Stock l,Separation s)<- NULL;
    auto_send (Stock st,Stock l,Separation s)<- NULL;
    comment (Stock st,Stock l,Separation s)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillSchedules ABSTRACT (DATE);

schedules 'schedules' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
        filterABM(LegalEntity l) <- TRUE WHERE toSentABM(l);
        filterABMSuppliers(Stock l) <- TRUE WHERE toSentABMSuppliers(l);
    }
    resetSchedules();
    fillSchedules(d);
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        store_uid = store_uid(Stock st,LegalEntity l,Separation s), 
        supplier_uid = supplier_uid(st,l,s), 
        split_mark = (OVERRIDE split_mark(st,l,s), ''),
        active = active(st,l,s),
        olt_mo = olt_mo(st,l,s),
        olt_tu = olt_tu(st,l,s),
        olt_we = olt_we(st,l,s),
        olt_th = olt_th(st,l,s),
        olt_fr = olt_fr(st,l,s),
        olt_sa = olt_sa(st,l,s),
        olt_su = olt_su(st,l,s),
        period = period(st,l,s),
        frequency = frequency(st,l,s),
        begin_date = (OVERRIDE begin_date(st,l,s), ''),
        auto_send = auto_send(st,l,s),
        emails = '' IF st IS Stock AND l IS LegalEntity AND s IS Separation,
        delivery_slot = '' IF st IS Stock AND l IS LegalEntity AND s IS Separation,
        comment = comment(st,l,s)  
    WHERE filterABM(st,l,s);
    WRITE exportFile() TO '/tmp/temp_schedules' APPEND;

    EXPORT CSV ',' ESCAPE CHARSET 'UTF-8' FROM
        store_uid = store_uid(Stock st,Stock l,Separation s),
        supplier_uid = supplier_uid(st,l,s),
        split_mark = (OVERRIDE split_mark(st,l,s), ''),
        active = active(st,l,s),
        olt_mo = olt_mo(st,l,s),
        olt_tu = olt_tu(st,l,s),
        olt_we = olt_we(st,l,s),
        olt_th = olt_th(st,l,s),
        olt_fr = olt_fr(st,l,s),
        olt_sa = olt_sa(st,l,s),
        olt_su = olt_su(st,l,s),
        period = period(st,l,s),
        frequency = frequency(st,l,s),
        begin_date = (OVERRIDE begin_date(st,l,s), ''),
        auto_send = auto_send(st,l,s),
        emails = '' IF st IS Stock AND l IS Stock AND s IS Separation,
        delivery_slot = '' IF st IS Stock AND l IS Stock AND s IS Separation,
        comment = comment(st,l,s)
        WHERE filterABM(st,l,s);
    WRITE exportFile() TO '/tmp/temp_schedules' APPEND;

    READ '/tmp/temp_schedules.csv' TO exportFile;
    delete('/tmp/temp_schedules.csv');
    
    sentABM(d,single,currentDateTime(),'schedules_', NULL, NULL);          
}
@sendABM(schedules);
// Таблица 7
//Данные об оприходованных заказах
//-- todo: Параметры, которые надо перегрузить в логике 
filterShipments = ABSTRACT VALUE BOOLEAN (Purchase.OrderDetail, DATE);
numberABM 'Номер ABM' = DATA STRING (Purchase.Order) INDEXED CHARWIDTH 10;
orderNumberABM = GROUP AGGR Purchase.Order o BY numberABM(o);
numberABM 'Номер ABM' (Purchase.OrderDetail d) = numberABM(order(d)) CHARWIDTH 10;
EXTEND FORM Purchase.userOrder
    PROPERTIES (o) numberABM
;
DESIGN Purchase.userOrder{
    second { 
        MOVE PROPERTY (numberABM(o)) AFTER PROPERTY (number(o));
    }
}
EXTEND FORM Purchase.orders
    PROPERTIES (o) READONLY  numberABM AFTER number(o)
;


product_uid = DATA LOCAL STRING (Purchase.InvoiceDetail);
store_uid = DATA LOCAL STRING (Purchase.InvoiceDetail);
supplier_uid = DATA LOCAL STRING (Purchase.InvoiceDetail);
quantity_ABM = DATA LOCAL NUMERIC[16,5] (Purchase.InvoiceDetail);
order_number = DATA LOCAL STRING (Purchase.InvoiceDetail);
document_uid = DATA LOCAL STRING (Purchase.InvoiceDetail);

resetShipments(){
    product_uid (Purchase.InvoiceDetail d)<- NULL;
    store_uid (Purchase.InvoiceDetail d)<- NULL;
    supplier_uid (Purchase.InvoiceDetail d)<- NULL;
    quantity_ABM (Purchase.InvoiceDetail d)<- NULL;
    order_number (Purchase.InvoiceDetail d)<- NULL;    
    document_uid (Purchase.InvoiceDetail d)<- NULL; 
}
//-- todo: действие, которое надо перегрузить в логике 
fillShipments ABSTRACT (DATE);

shipments 'shipments' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    }
    resetShipments();
    fillShipments(d);
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        product_uid = product_uid(Purchase.InvoiceDetail dd), 
        store_uid = store_uid(dd), 
        supplier_uid = supplier_uid(dd),       
        quantity = quantity_ABM(dd),
        order_number = order_number(dd),
        document_uid = document_uid(dd)
        WHERE filterABM(dd);       
    sentABM(d,single,currentDateTime(),'shipments_', NULL, NULL);          
}
@sendABM(shipments);
// Таблица 8
//Данные о закрытии размещенных заказов
filterABMCloseLocal = DATA LOCAL NESTED BOOLEAN (Purchase.Order);
fillSentTime(STRING  str) +{
    IF str == 'orderclose' THEN {
        NEWSESSION NESTED LOCAL {
            stateABMTimeClose (Purchase.Order o) <- currentDateTime() WHERE filterABMCloseLocal(o);
            APPLY NESTED LOCAL;
        }
    }
}
resetSentTime()+{
    filterABMCloseLocal(Purchase.Order o)<- NULL;    
}

orderclose 'orderclose' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    }
    filterABMClose(Purchase.Order o)<- TRUE WHERE numberABM(o)==getWord(numberABM(o), '~',1) AND filterABM(customerStock(o)) AND NOT isOpened(o) AND NOT stateABMTimeClose(o);
    filterABMCloseLocal(Purchase.Order o)<- TRUE WHERE numberABM(o)==getWord(numberABM(o), '~',1) AND filterABM(customerStock(o)) AND NOT isOpened(o) AND NOT stateABMTimeClose(o);
    toSent('orderclose')<- TRUE;
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        order_number = numberABM(Purchase.Order o)
        WHERE filterABMClose(o);       
    sentABM(d,single,currentDateTime(),'orderclose_', NULL, NULL);            
}
@sendABM(orderclose);
// Таблица 9
//Данные о корректировке отправленных заказов, сделанных на стороне клиента

product_uid = DATA LOCAL STRING (Purchase.OrderDetail);
store_uid = DATA LOCAL STRING (Purchase.OrderDetail);
supplier_uid = DATA LOCAL STRING (Purchase.OrderDetail);
quantity_ABM = DATA LOCAL NUMERIC[16,5] (Purchase.OrderDetail);
order_number = DATA LOCAL STRING (Purchase.OrderDetail);
delivery_date = DATA LOCAL STRING (Purchase.OrderDetail);

resetOrdered(){
    product_uid (Purchase.OrderDetail d)<- NULL;
    store_uid (Purchase.OrderDetail d)<- NULL;
    supplier_uid (Purchase.OrderDetail d)<- NULL;
    quantity_ABM (Purchase.OrderDetail d)<- NULL;
    order_number (Purchase.OrderDetail d)<- NULL;
    delivery_date (Purchase.OrderDetail d)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillOrdered ABSTRACT (DATE);
fillOrdered ABSTRACT ();
ordered 'ordered' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());        
    }
    resetOrdered();
    fillOrdered(d);                                                 
    
    FOR filterABM(Purchase.UserOrder o) DO {
        EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
            product_uid = product_uid(Purchase.UserOrderDetail dd), 
            store_uid = store_uid(dd), 
            supplier_uid = supplier_uid(dd), 
            quantity = quantity_ABM(dd), 
            order_number = order_number(dd), 
            delivery_date = delivery_date(dd)
            WHERE userOrder(dd) == o AND order_number(dd);        
        sentABM(d,single,currentDateTime(),'ordered_', NULL, numberABM(o)+'_');     
    }   
}


@sendABM(ordered);
// Таблица 11 и 12
// Данные о создании новых периодах и их настройках (Акции)
//-- todo: Параметры, которые надо перегрузить в логике 

promo_uid = DATA LOCAL STRING (PriceList);
name_ABM = DATA LOCAL STRING (PriceList);
buffer_type = DATA LOCAL INTEGER (PriceList);
begin_date = DATA LOCAL STRING (PriceList);
end_date = DATA LOCAL STRING (PriceList);
buffer_change = DATA LOCAL INTEGER (PriceList);
ignore_max_buffer = DATA LOCAL INTEGER (PriceList);
buffer_control = DATA LOCAL INTEGER (PriceList);
end_action = DATA LOCAL INTEGER (PriceList);
promo_type_code = DATA LOCAL STRING (PriceList);
default_promo_mechanic_code = DATA LOCAL STRING (PriceList);

promo_uid = DATA LOCAL STRING (PriceList,Stock,Sku);
product_uid = DATA LOCAL STRING (PriceList,Stock,Sku);
store_uid = DATA LOCAL STRING (PriceList,Stock,Sku);
promo_mechanic_code = DATA LOCAL STRING (PriceList,Stock,Sku);
nonpromo_price = DATA LOCAL NUMERIC[16,4] (PriceList,Stock,Sku);
promo_price = DATA LOCAL NUMERIC[16,4] (PriceList,Stock,Sku);
deleted = DATA LOCAL INTEGER (PriceList,Stock,Sku);

resetPromoheader(){
    promo_uid (PriceList p)<- NULL;
    name_ABM (PriceList p)<- NULL;
    buffer_type (PriceList p)<- NULL;
    begin_date (PriceList p)<- NULL;
    end_date (PriceList p)<- NULL;
    buffer_change (PriceList p)<- NULL;
    ignore_max_buffer (PriceList p)<- NULL;
    buffer_control (PriceList p)<- NULL;
    end_action (PriceList p)<- NULL;
    promo_type_code (PriceList p)<- NULL;
    default_promo_mechanic_code (PriceList p)<- NULL;
    //
    promo_uid (PriceList d,Stock st, Sku s)<- NULL;
    product_uid (PriceList d,Stock st, Sku s)<- NULL;
    store_uid (PriceList d,Stock st, Sku s)<- NULL;
    promo_mechanic_code (PriceList d,Stock st, Sku s)<- NULL;
    nonpromo_price (PriceList d,Stock st, Sku s)<- NULL;
    promo_price (PriceList d,Stock st, Sku s)<- NULL;        
    deleted (PriceList d,Stock st, Sku s)<- NULL;        
}
fillPromoheader ABSTRACT (DATE);

namePromotionAMB = ABSTRACT STRING (PriceList);
bufferTypeAMB = ABSTRACT INTEGER (PriceList);
bufferChangeAMB = ABSTRACT INTEGER (PriceList);
ignoreMaxBufferAMB = ABSTRACT INTEGER (PriceList);
bufferControlAMB = ABSTRACT INTEGER (PriceList);
// делаем два вместе promoHEADER ESCAPE и promobody
promoheader 'promoheader/promobody' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    }
    filterABM(PriceList s) <- TRUE WHERE toSentABM(s,d);
    filterABM(PriceList p, Stock st, Sku s) <- TRUE WHERE filterABM(p) AND filterABM(st) AND
                                                    ((in(p,st)  AND userPriceListDetail(p,s) AND NOT skipSentABM(s)) OR stateABMSent(p,st,s));
    
    resetPromoheader();
    fillPromoheader(d);
    IF (GROUP SUM 1 IF filterABM (PriceList p)) THEN {
        EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
            promo_uid = promo_uid(PriceList p), 
            name = name_ABM(p), 
            buffer_type = buffer_type(p), 
            begin_date = begin_date(p), 
            end_date = end_date(p), 
            buffer_change = buffer_change(p),
            ignore_max_buffer = ignore_max_buffer(p),
            buffer_control = buffer_control(p),
            end_action = end_action(p),
            promo_type_code = promo_type_code(p),
            default_promo_mechanic_code = default_promo_mechanic_code(p)
            WHERE filterABM(p);
        sentABM(d,single,currentDateTime(),'promoheader_', NULL, NULL);        
    }    
    IF (GROUP SUM 1 IF filterABM (PriceList p)) THEN {
        EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
            promo_uid = promo_uid(PriceList p, Stock st, Sku s), 
            product_uid = product_uid(p,st,s), 
            store_uid = store_uid(p,st,s), 
            promo_mechanic_code = promo_mechanic_code(p,st,s), 
            nonpromo_price = nonpromo_price(p,st,s), 
            promo_price = promo_price(p,st,s),
            delete = deleted(p,st,s)
            WHERE filterABM(p,st,s);
        sentABM(d,single,currentDateTime(),'promobody_', NULL, NULL);       
    }       
}

@sendABM(promoheader);

// Таблица 15 categories
// Данные основных категорий товаров

category_uid = DATA LOCAL STRING (SkuGroup);
name = DATA LOCAL STRING (SkuGroup);
parent_category_uid = DATA LOCAL STRING (SkuGroup);
deleted = DATA LOCAL INTEGER (SkuGroup);

resetCategories(){
    category_uid (SkuGroup s)<- NULL;
    name (SkuGroup s)<- NULL;
    parent_category_uid (SkuGroup s)<- NULL;
    deleted (SkuGroup s)<- NULL;
}
//-- todo: действие, которое надо перегрузить в логике 
fillCategories ABSTRACT (DATE);

categories 'categories' (DATE d, BOOLEAN single) {
    IF single THEN {
        resetFilterABM();
        filterABM(SkuGroup s) <- TRUE WHERE toSentABM(s);
    } 
    resetCategories();    
    fillCategories(d);
    EXPORT CSV ',' HEADER ESCAPE CHARSET 'UTF-8' FROM 
        category_uid = category_uid(SkuGroup g), 
        name = name(g), 
        parent_category_uid = parent_category_uid(parent(g)),
        deleted = deleted(g)
    WHERE filterABM(g) AND g IS Item.ItemGroup;
    
    sentABM(d,single,currentDateTime(),'categories_', NULL, NULL);       
}
@sendABM(categories);

//////////////////////////////////////////////////
exportPrefix = ABSTRACT STRING();
exportAll 'Все файлы' (DATE d) {
    
    resetFilterABM();
        
    filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    filterABM(Sku s, Stock st) <- toSentABM(s,st,d);    
    filterABM(Sku s) <- TRUE WHERE (GROUP SUM 1 IF filterABM(s, Stock st)) OR stateABMSent(s);
    filterABM(SkuGroup s) <- active(s) OR stateABMSent(s);    
    filterABM(LegalEntity l) <- TRUE WHERE toSentABM(l);
    filterABMSuppliers(Stock l) <- TRUE WHERE toSentABMSuppliers(l);
    zippingPath(STRING[1000] s) <- NULL;
    
    sentABM(d, NULL);
    
    makeZipFile();
    WRITE zipped() TO connectionStringABM() + (CONCAT'_',exportPrefix(),toDateYYYYMMDD(d));
    deleteZippingPath(); 
}


EXTEND FORM integrationData   
    PROPERTIES exportAll(d), sendABMSelected(d, dToABM, single)
        
    OBJECTS abmStock = Stock
    PROPERTIES(abmStock) selectABM
    PROPERTIES(abmStock) READONLY id, Stock.name, objectClassName
    FILTERS isCompany(abmStock)
;

DESIGN integrationData {
    tab1 {
        buttons {
            MOVE PROPERTY(exportAll(d));
            MOVE PROPERTY(sendABMSelected(d, dToABM, single));
        }
        MOVE BOX(abmStock) { fill = 2; }
    }
}

name = DATA LOCAL STRING();
type = DATA LOCAL STRING();
status = DATA LOCAL STRING();

title = DATA LOCAL STRING();
message = DATA LOCAL STRING();

GROUP error;
GROUP state;

FORM answerABM
    PROPERTIES() IN state name, type, status
    PROPERTIES() IN error title, message
;

tokenABM 'Токен ABM API' = DATA STRING[255]() ECHO ;

name_ABM = DATA LOCAL STRING();
type_ABM = DATA LOCAL STRING();

FORM ordered
    PROPERTIES() name_ABM EXTID 'name', type_ABM EXTID 'type'
    
    OBJECTS data = Purchase.UserOrderDetail
    PROPERTIES(data) quantity =quantity_ABM, warehouse_code = store_uid, sku = product_uid, order_id= numberABM
    FILTERS filterABM(data)
;


exportOrdered 'ordered API' (DATE d){
    resetFilterABM();
    filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    type_ABM()<- 'ordered';
    name_ABM() <-  'ordered_'+toDateYYYYMMDD(currentDate())+'_'+toTimeHHMISS(currentDateTime());
    resetOrdered();
    fillOrdered(d);  
    EXPORT ordered JSON;
    TRY {
        IF exportPostABMPath() THEN {
            LOCAL headers = TEXT(STRING[100]);
            headers('Authorization') <- tokenABM();
            EXTERNAL HTTP POST exportPostABMPath()  HEADERS headers PARAMS exportFile() TO resultFile;
            IMPORT answerABM JSON FROM resultFile();
            IF title()  THEN {
                logToFile('ABM', (CONCAT '\n', currentDateTime()+ ' ERROR IN Body: ordered', (CONCAT ', ', title(), message())));    
            }
        }
    } CATCH {
        logToFile('ABM', (CONCAT '\n', 'ERROR: ordered', (CONCAT '\n\n', messageCaughtException(), lsfStackTraceCaughtException(), javaStackTraceCaughtException ())));
    }
} 

FORM shipments
    PROPERTIES() name_ABM EXTID 'name', type_ABM EXTID 'type'
    
    OBJECTS data = Purchase.UserInvoiceDetail
    PROPERTIES(data) quantity =quantity_ABM, warehouse_code = store_uid, sku = product_uid, order_id= order_number
    FILTERS filterABM(data)
;

exportShipments 'shipments API'(DATE d){
    resetFilterABM();
    filterABM(Stock st) <- TRUE WHERE toSentABM(st) AND (selectABM(st) OR NOT countSelectABM());
    type_ABM()<- 'shipments';
    name_ABM() <-  'shipments_'+toDateYYYYMMDD(currentDate())+'_'+toTimeHHMISS(currentDateTime());
    resetShipments();
    fillShipments(d);  
    EXPORT shipments JSON;
    TRY {
        IF exportPostABMPath() THEN {
            LOCAL headers = TEXT(STRING[100]);
            headers('Authorization') <- tokenABM();
            EXTERNAL HTTP POST exportPostABMPath()  HEADERS headers PARAMS exportFile() TO resultFile;
            IMPORT answerABM JSON FROM resultFile();
            IF title()  THEN {
                logToFile('ABM', (CONCAT '\n', currentDateTime() +' ERROR IN Body: shipments', (CONCAT ', ', title(), message())));    
            }
        }
    } CATCH {
        logToFile('ABM', (CONCAT '\n', 'ERROR: shipments', (CONCAT '\n\n', messageCaughtException(), lsfStackTraceCaughtException(), javaStackTraceCaughtException ())));
    }
} 

EXTEND FORM integrationData
    PROPERTIES () tokenABM
    PROPERTIES (d) exportOrdered, exportShipments
;
DESIGN integrationData{
    buttons {
        MOVE PROPERTY (exportOrdered(d));
        MOVE PROPERTY (exportShipments(d));
    }
}
