MODULE PriceListLedger;

REQUIRE PriceListType, Historizable;

NAMESPACE PriceList;

CLASS ABSTRACT LedgerPriceListType 'Регистровый вид цены' : BasePriceListType;

name 'Наименование' = ABSTRACT ISTRING[100](LedgerPriceListType) IN id;
name(LedgerPriceListType type) += name(type) IF type IS LedgerPriceListType;

differentOrganizations 'Для разных организаций' = ABSTRACT CASE EXCLUSIVE BOOLEAN (LedgerPriceListType) MATERIALIZED;    

TABLE ledgerPriceListTypeStock (LedgerPriceListType, Stock);
batch 'Использовать для партий свои цены' = ABSTRACT CASE EXCLUSIVE BOOLEAN (LedgerPriceListType, Stock) MATERIALIZED;
// свойство нужно, чтобы у таблицы была правильная статистика по свойству batch  
isCompany 'Склад компании' (LedgerPriceListType t, Stock s) = t IS LedgerPriceListType AND isCompany(s) MATERIALIZED; 

skipBatch = ABSTRACT CASE BOOLEAN (LedgerPriceListType, Stock, Batch);
                                                   
FORM ledgerPriceListTypes 'Регистровые виды цен'
   OBJECTS p = LedgerPriceListType
   PROPERTIES(p) READONLY name
   
   LIST LedgerPriceListType OBJECT p
;
    
CLASS ABSTRACT PriceListLedger 'Изменение цены';
TABLE priceListLedger(PriceListLedger);

@defineCreatedAbstract(PriceListLedger);

show 'Просмотреть'  ABSTRACT MULTI ( PriceListLedger) TOOLBAR;

fromDateTime 'Дата/время с' = ABSTRACT DATETIME (PriceListLedger) MATERIALIZED;
toDateTime 'Дата/время по' = ABSTRACT DATETIME (PriceListLedger) MATERIALIZED;

isPosted 'Проведен' (ledger) = ABSTRACT BOOLEAN (PriceListLedger) MATERIALIZED;
skip 'Не изменять значение' (ledger) = ABSTRACT BOOLEAN (PriceListLedger) MATERIALIZED;

active 'Активен' (PriceListLedger ledger) = isPosted(ledger) AND NOT skip(ledger) MATERIALIZED;

sku = ABSTRACT Sku (PriceListLedger) MATERIALIZED;
nameSku 'SKU' (PriceListLedger l) = name(sku(l));

operation = ABSTRACT Operation (PriceListLedger);

countPriceListLedger = GROUP SUM 1 BY sku(PriceListLedger ledger);

TABLE priceListLedgerBatch(PriceListLedger, Batch);
in = ABSTRACT BOOLEAN (PriceListLedger, Batch) MATERIALIZED;

batch (PriceListLedger ledger) = GROUP MAX Batch batch IF in(ledger, batch);
idBatch (PriceListLedger ledger) = id(batch(ledger));

description 'Описание' = ABSTRACT ISTRING[200] (PriceListLedger) MATERIALIZED;

company = ABSTRACT LegalEntity (PriceListLedger) MATERIALIZED;
nameCompany 'Компания' = name(company(PriceListLedger ledger));
INDEX sku(PriceListLedger ledger), company(ledger), fromDateTime(ledger), ledger;

companyStock = ABSTRACT Stock (PriceListLedger) MATERIALIZED INDEXED;

TABLE priceListLedgerLedgerPriceListType(PriceListLedger, LedgerPriceListType);
in = ABSTRACT BOOLEAN (PriceListLedger, LedgerPriceListType) MATERIALIZED;
price 'Цена' = ABSTRACT NUMERIC[16,4] (PriceListLedger, LedgerPriceListType) MATERIALIZED CHARWIDTH 7;

priceListTypes 'Цены' (PriceListLedger priceList) = GROUP
                                                                CONCAT name(LedgerPriceListType type) IF in(priceList, type) , ', '
                                                                ORDER type CHARWIDTH 20;

in (ledger, stock) = ABSTRACT BOOLEAN (PriceListLedger, Stock);
stock (PriceListLedger ledger) = GROUP MAX Stock stock IF in(ledger, stock);

stocks 'Склады' (PriceListLedger priceList) = GROUP
                                                   CONCAT name(Stock stock) IF in(priceList, stock) , ', '
                                                   ORDER stock CHARWIDTH 20;

// ------------------ Расчет цен для sku ---------------- //

active(PriceListLedger ledger, LedgerPriceListType type) =
    active(ledger) AND in(ledger, type) MATERIALIZED;

priceB 'Цена' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type)
          ORDER fromDateTime(ledger), ledger
          WHERE active(ledger, type) AND
                fromDateTime(ledger) < dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;

priceA 'Цена' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type)
          ORDER fromDateTime(ledger), ledger
          WHERE active(ledger, type) AND
                fromDateTime(ledger) <= dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;

// Только с ценами

//activePriceB 'Цена' (type, sku, company, dateTime) =
//    GROUP LAST price(PriceListLedger ledger, LedgerPriceListType type)
//          BY type, sku(ledger), company(ledger), DATETIME dateTimeIn
//          ORDER fromDateTime(ledger), ledger
//          WHERE price(ledger, type) AND active(ledger, type) AND
//                fromDateTime(ledger) < dateTimeIn AND NOT toDateTime(ledger) < dateTimeIn COMPLEX;

//activePriceA 'Цена' (type, sku, company, dateTime) =
//    GROUP LAST price(PriceListLedger ledger, LedgerPriceListType type)
//          BY type, sku(ledger), company(ledger), DATETIME dateTimeIn
//          ORDER fromDateTime(ledger), ledger
//          WHERE price(ledger, type) AND active(ledger, type) AND
//                fromDateTime(ledger) <= dateTimeIn AND NOT toDateTime(ledger) < dateTimeIn COMPLEX;

//activeDescriptionB 'Описание' (type, sku, company, dateTime) =
//    GROUP LAST description(PriceListLedger ledger)
//          BY LedgerPriceListType type, sku(ledger), company(ledger), DATETIME dateTimeIn
//          ORDER fromDateTime(ledger), ledger
//          WHERE price(ledger, type) AND active(ledger, type) AND
//                fromDateTime(ledger) < dateTimeIn AND NOT toDateTime(ledger) < dateTimeIn COMPLEX;

//activeDescriptionA 'Описание' (type, sku, company, dateTime) =
//    GROUP LAST description(PriceListLedger ledger)
//          BY LedgerPriceListType type, sku(ledger), company(ledger), DATETIME dateTimeIn
//          ORDER fromDateTime(ledger), ledger
//          WHERE price(ledger, type) AND active(ledger, type) AND
//                fromDateTime(ledger) <= dateTimeIn AND NOT toDateTime(ledger) < dateTimeIn COMPLEX;

activeLedgerA (LedgerPriceListType type, sku, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger), ledger
          WHERE price(ledger, type) AND active(ledger, type) AND
                fromDateTime(ledger) <= dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger), company(ledger) COMPLEX;

//по складу компании
activeLedgerA (LedgerPriceListType type, sku, companyStock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger), ledger
          WHERE price(ledger, type) AND active(ledger, type) AND
                fromDateTime(ledger) <= dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger), companyStock(ledger) COMPLEX;


// ------------------ Расчет цен для sku / stock / datetime

TABLE priceListLedgerLedgerPriceListTypeStock (PriceListLedger, LedgerPriceListType, Stock);

skip = ABSTRACT BOOLEAN (LedgerPriceListType, Stock);
active(PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    active(ledger, type) AND in(ledger, stock) AND NOT skip(type, stock) MATERIALIZED;

price 'Цена' (PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    price(ledger, type) IF active(ledger, type, stock) MATERIALIZED CHARWIDTH 7;

sku(PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    sku(ledger) IF active(ledger, type, stock) MATERIALIZED;
    
fromDateTime 'Дата/время с' (PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    fromDateTime(ledger) IF active(ledger, type, stock) MATERIALIZED;

toDateTime 'Дата/время по' (PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    toDateTime(ledger) IF active(ledger, type, stock) MATERIALIZED;

INDEX LedgerPriceListType type, sku(PriceListLedger ledger, type, Stock stock), stock, fromDateTime(ledger, type, stock), ledger;
INDEX sku(PriceListLedger ledger, LedgerPriceListType type, Stock stock), stock;

//INDEX LedgerPriceListType type, Stock stock, fromDateTime(PriceListLedger ledger, type, stock);

company(PriceListLedger ledger, LedgerPriceListType type, Stock stock) =
    company(ledger) IF active(ledger, type, stock) MATERIALIZED;

// По товарам
activePriceB 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;

activePriceA 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;

prevActivePriceA 'Цена' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(activePriceA (type, sku, stock, dateTime));

prevActivePriceB 'Цена' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(activePriceB (type, sku, stock, dateTime));

activePriceListLedgerB  (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;
prevActivePriceListLedgerB (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(activePriceListLedgerB(type, sku, stock, dateTime));  
              
activePriceListLedgerA  (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;
prevActivePriceListLedgerA (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(activePriceListLedgerA(type, sku, stock, dateTime));   

//-- Следующая цена, которая проводится по регистру, после даты/время
activeNextPriceA 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER DESC fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) >= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;
                
activeNextPriceB 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER DESC fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) > dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;
 
activeNextPriceA 'Цена' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type)
          ORDER DESC fromDateTime(ledger), ledger
          WHERE price(ledger, type) AND active(ledger, type) AND
                fromDateTime(ledger) >= dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;
                
activeNextPriceB 'Цена' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type)
          ORDER DESC fromDateTime(ledger), ledger
          WHERE price(ledger, type) AND active(ledger, type) AND
                fromDateTime(ledger) > dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;

// По компаниям

// ------------------ Расчет цен для sku / company ---------------- //

INDEX LedgerPriceListType type, company(PriceListLedger ledger, type, Stock stock), sku(ledger, type, stock), fromDateTime(ledger, type, stock), ledger; 
INDEX LedgerPriceListType type, Stock stock, company(PriceListLedger ledger, type, stock), sku(ledger, type, stock), fromDateTime(ledger, type, stock), ledger; 

// расчет цены по компании считается на основе ledger/type/stock потому, что только в ней есть индекс по компании и виду цен одновременно, что позволяет быстро отсечь ненужные цены
activePriceListLedgerB 'Цена' (LedgerPriceListType type, sku, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, Stock stock), ledger
          WHERE price(ledger, type, stock) AND fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

activePriceListLedgerA 'Цена' (LedgerPriceListType type, sku, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, Stock stock), ledger
          WHERE price(ledger, type, stock) AND fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

activeDescriptionB 'Описание' (LedgerPriceListType type, Sku sku, LegalEntity company, DATETIME dateTime) =
    description(activePriceListLedgerB(type, sku, company, dateTime));

activeDescriptionA 'Описание' (LedgerPriceListType type, Sku sku, LegalEntity company, DATETIME dateTime) =
    description(activePriceListLedgerA(type, sku, company, dateTime)) CHARWIDTH 30;

activePriceA 'Цена' (LedgerPriceListType type, sku, company, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, Stock stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX CHARWIDTH 7;
                                
// Только с ценами
priceB 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX CHARWIDTH 7;

priceA 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX CHARWIDTH 7;

priceListLedgerA (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;

prevPriceListLedgerA 'Цена (пред.)' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(priceListLedgerA(type, sku, stock, dateTime)) COMPLEX;                
          
priceListLedgerB (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;    
prevPriceListLedgerB 'Цена (пред.)' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(priceListLedgerB(type, sku, stock, dateTime)) COMPLEX;                

currentPriceListLedger 'Цена' (LedgerPriceListType type, sku, Stock stock) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          BY sku(ledger, type, stock) COMPLEX;

lastPriceListLedger 'Цена' (LedgerPriceListType type, sku, Stock stock) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          BY sku(ledger, type, stock) COMPLEX;

lastPriceListLedger 'Цена' (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock) COMPLEX;


META defineLastLedgerPriceListTypeSkuStock(property, caption)
    property##B caption (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
        GROUP LAST property(PriceListLedger ledger)
              ORDER fromDateTime(ledger, type, stock), ledger
              WHERE active(ledger, type, stock) AND
                    fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
              BY sku(ledger, type, stock) COMPLEX;

    property##A caption (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
        GROUP LAST property(PriceListLedger ledger)
              ORDER fromDateTime(ledger, type, stock), ledger
              WHERE active(ledger, type, stock) AND
                    fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
              BY sku(ledger, type, stock) COMPLEX;
END

META defineLastLedgerPriceListTypeSkuStockAggr(property, caption)
    property##B caption (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
        GROUP LAST property(PriceListLedger ledger, type, stock)
              ORDER fromDateTime(ledger, type, stock), ledger
              WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
              BY sku(ledger, type, stock) COMPLEX;

    property##A caption (LedgerPriceListType type, sku, Stock stock, DATETIME dateTime) =
        GROUP LAST property(PriceListLedger ledger, type, stock)
              ORDER fromDateTime(ledger, type, stock), ledger
              WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
              BY sku(ledger, type, stock) COMPLEX;
END

@defineLastLedgerPriceListTypeSkuStockAggr(company, 'Организация');
nameCompanyB 'Организация' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) =
    name(companyB(type, sku, stock, dateTime));
nameCompanyA 'Организация' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) =
    name(companyA(type, sku, stock, dateTime));

companyB 'Организация' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST company(PriceListLedger ledger)
          ORDER fromDateTime(ledger), ledger
          WHERE active(ledger, type) AND price(ledger, type) AND
                fromDateTime(ledger) < dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;

companyA 'Организация' (LedgerPriceListType type, sku, DATETIME dateTime) =
    GROUP LAST company(PriceListLedger ledger)
          ORDER fromDateTime(ledger), ledger
          WHERE active(ledger, type) AND price(ledger, type) AND
                fromDateTime(ledger) <= dateTime AND NOT toDateTime(ledger) < dateTime
          BY sku(ledger) COMPLEX;

@defineLastLedgerPriceListTypeSkuStock(description, 'Описание');

@defineLastLedgerPriceListTypeSkuStock(fromDateTime, 'Дата/время с');

price (PriceListLedger ledger, LedgerPriceListType type, Stock stock, Batch batch) = 
    price(ledger, type, stock) IF in(ledger, batch); 

active(PriceListLedger ledger, LedgerPriceListType type, Stock stock, Batch batch) =
    active(ledger, type, stock) AND in(ledger, batch);
    

// По партиям

activePriceListLedgerB (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTimeIn) =
    GROUP
        LAST PriceListLedger ledger
        ORDER fromDateTime(ledger, type, stock), ledger
        WHERE active(ledger, type, stock, batch) AND price(ledger, type, stock, batch) AND
              fromDateTime(ledger, type, stock) < dateTimeIn AND NOT toDateTime(ledger, type, stock) < dateTimeIn;

activePriceListLedgerA  (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTimeIn) =
    GROUP
        LAST PriceListLedger ledger
        ORDER fromDateTime(ledger, type, stock), ledger
        WHERE active(ledger, type, stock, batch) AND price(ledger, type, stock, batch) AND
              fromDateTime(ledger, type, stock) <= dateTimeIn AND NOT toDateTime(ledger) < dateTimeIn;

priceBatchB 'Цена' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
    GROUP
        LAST price(PriceListLedger ledger, type, stock, batch)
        ORDER fromDateTime(ledger, type, stock), ledger
        WHERE active(ledger, type, stock, batch) AND
              fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime COMPLEX;

priceB 'Цена' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
    IF batch(type, stock) AND NOT skipBatch(type, stock, batch) THEN
        priceBatchB(type, batch, stock, dateTime)
    ELSE
        priceB(type, sku(batch), stock, dateTime) COMPLEX;

priceA 'Цена' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
    IF batch(type, stock) AND NOT skipBatch(type, stock, batch) THEN
        (GROUP
               LAST price(PriceListLedger ledger, type, stock, batch)
               ORDER fromDateTime(ledger, type, stock), ledger
               WHERE active(ledger, type, stock, batch) AND
                     fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime)
    ELSE
        priceA(type, sku(batch), stock, dateTime) COMPLEX;

prevPriceB 'Цена (пред.)' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) = PREV(priceB(type, batch, stock, dateTime)) CHARWIDTH 7 COMPLEX;
prevPriceA 'Цена (пред.)' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) = PREV(priceA(type, batch, stock, dateTime)) CHARWIDTH 7 COMPLEX;

prevPriceBatchB 'Цена (пред.)' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) = PREV(priceBatchB(type, batch, stock, dateTime)) CHARWIDTH 7 COMPLEX;

prevPriceB 'Цена (пред.)' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(priceB(type, sku, stock, dateTime)) CHARWIDTH 7 COMPLEX;
prevPriceA 'Цена (пред.)' (LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) = PREV(priceA(type, sku, stock, dateTime)) CHARWIDTH 7 COMPLEX;

//-- Только от партии
priceBBatch 'Цена' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTimeIn) =
    GROUP
        LAST price(PriceListLedger ledger, type, stock, batch)
        ORDER fromDateTime(ledger, type, stock), ledger
        WHERE active(ledger, type, stock, batch) AND
            fromDateTime(ledger, type, stock) < dateTimeIn AND NOT toDateTime(ledger, type, stock) < dateTimeIn COMPLEX;

priceABatch 'Цена' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTimeIn) =
    GROUP
        LAST price(PriceListLedger ledger, type, stock, batch)
        ORDER fromDateTime(ledger, type, stock), ledger
        WHERE active(ledger, type, stock, batch) AND
            fromDateTime(ledger, type, stock) <= dateTimeIn AND NOT toDateTime(ledger, type, stock) < dateTimeIn COMPLEX;

prevPriceBBatch 'Цена (пред.)' (type, batch, stock, dateTime) = PREV(priceBBatch(type, batch, stock, dateTime)) COMPLEX;
prevPriceABatch 'Цена (пред.)' (type, batch, stock, dateTime) = PREV(priceABatch(type, batch, stock, dateTime)) COMPLEX;

META defineLastLedgerPriceListTypeBatchStock(property, caption)
    property##B caption (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
        IF batch(type, stock) AND NOT skipBatch(type, stock, batch) THEN
            (GROUP
                   LAST property(PriceListLedger ledger) IF in(ledger, batch)
                   ORDER fromDateTime(ledger, type, stock), ledger
                   WHERE active(ledger, type, stock, batch) AND
                        fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime)
        ELSE
            property##B(type, sku(batch), stock, dateTime) COMPLEX;

    property##A caption (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
        IF batch(type, stock) AND NOT skipBatch(type, stock, batch) THEN
            (GROUP
                   LAST property(PriceListLedger ledger) IF in(ledger, batch)
                   ORDER fromDateTime(ledger, type, stock), ledger
                   WHERE active(ledger, type, stock, batch) AND
                        fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime)
        ELSE
            property##A(type, sku(batch), stock, dateTime) COMPLEX;
END

@defineLastLedgerPriceListTypeBatchStock(company, 'Организация');
nameCompanyB 'Компания прайса' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
    name(companyB(type, batch, stock, dateTime));
nameCompanyA 'Компания прайса' (LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) =
    name(companyA(type, batch, stock, dateTime));

@defineLastLedgerPriceListTypeBatchStock(description, 'Описание');

// ------------------ Расчет цен для sku / stock / company / datetime

//INDEX company(PriceListLedger ledger, LedgerPriceListType type, Stock stock), type, stock, fromDateTime(ledger, type, stock), ledger; 

priceB 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;
                
prevPriceB(LedgerPriceListType type, Sku sku, Stock stock, LegalEntity company, DATETIME dateTime) =
    PREV(priceB(type, sku, stock, company, dateTime)) COMPLEX; 

priceA 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

prevPriceA(LedgerPriceListType type, Sku sku, Stock stock, LegalEntity company, DATETIME dateTime) =
    PREV(priceA(type, sku, stock, company, dateTime)) COMPLEX; 

descriptionA 'Описание' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST description(PriceListLedger ledger)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

currentPrice 'Цена' (LedgerPriceListType type, sku, Stock stock, company) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

priceListLedgerB 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;
prevPriceListLedgerB (LedgerPriceListType type, Sku sku, Stock stock, LegalEntity company, DATETIME dateTime) =
    PREV(priceListLedgerB(type, sku, stock, company, dateTime)) COMPLEX;

priceListLedgerA 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;
prevPriceListLedgerA (LedgerPriceListType type, Sku sku, Stock stock, LegalEntity company, DATETIME dateTime) =
    PREV(priceListLedgerA(type, sku, stock, company, dateTime)) COMPLEX;
    
activeLedgerA 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND active(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;    
          
// Только с ценами                
activePriceB 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;

activePriceA 'Цена' (LedgerPriceListType type, sku, Stock stock, company, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE price(ledger, type, stock) AND
                fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;                
                

// ------------------ Расчет цен для sku / stock / company / stockCompany / datetime

priceB 'Цена' (LedgerPriceListType type, sku, Stock stock, companyStock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), companyStock(ledger) COMPLEX;
prevPriceB (LedgerPriceListType type, Sku sku, Stock stock, Stock companyStock, DATETIME dateTime) =
    PREV(priceB(type, sku, stock, companyStock, dateTime)) COMPLEX;
    
priceA 'Цена' (LedgerPriceListType type, sku, Stock stock, companyStock, DATETIME dateTime) =
    GROUP LAST price(PriceListLedger ledger, type, stock)
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), companyStock(ledger) COMPLEX;
prevPriceA (LedgerPriceListType type, Sku sku, Stock stock, Stock companyStock, DATETIME dateTime) =
    PREV(priceA(type, sku, stock, companyStock, dateTime)) COMPLEX;
                
priceListLedgerB 'Цена' (LedgerPriceListType type, sku, Stock stock, companyStock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) < dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), companyStock(ledger) COMPLEX;
prevPriceListLedgerB (LedgerPriceListType type, Sku sku, Stock stock, Stock companyStock, DATETIME dateTime) =
    PREV(priceListLedgerB(type, sku, stock, companyStock, dateTime)) COMPLEX; 

priceListLedgerA 'Цена' (LedgerPriceListType type, sku, Stock stock, companyStock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime
          BY sku(ledger, type, stock), companyStock(ledger) COMPLEX;
prevPriceListLedgerA (LedgerPriceListType type, Sku sku, Stock stock, Stock companyStock, DATETIME dateTime) =
    PREV(priceListLedgerA(type, sku, stock, companyStock, dateTime)) COMPLEX;

priceListLedgerA 'Цена' (LedgerPriceListType type, sku, Stock stock, LegalEntity company, Stock companyStock, DATETIME dateTime) =
    GROUP LAST PriceListLedger ledger
          ORDER fromDateTime(ledger, type, stock), ledger
          WHERE fromDateTime(ledger, type, stock) <= dateTime AND NOT toDateTime(ledger, type, stock) < dateTime AND companyStock(ledger) = companyStock
          BY sku(ledger, type, stock), company(ledger, type, stock) COMPLEX;
prevPriceListLedgerA (LedgerPriceListType type, Sku sku, Stock stock, LegalEntity company, Stock companyStock, DATETIME dateTime) =
    PREV(priceListLedgerA(type, sku, stock, company, companyStock, dateTime)) COMPLEX;


countStockB 'Кол-во складов' (LedgerPriceListType type, Sku sku, LegalEntity company, DATETIME dateTime) =
    GROUP
    SUM 1 IF priceB(type, sku, Stock stock, company, dateTime);

countStockA 'Кол-во складов' (LedgerPriceListType type, Sku sku, LegalEntity company, DATETIME dateTime) =
    GROUP
    SUM 1 IF priceA(type, sku, Stock stock, company, dateTime);

// ------- НДС --- //

includeVAT 'Цена с НДС' = ABSTRACT BOOLEAN (LedgerPriceListType);
includeVAT(LedgerPriceListType type) += includeVAT(type);

// ------------------ Связь с базовым видом цен ------------- //

priceB(LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) += priceB(type, sku, stock, dateTime);
priceA(LedgerPriceListType type, Sku sku, Stock stock, DATETIME dateTime) += priceA(type, sku, stock, dateTime);

priceB(LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) += priceB(type, batch, stock, dateTime);
priceA(LedgerPriceListType type, Batch batch, Stock stock, DATETIME dateTime) += priceA(type, batch, stock, dateTime);

// ------ оптимизация для ассортиментов
ledgerPriceListType = ABSTRACT LedgerPriceListType (PriceListType) MATERIALIZED;
in = ABSTRACT BOOLEAN (PriceListType, LedgerPriceListType);

ledgerPriceListType(LedgerPriceListType type) += type AS LedgerPriceListType;

overIn (PriceListType t, LedgerPriceListType lt) = ledgerPriceListType(t) == lt OR in(t, lt);

// ---------------------- Системный вид цены 

CLASS SystemLedgerPriceListType 'Системный вид цены (регистр)' : LedgerPriceListType;

showCopy(PriceListType p) += p IS PriceListType AND NOT (p IS SystemLedgerPriceListType);

name (SystemLedgerPriceListType type) += ISTRING[100](staticCaption(type)) IF type IS SystemLedgerPriceListType;

includeVAT 'Цена с НДС' = ABSTRACT CASE EXCLUSIVE BOOLEAN (SystemLedgerPriceListType);
includeVAT (SystemLedgerPriceListType type) += includeVAT(type);

in = ABSTRACT CASE EXCLUSIVE BOOLEAN (PriceListLedger, SystemLedgerPriceListType);
price = ABSTRACT CASE EXCLUSIVE NUMERIC[16,4] (PriceListLedger, SystemLedgerPriceListType);
in(PriceListLedger ledger, SystemLedgerPriceListType type) += in(ledger, type);
price(PriceListLedger ledger, SystemLedgerPriceListType type) += price(ledger, type);

// ----------------------------- Метакоды ------------------------ //

// Implement
META implementSystemLedgerPriceListType (type, objectClass, companyProp, stockProp, prefix)
    EXTEND CLASS objectClass : PriceListLedger;

    fromDateTime (objectClass ledger) += dateTime(ledger);

    isPosted[PriceListLedger](objectClass ledger) += isPosted(ledger);

    sku[PriceListLedger] (objectClass ledger) += sku(ledger);

    description[PriceListLedger] (objectClass ledger) += description(ledger);

    company (objectClass ledger) += companyProp(ledger);

    in (objectClass ledger, SystemLedgerPriceListType type) += WHEN price(ledger) AND type == SystemLedgerPriceListType.##type##PriceListType THEN TRUE;
    price (objectClass ledger, SystemLedgerPriceListType type) += WHEN price(ledger) AND type == SystemLedgerPriceListType.##type##PriceListType THEN price(ledger);

    in (objectClass ledger, ###stockProp stock) += stockProp(ledger) == stock;
    
    show[PriceListLedger] (objectClass ledger) + { show(ledger);};
END

META implementSystemLedgerPriceListType (type, objectClass, companyProp, stockProp)
    @implementSystemLedgerPriceListType(type, objectClass, companyProp, stockProp, );
END

META implementSystemLedgerPriceListTypeBatch (type, objectClass, companyProp, stockProp)
    @implementSystemLedgerPriceListType(type, objectClass, companyProp, stockProp);
    in(objectClass ledger, objectClass batch) += (ledger AS objectClass) == batch;
END

// Derive
META deriveDocumentDetailPriceSystemLedgerPriceListType (concrete, priceListTypeProp, prefixP, skuProp, stockProp)
    prefixP##Price (###concrete##Detail detail)  <- prevPriceB[PriceListType,###skuProp,Stock,DATETIME](SystemLedgerPriceListType.##priceListTypeProp,
                                                                                            skuProp(detail),
                                                                                            stockProp(detail),
                                                                                            dateTime(detail))
                                                    WHEN DO CHANGED(skuProp(detail)) OR
                                                         CHANGED(stockProp(detail)) OR
                                                         CHANGED(dateTime(detail));
END

skipUpdatePriceAccount = DATA LOCAL BOOLEAN ();
replaceBefore(Sku i, Sku item) + {skipUpdatePriceAccount() <- i!=item;}

META deriveDocumentDetailPriceAccountBatch (concrete, prefixP, skuProp, stockProp)
    WHEN LOCAL (CHANGED(stockProp(###concrete##Detail detail)) OR
                (CHANGED(dateTime(detail)) AND NOT isPosted(detail)) OR
                SETCHANGED(batch(detail))) AND batch(detail) AND NOT CHANGED(prefixP###price(detail)) AND NOT skipUpdatePriceAccount() DO
        prefixP###price (detail) <- prevAccountPriceB(batch(detail), stockProp(detail), dateTime(detail));

    WHEN LOCAL (CHANGED(skuProp(###concrete##Detail detail)) OR
                CHANGED(stockProp(detail)) OR
                (CHANGED(dateTime(detail)) AND NOT isPosted(detail)) OR
                DROPPED(batch(detail))) AND NOT batch(detail) AND NOT CHANGED(prefixP###price(detail)) AND NOT skipUpdatePriceAccount() DO
        prefixP###price (detail) <- prevAccountPriceB(sku(detail), stockProp(detail), dateTime(detail));
END

META deriveDocumentDetailPriceAccountBatch (concrete, skuProp, stockProp)
    @deriveDocumentDetailPriceAccountBatch (concrete, , skuProp, stockProp);
END
META deriveDocumentDetailPriceAccountBatchDisable (concrete, prefixP, skuProp, stockProp)
    disableUpdate###prefixP###price = ABSTRACT VALUE BOOLEAN (###concrete##Detail);

    WHEN LOCAL (CHANGED(stockProp(###concrete##Detail detail)) OR
                (CHANGED(dateTime(detail)) AND NOT isPosted(detail)) OR
                SETCHANGED(batch(detail))) AND batch(detail) AND NOT CHANGED(prefixP###price(detail)) AND NOT disableUpdate###prefixP###price(detail) AND NOT skipUpdatePriceAccount() DO
        prefixP###price (detail) <- prevAccountPriceB(batch(detail), stockProp(detail), dateTime(detail));

    WHEN LOCAL (CHANGED(skuProp(###concrete##Detail detail)) OR
                CHANGED(stockProp(detail)) OR
                (CHANGED(dateTime(detail)) AND NOT isPosted(detail)) OR
                DROPPED(batch(detail))) AND NOT batch(detail) AND NOT CHANGED(prefixP###price(detail)) AND NOT disableUpdate###prefixP###price(detail) AND NOT skipUpdatePriceAccount() DO
        prefixP###price (detail) <- prevAccountPriceB(sku(detail), stockProp(detail), dateTime(detail));
END

META deriveDocumentDetailPriceAccountBatchDisable (concrete, skuProp, stockProp)
    @deriveDocumentDetailPriceAccountBatchDisable (concrete, , skuProp, stockProp);
END


META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (concrete, priceListTypeProp, prefixP, prefixB, skuProp, stockProp)
    prefixP###price (###concrete##Detail detail)  <- IF batch(detail)

                                                    THEN prevPriceB[PriceListType,Batch,Stock,DATETIME](SystemLedgerPriceListType.##priceListTypeProp,
                                                                                                   batch(detail),
                                                                                                   stockProp(detail),
                                                                                                   dateTime(detail))
                                                    ELSE prevPriceB[PriceListType,###skuProp,Stock,DATETIME](SystemLedgerPriceListType.##priceListTypeProp,
                                                                                                 skuProp(detail),
                                                                                                 stockProp(detail),
                                                                                                 dateTime(detail))
                                                    WHEN DO CHANGED(skuProp(detail)) OR
                                                         CHANGED(stockProp(detail)) OR
                                                         (CHANGED(dateTime(detail)) AND NOT isPosted(detail)) OR
                                                         CHANGED(batch(detail));
END

META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (concrete, priceListTypeProp, prefixP, skuProp, stockProp)
    @deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (concrete, priceListTypeProp, prefixP, , skuProp, stockProp);
END

META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (concrete, priceListTypeProp, skuProp, stockProp)
    @deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (concrete, priceListTypeProp, , , skuProp, stockProp);
END

META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatchExtra (concrete, priceListTypeProp, prefixP, prefixB, skuProp, stockProp)
    prevList###skuProp###prefixP##Price = ABSTRACT VALUE NUMERIC[16,4] (###concrete##Detail);
    prevListBatch###prefixP##Price = ABSTRACT VALUE NUMERIC[16,4] (###concrete##Detail);
    
    prevListBatch###prefixP##Price(###concrete##Detail detail) += prevPriceB[PriceListType,Batch,Stock,DATETIME](SystemLedgerPriceListType.##priceListTypeProp,
                                                                                                           batch(detail),
                                                                                                           stockProp(detail),
                                                                                                           dateTime(detail));
    prevList###skuProp###prefixP##Price(###concrete##Detail detail) += prevPriceB[PriceListType,###skuProp,Stock,DATETIME](SystemLedgerPriceListType.##priceListTypeProp,
                                                                                                 skuProp(detail),
                                                                                                 stockProp(detail),
                                                                                                 dateTime(detail));
                                                                                                     
    prefixP##Price (###concrete##Detail detail)  <- round2(IF batch(detail)    
                                                    THEN prevListBatch###prefixP##Price(detail)
                                                    ELSE prevList###skuProp###prefixP##Price(detail))
        WHEN DO CHANGED(skuProp(detail)) OR
             CHANGED(stockProp(detail)) OR
             CHANGED(dateTime(detail)) OR
             CHANGED(batch(detail));
END
META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatchExtra (concrete, priceListTypeProp, prefixP, skuProp, stockProp)
    @deriveDocumentDetailPriceSystemLedgerPriceListTypeBatchExtra (concrete, priceListTypeProp, prefixP, , skuProp, stockProp);
END
META deriveDocumentDetailPriceSystemLedgerPriceListTypeBatchExtra (concrete, priceListTypeProp, skuProp, stockProp)
    @deriveDocumentDetailPriceSystemLedgerPriceListTypeBatchExtra (concrete, priceListTypeProp, , , skuProp, stockProp);
END

dialogPriceListType = DATA LOCAL LedgerPriceListType (Sku, Stock);
nameDialogPriceListType 'Вид цены' = name[PriceListType](dialogPriceListType(Sku sku, Stock stock));

relation(Sku s,Stock st,LedgerPriceListType t) = GROUP SUM 1 IF sku(PriceListLedger pl) == s AND isPosted(pl) AND active(pl, t)
    AND in(pl,st) AND price(pl,t);
//CONSTRAINT dialogPriceListType(Sku s,Stock st) AND NOT relation(s,st,dialogPriceListType(s,st))
//    CHECKED BY dialogPriceListType[Sku,Stock] MESSAGE 'Выбран вид цены, по которому нет истории изменения по данному товару';

skipShowEdit = ABSTRACT VALUE BOOLEAN (PriceListLedger);
showEdit(PriceListLedger p) = p IS PriceListLedger AND NOT skipShowEdit(p) ;

showToShow(PriceListLedger p) = p IS PriceListLedger AND NOT showEdit(p); 

background(Sku s, Stock st, LedgerPriceListType t, PriceListLedger pl) = IF prevPriceListLedgerA(t, s, st, currentDateTime()) == pl THEN #FFFFBC;

FORM movementPriceSkuStock 'Изменение цены товара по складу'
    OBJECTS s = Sku PANEL
    PROPERTIES(s) READONLY name

    OBJECTS st = Stock PANEL
    PROPERTIES(st) SELECTOR name
    PROPERTIES(s,st) nameDialogPriceListType

    OBJECTS pp = (t = LedgerPriceListType, pl = PriceListLedger)
    PROPERTIES READONLY name[PriceListType](t) BACKGROUND background(s, st, t,pl),
                        description(pl) BACKGROUND background(s, st, t,pl),
                        fromDateTime(pl, t, st) BACKGROUND background(s, st, t,pl),
                        toDateTime(pl, t, st) BACKGROUND background(s, st, t,pl),
                        price(pl, t, st) BACKGROUND background(s, st, t,pl)
 
    PROPERTIES(pl) NEWSESSION EDIT SHOWIF showEdit(pl)
    PROPERTIES(pl)            show SHOWIF showToShow(pl)
    ORDERS name(t), fromDateTime(pl, t, st) DESC

    FILTERS sku(pl, t, st) == s,
            (t IS PriceListType AND NOT dialogPriceListType(s,st)) OR dialogPriceListType(s,st) == t

;
DESIGN movementPriceSkuStock {
    BOX {
        size = (1024, 768);
        NEW topContainer{
            alignment = STRETCH;
            type = CONTAINERH;
            MOVE BOX(s) { fill = 1; MOVE PROPERTY (name(s)) { fill = 1; } }
            MOVE BOX(st) { fill = 1; MOVE PROPERTY (name(st)) { fill = 1; } }
        }
        NEW dialog {
            caption = 'Вид цен';
            MOVE PROPERTY(nameDialogPriceListType(s,st));
        }
        MOVE BOX(pp);
        PROPERTY(name(s)) { focusable = FALSE;}
        PROPERTY(name(t)) { caption = 'Вид цен';}
    }
    MOVE TOOLBARBOX;
}

// --
dialogSupplier = DATA LOCAL LegalEntity (Sku, Stock);
nameDialogSupplier 'Поставщик' = name(dialogSupplier(Sku sku, Stock stock));

relationCompany(Sku s,Stock st,c) = GROUP SUM 1 IF sku(PriceListLedger pl) == s AND isPosted(pl) AND active(pl)
    AND in(pl,st) BY company(pl);

CONSTRAINT dialogSupplier(Sku s,Stock st) AND NOT isSupplier(dialogSupplier(s,st))
    CHECKED BY dialogSupplier[Sku,Stock] MESSAGE 'Выбран организация, которая не является поставщиком';
CONSTRAINT dialogSupplier(Sku s,Stock st) AND NOT relationCompany(s,st,dialogSupplier(s,st))
    CHECKED BY dialogSupplier[Sku,Stock] MESSAGE 'Выбран организация, по которой нет истории изменения по данному товару';

FORM movementPriceSkuStockSupplier 'Изменение цены товара по складу и поставщику'
    OBJECTS s = Sku PANEL
    PROPERTIES(s) READONLY name

    OBJECTS st = Stock PANEL
    PROPERTIES(st) SELECTOR name
    PROPERTIES(s,st) nameDialogPriceListType, nameDialogSupplier

    OBJECTS pp = (t = LedgerPriceListType, pl = PriceListLedger)
    PROPERTIES READONLY  name[PriceListType](t),  description(pl), nameCompany(pl), fromDateTime(pl, t, st), toDateTime(pl, t, st),
                        price(pl, t, st) 
    PROPERTIES(pl) NEWSESSION EDIT                     
    ORDERS name(t), fromDateTime(pl, t, st) DESC

    FILTERS sku(pl, t, st) == s,
            (t IS PriceListType AND NOT dialogPriceListType(s,st)) OR dialogPriceListType(s,st) == t,
            (pl IS PriceListLedger AND NOT dialogSupplier(s,st)) OR dialogSupplier(s,st) == company(pl)

;
DESIGN movementPriceSkuStockSupplier {
    BOX {
        size = (1024, 768);
        NEW topContainer{
            type = CONTAINERH;
            NEW left {
                type = CONTAINERV;
                MOVE BOX(s);
                NEW dialog1 {
                    caption = 'Вид цен';
                    MOVE PROPERTY(nameDialogPriceListType(s,st));
                }
            }
            NEW reight {
                type = CONTAINERV;
                MOVE BOX(st);
                NEW dialog2 {
                    caption = 'Поставщик';
                    MOVE PROPERTY(nameDialogSupplier(s,st));
                }
            }
            
        }

        MOVE BOX(pp);
        PROPERTY(name(s)) { focusable = FALSE;}
        PROPERTY(name(t)) { caption = 'Вид цен';}
    }
    MOVE TOOLBARBOX;
}

//--
dialogPriceListType = DATA LOCAL LedgerPriceListType (Sku);
nameDialogPriceListType 'Вид цены' = name[PriceListType](dialogPriceListType(Sku sku));

FORM movementPriceSkuStocks 'Изменение цены товара'
    OBJECTS s = Sku PANEL
    PROPERTIES(s) READONLY name, nameDialogPriceListType CHANGEABLE 

    OBJECTS pp = (t = LedgerPriceListType, pl = PriceListLedger, st = Stock)
    PROPERTIES READONLY  name(t), name(st), description(pl),  fromDateTime(pl, t, st), toDateTime(pl, t, st),
                        price(pl, t, st) 
    PROPERTIES(pl) NEWSESSION EDIT SHOWIF showEdit(pl)
    PROPERTIES(pl)            show SHOWIF showToShow(pl)
    ORDERS name(st), name(t), fromDateTime(pl, t, st) DESC

    FILTERS sku(pl, t, st) == s,
            (t IS PriceListType AND NOT dialogPriceListType(s)) OR dialogPriceListType(s) == t
;
DESIGN movementPriceSkuStocks {
    BOX {
        size = (1024, 768);
        MOVE BOX(s) { MOVE PROPERTY (name(s)) { fill = 1; } }          
        NEW filter {
            type = CONTAINERH;
            caption = 'Фильтры';
            MOVE PROPERTY (nameDialogPriceListType(s)){caption = 'Вид цены'; focusable = FALSE;}
        }
        MOVE BOX(pp);
        PROPERTY(name(s)) { focusable = FALSE;}
        PROPERTY(nameDialogPriceListType(s)) { }
        PROPERTY(name(st)) { caption = 'Склад';}
        PROPERTY(name(t)) { caption = 'Вид цен';}
    }
    MOVE TOOLBARBOX;
}

META defineMovementPriceSku(detail, stockProp, skuProp, nameSkuProp)
    showMovementPrice###skuProp##Stock 'Показать изменение цены товара по складу' (###detail detail)  { 
        FOR s == skuProp(detail) AND st == stockProp(detail) DO
            NEWSESSION SHOW movementPriceSkuStock OBJECTS s = s, st = st; } 
    ASON CONTEXTMENU nameSkuProp[###detail];
    
    showMovementPrice###skuProp##Stocks 'Показать изменение цены товара' (###detail detail)  { 
        FOR s == skuProp(detail) DO 
            NEWSESSION SHOW movementPriceSkuStocks OBJECTS s = s; } 
    ASON CONTEXTMENU nameSkuProp[###detail];
END
META defineMovementPriceSku(detail, skuProp, nameSkuProp)
    showMovementPrice###skuProp##Stock 'Показать изменение цены товара по складу' (###detail detail)  { 
        FOR s == skuProp(detail) DO
            NEWSESSION SHOW movementPriceSkuStock OBJECTS s = s; } 
    ASON CONTEXTMENU nameSkuProp[###detail];
    
    showMovementPrice###skuProp##Stocks 'Показать изменение цены товара' (###detail detail)  { 
        FOR s == skuProp(detail) DO
            NEWSESSION SHOW movementPriceSkuStocks OBJECTS s = s; } 
    ASON CONTEXTMENU nameSkuProp[###detail];
END

META defineMovementPriceSku(detail, stockProp)
    @defineMovementPriceSku(detail, stockProp, sku, nameSku);
END
META defineMovementPriceSku(detail)
    @defineMovementPriceSku(detail, sku, nameSku);
END

showMovementPriceSku 'Показать изменение цены товара по складу' (Sku sku, Stock stock)  { NEWSESSION SHOW movementPriceSkuStock OBJECTS s = sku, st = stock ; }
showBalancePriceSku(Sku sku, Stock stock) + {  showMovementPriceSku(sku, stock); } 
showMovementPriceSkuStocks 'Показать изменение цены товара по складу' (Sku sku)  { NEWSESSION SHOW movementPriceSkuStock OBJECTS s = sku ; }
showMovementPriceStocks 'Показать изменение цены товара' (Sku sku)  { NEWSESSION SHOW movementPriceSkuStocks OBJECTS s = sku; }  ASON CONTEXTMENU name[Sku];

showMovementPriceSku 'Показать изменение цены товара по складу' (Batch batch, Stock stock)  { 
    FOR s == sku(batch) DO
        NEWSESSION SHOW movementPriceSkuStock OBJECTS s = s, st = stock ; }

showMovementPriceSkuStocks 'Показать изменение цены товара по складу' (Batch batch)  { 
    FOR s == sku(batch) DO 
        NEWSESSION SHOW movementPriceSkuStock OBJECTS s = s; } 
ASON CONTEXTMENU nameSku[Batch];

showMovementPriceStocks 'Показать изменение цены товара' (Batch batch)  { 
    FOR s == sku(batch) DO
        NEWSESSION SHOW movementPriceSkuStocks OBJECTS s = s; } 
ASON CONTEXTMENU nameSku[Batch];

showMovementPriceSkuStock 'Показать изменение цены товара по складу возникновения партии' (Batch batch)  { 
    FOR s == sku(batch) AND st == stock(batch) DO
        NEWSESSION SHOW movementPriceSkuStock OBJECTS s = s, st = st; } 
ASON CONTEXTMENU nameSku[Batch];

@extendFormFilterStockAccess(st, movementPriceSkuStock);
@extendFormFilterStockAccess(st, movementPriceSkuStocks);
@extendFormFilterStockAccess(st, movementPriceSkuStockSupplier);

filterReportStock  = DATA LOCAL Stock ();
nameFilterReportStock 'Склад' = name(filterReportStock()) CHARWIDTH 15;          
  
CONSTRAINT  filterReportStock() AND NOT isCompany(filterReportStock())
    CHECKED BY filterReportStock[] MESSAGE 'Выбран склад, который не является складом компании';
  
filterReportLedgerPriceListType  = DATA LOCAL LedgerPriceListType ();
nameFilterReportLedgerPriceListType 'Вид цены' = name[PriceListType](filterReportLedgerPriceListType()) CHARWIDTH 15; 

filterReportSku = DATA LOCAL Sku ();
nameFilterReportSku 'SKU' = name(filterReportSku()) CHARWIDTH 15; 

FORM priceTypeLedgerSkuStock 'Регистр цен'

    OBJECTS dates = (dFrom = DATE , dTo = DATE) PANEL
    PROPERTIES valFrom = VALUE(dFrom), valTo = VALUE(dTo), nameFilterReportStock(), nameFilterReportLedgerPriceListType(),
               nameFilterReportSku()       

    OBJECTS pp = (t = LedgerPriceListType, pl = PriceListLedger, st = Stock)
    PROPERTIES READONLY name[PriceListType](t),  name(st), nameSku(pl), description(pl), fromDateTime(pl, t, st), toDateTime(pl, t, st),
                        price(pl, t, st) 
    PROPERTIES(pl) NEWSESSION EDIT                     
//    ORDERS fromDateTimePriceListLedger(pl)

    FILTERS fromDateTime(pl, t, st) >= DATETIME(dFrom),
            fromDateTime(pl, t, st) < DATETIME(sum(dTo, 1)),                       
            filterReportStock() == st OR (st IS Stock AND NOT filterReportStock()),
            filterReportLedgerPriceListType() == t OR (t IS PriceListType AND NOT filterReportLedgerPriceListType()),
            filterReportSku() == sku(pl, t, st) OR (pl IS PriceListLedger AND NOT filterReportSku())
;
DESIGN priceTypeLedgerSkuStock {
    BOX {
        MOVE BOX(dates) {        
            caption = 'Период';
            type = CONTAINERH;
        }
        NEW filter {
            caption = 'Фильтры';
            type = CONTAINERH;
            MOVE PROPERTY(nameFilterReportStock());
            MOVE PROPERTY(nameFilterReportLedgerPriceListType());
            MOVE PROPERTY(nameFilterReportSku());
        }
        MOVE BOX(pp);
    }
    MOVE TOOLBARBOX;
}

NAVIGATOR {
    priceListReport  {
        NEW priceTypeLedgerSkuStock;
    }       
}
