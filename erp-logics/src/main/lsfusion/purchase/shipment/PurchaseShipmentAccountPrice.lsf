MODULE PurchaseShipmentAccountPrice;

REQUIRE PurchaseShipmentAccountLedger, SkuLedgerCost, SalePurchaseShipment;

NAMESPACE Purchase;

accountPrice 'Учетная цена (после)' = DATA NUMERIC[16,4] (ShipmentDetail);
accountLedgerPrice (ShipmentDetail d) += accountPrice(d);

//@defineCalcAveragePrice(ShipmentDetail, customerStock){
//    calcAccountPrice (ShipmentDetail d) =
//        NUMERIC[16,4]((balanceB(sku(d), customerStock(d), dateTime(d))*accountPriceB(sku(d), customerStock(d), dateTime(d)) +
//            quantity(d) * price(d))/(quantity(d) + balanceB(sku(d), customerStock(d), dateTime(d))));
//
//    // пока без PREV, так как нужно хитро пересчитывать при изменении той же даты
//    WHEN (SETCHANGED(sku(ShipmentDetail d)) OR SETCHANGED(customerStock(d)) OR SETCHANGED(dateTime(d)) OR 
//        SETCHANGED(quantity(d)) OR SETCHANGED(price(d))) AND NOT disableCalcAccountPrice() DO
//        accountPrice(d) <- calcAccountPrice(d);
//};

positiveBalanceB(Sku sk, Stock st, DATETIME dt) = OVERRIDE (balanceB(sk, st, dt) IF balanceB(sk, st, dt)>0.0), 0.0;
positiveBalanceB 'Остаток (до)' (ShipmentDetail d) = positiveBalanceB(sku(d), customerStock(d), dateTime(d));

useOnlyBalanceB 'Учитывать только положит.остатки при расчете учетной цены' = DATA BOOLEAN ();

EXTEND FORM options 
    PROPERTIES () useOnlyBalanceB
;

DESIGN options {
    stock {
        MOVE PROPERTY(useOnlyBalanceB());
    }
}

calcAccountPriceBalance (Sku sk, Stock st, DATETIME dt) = IF useOnlyBalanceB()
    THEN positiveBalanceB(sk, st, dt)
    ELSE balanceB(sk, st, dt);

calcAccountPriceBalance (ShipmentDetail d) = calcAccountPriceBalance(sku(d), customerStock(d), dateTime(d));

calcAccountPrice (ShipmentDetail d) =
    NUMERIC[16,4]((calcAccountPriceBalance(sku(d), customerStock(d), dateTime(d))*accountPriceB(sku(d), customerStock(d), dateTime(d)) +
        quantity(d) * price(d))/(quantity(d) + calcAccountPriceBalance(sku(d), customerStock(d), dateTime(d))));

// пока без PREV, так как нужно хитро пересчитывать при изменении той же даты
WHEN (SETCHANGED(sku(ShipmentDetail d)) OR SETCHANGED(customerStock(d)) OR SETCHANGED(dateTime(d)) OR
    SETCHANGED(quantity(d)) OR SETCHANGED(price(d))) AND NOT disableCalcAccountPrice() DO
    accountPrice(d) <- calcAccountPrice(d);

EXTEND FORM currentBalanceSkuStock
    OBJECTS sd = ShipmentDetail
    PROPERTIES (sd) READONLY dateTime, number, quantity, price, accountPrice, balanceB
    ORDERS dateTime(sd) DESC
    FILTERS sku(sd) = s, customerStock(sd) = st
;

DESIGN currentBalanceSkuStock {
    ledgerBox {
        MOVE BOX(sd) {
            caption = 'Поставки (закупка)';
        }
    }
}

// считаем кол-во за один момент, чтобы исключить проблемы с одним товаром разными строками за одно время
// в оперативном расчете пока это не учитываем в целях производительности
quantityShipmentDetail (Sku sk, DATETIME dt, Stock st) = GROUP SUM quantity(ShipmentDetail d) BY sku(d), dateTime(d), customerStock(d);

calcIntraAccountPrice (ShipmentDetail d) =
    NUMERIC[16,4]((calcAccountPriceBalance(d)*accountPriceB(d) +
           (OVERRIDE quantityShipmentDetail(sku(d), dateTime(d), customerStock(d)), 0.0) * (IF shipmentDetail(d) THEN accountPriceB(sku(d), supplierStock(d), dateTime(d)) ELSE price(d)))
        / ((OVERRIDE quantityShipmentDetail(sku(d), dateTime(d), customerStock(d)), 0.0) + calcAccountPriceBalance(d)));

recalculateCostLedger (DATE dFrom, DATE dTo) + {
    LOCAL ordered = INTEGER (ShipmentDetail);
    ordered (ShipmentDetail d) <- PARTITION SUM 1 IF date(d) >= dFrom AND date(d) <= dTo AND calcRecalculateCost(sku(d)) ORDER dateTime(d), d BY sku(d), dFrom, dTo;

    FOR iterate(INTEGER i, 1, (GROUP MAX ordered(ShipmentDetail d))) DO 
        NEWSESSION NESTED (ordered) {
            APPLY NESTED LOCAL {
                LOCAL it = BOOLEAN (ShipmentDetail);
                it(ShipmentDetail d) <- ordered(d) == i; // чтобы определились классы

                accountPrice(ShipmentDetail d) <- calcIntraAccountPrice(d)
                    WHERE it(d) AND NOT date(d) < documentsClosedDate(customerStock(d));
            }
        }
}
