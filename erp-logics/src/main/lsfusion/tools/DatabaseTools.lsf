MODULE DatabaseTools;

REQUIRE Tools, Reflection, SQLUtils, LogTools;

NAMESPACE Tools;

@defineLogRotate(databaseTools, 5, weekly, 'database-tools');

CLASS ABSTRACT DatabaseTable 'Tаблица';
EXTEND CLASS Table: DatabaseTable;

CLASS PgTable 'Системная таблица' : DatabaseTable;
TABLE pgTable(PgTable);
sid '{reflection.sid.table}' = DATA ISTRING[100] (PgTable);
sid '{reflection.sid.table}' (DatabaseTable t) = MULTI sid[Table](t), sid[PgTable](t);
table '{reflection.table}' = GROUP MAX DatabaseTable table BY sid (table);

dataSize 'Размер данных (МБ)' = DATA NUMERIC[15,3](Table);
dataSize 'Размер данных (МБ)' = DATA NUMERIC[15,3](PgTable);
dataSize 'Размер данных (МБ)' (DatabaseTable t) = MULTI dataSize[Table](t), dataSize[PgTable](t);

indexSize 'Размер индексов (МБ)' = DATA NUMERIC[15,3](Table);
indexSize 'Размер индексов (МБ)' = DATA NUMERIC[15,3](PgTable);
indexSize 'Размер индексов (МБ)' (DatabaseTable t) = MULTI indexSize[Table](t), indexSize[PgTable](t);

curDataSize 'Тек. размер данных (МБ)' = DATA LOCAL NESTED NUMERIC[15,3](DatabaseTable);
curIndexSize 'Тек. размер индексов (МБ)' = DATA LOCAL NESTED NUMERIC[15,3](DatabaseTable);
curRows 'Тек. количество записей' = DATA LOCAL NESTED LONG (Table);

deleteIndexes 'Удалять индексы при упаковке' = DATA BOOLEAN (Table);
large 'Большая таблица' = DATA BOOLEAN (Table);

CLASS Index 'Индекс';

table 'Таблица' = DATA Table (Index) NONULL DELETE INDEXED;
sidTable 'Таблица' (Index i) = sid(table(i)) CHARWIDTH 10;

name 'Наименование' = DATA STRING (Index);
index = GROUP AGGR Index x BY name(x);

tablespace 'Tablespace' = DATA STRING (Index);
definition 'Скрипт' = DATA STRING (Index);
isConstraint 'Constraint' = DATA BOOLEAN (Index);
indexSize 'Размер' = DATA LONG (Index);
indexScans 'Сканирований' = DATA LONG (Index);
indexReads 'Считано' = DATA LONG (Index);

relid 'OID индекса' = DATA LONG (Index);
indisvalid 'Активный' = DATA BOOLEAN (Index);

efficiency 'Эффективность' (Index i) = 100.0 * indexReads(i) / indexScans(i) / curRows(table(i));

stopAfter 'Не запускать после' = DATA TIME();

//utils
isStopTime() = currentTime() > stopAfter() AND currentTime() < 20:00;

coeff(Table t) = NUMERIC(rows(t)) / curRows(t);

maxInt() = 2147483647;
safeInt(NUMERIC n) = INTEGER(max(min(n, maxInt()), 0));

changedCoeff(NUMERIC cur, NUMERIC new) = max(cur, new) / NUMERIC(IF min(cur, new) == 0 THEN 0.0001 ELSE min(cur, new));
grow = [NUMERIC[12,3](OVERRIDE (((OVERRIDE A, 0.001) - (OVERRIDE B, 0.001)) / (MAX B, 0.001)), 0.0)](a, b);

////

//Секционированная таблица
//CLASS Partition 'Секция' : DatabaseTable;
//TABLE partition(Partition);

getIndexes 'Получить список индексов'(Table t) {
    NEWSESSION {
        LOCAL is = BOOLEAN (Index);

        INTERNAL DB 'SELECT indexname, tablespace, indexdef, pg_get_constraintdef(c.oid), pg_relation_size(psai.indexrelid), psai.idx_scan, psai.idx_tup_read, ind.indexrelid, ind.indisvalid from pg_indexes i left join pg_constraint c ON i.indexname = c.conname left join pg_stat_all_indexes psai on i.indexname = psai.indexrelname left join pg_index ind on ind.indexrelid = psai.indexrelid WHERE tablename = $1'
            PARAMS lower(sid(t))
            TO file;

        IMPORT TABLE FROM file() FIELDS STRING indexName, STRING tablespace NULL, STRING definition, STRING constraint, LONG indexSize, LONG indexScans, LONG indexReads, LONG relid, BOOLEAN indisvalid NULL DO {
            IF NOT index(indexName) THEN NEW i = Index {
                name(i) <- indexName;
            }
            FOR name(Index i) == indexName DO {
                table(i) <- t;
                tablespace(i) <- tablespace;
                definition(i) <- definition;
                isConstraint(i) <- TRUE IF constraint != '';
                indexSize(i) <- indexSize;
                indexScans(i) <- indexScans;
                indexReads(i) <- indexReads;
                relid(i) <- relid;
                indisvalid(i) <- indisvalid;
                is(i) <- TRUE;
            }
        }

        DELETE Index i WHERE table(i) == t AND NOT is(i);

        APPLY;

    }
}

invalidate 'Отключить' (Index i) {
    IF relid(i) > 0 THEN {
        INTERNAL DB 'UPDATE pg_index SET indisvalid = false WHERE indexrelid = $1'
            PARAMS relid(i);
        getIndexes(table(i));
    }
}

validate 'Включить' (Index i) {
    IF relid(i) > 0 THEN {
        INTERNAL DB 'UPDATE pg_index SET indisvalid = true WHERE indexrelid = $1'
            PARAMS relid(i);
        getIndexes(table(i));
    }
}

dropIndexes 'Удалить индексы' (Table t) {
    logToFile('database-tools', 'start - DROP INDEXES');
    runSQL(CONCAT '\n',
        ('ALTER TABLE ' + lower(sid(t)) + (GROUP CONCAT (' DROP CONSTRAINT ' + name(Index i)) IF isConstraint(i) AND table(i) == t, '\n' ORDER i) + ';'),
        (GROUP CONCAT ('DROP INDEX ' + name(Index i)) IF NOT isConstraint(i) AND table(i) == t, ';\n' ORDER i)
    );
}

dataCountTreads = DATA INTEGER ();
countTreads 'Количество потоков'() = OVERRIDE dataCountTreads(), 4;

createIndexes 'Создать индексы' (Table t) {
    NEWEXECUTOR
        FOR table(Index i) == t DO
            NEWTHREAD NEWSESSION NEWSQL {
                TRY {
                    logToFile('database-tools', 'start - ' + definition(i));
                    runSQL(definition(i));
                } CATCH {
                    logToFile('database-tools', (CONCAT '', 'error - ' + definition(i) + ': \n', messageCaughtException() ));
                }
                logToFile('database-tools', 'end - ' + definition(i) );
            }
        THREADS countTreads();

    FOR isConstraint(Index i) AND table(i) == t DO {
        TRY {
            logToFile('database-tools', 'start - ADD CONSTRAINT  ' + name(i) );
            //пока полагаемся что у нас только PRIMARY KEY иначе нужно будет проверять что pg_get_constraintdef
            runSQL('ALTER TABLE ' + lower(sid(t)) + ' ADD CONSTRAINT ' + name(i) + ' PRIMARY KEY USING INDEX ' + name(i));
        } CATCH {
            logToFile('database-tools', (CONCAT '', 'error - ADD CONSTRAINT ' + name(i) + ': \n', messageCaughtException() ));
        }
        logToFile('database-tools', 'end - ADD CONSTRAINT  ' + name(i));
    }
}

//REINDEX CONCURRENTLY вешает Lock virtualxid и ждет пока завершатся ВСЕ запросы в базе запущенные раньше этого момента
//https://www.postgresql.org/message-id/1878.1481823217%40sss.pgh.pa.us
//что может приводить к большому времени ожидания завершения опраци если есть длинные запросы
//поэтому на небольших индексах лучше на несколько секунд заблокировать все запросы к таблице чем REINDEX на долгое время
reindexConcurrentlySize 'REINDEX CONCURRENTLY свыше (МБ)' = DATA NUMERIC[15,3] ();

skipExceptions 'Пропускать ошибки' = DATA BOOLEAN ();

runAndLogSQL(STRING command) {
    logToFile('database-tools', 'start - ' + command);
    IF skipExceptions() THEN {
        TRY {
            runSQL(command);
        } CATCH {
            logToFile('database-tools', (CONCAT '\n', messageCaughtException(), javaStackTraceCaughtException(), lsfStackTraceCaughtException()));
        }
    } ELSE
        runSQL(command);
    logToFile('database-tools', 'end - ' + command);
}

reindex 'REINDEX' (Index i) {
    runAndLogSQL('REINDEX INDEX ' + (IF indexSize(i) / 1024 / 1024.0 > reindexConcurrentlySize() THEN 'CONCURRENTLY ' ELSE '') + name(i));
}

reindex 'REINDEX' (Table t) {
    CASE WHEN deleteIndexes(t) THEN {
        getIndexes(t);
        dropIndexes(t);
        createIndexes(t);
    } WHEN large(t) THEN {
        getIndexes(t);
        FOR table(Index i) == t ORDER indexSize(i) DO {
            reindex(i);
        }
    } ELSE {
        runAndLogSQL('REINDEX TABLE ' + (IF indexSize(t) > reindexConcurrentlySize() THEN 'CONCURRENTLY ' ELSE '') + sid(t));
    }
    NEWSESSION {
        indexSize(t) <- [FORMULA NUMERIC[15,3] 'pg_indexes_size($1) /1024/1024.0'](lower(sid(t)));
        APPLY;
    }
} ASON CONTEXTMENU sid[DatabaseTable];

vacuumSysTab ABSTRACT (INTEGER, STRING);
vacuumSysTab (INTEGER count, STRING table) + {
    TRY {
        runSQL('VACUUM FULL ' + table);
    } CATCH {
        IF count > 2 THEN {
            MESSAGE 'Error while vacuum table ' + table + '. See database-tools.log for details.' NOWAIT;
            logToFile('database-tools', CONCAT '\n', 'VACUUM SYSTEM TABLES ERROR:', messageCaughtException(), lsfStackTraceCaughtException(), javaStackTraceCaughtException());
            RETURN;
        } ELSE {
            vacuumSysTab(count + 1, table);
        }
    }
}

vacuum 'VACUUM FULL' (DatabaseTable t) {
    IF deleteIndexes(t) THEN {
        getIndexes(t);
        dropIndexes(t);
    }
    IF t IS PgTable THEN {
        logToFile('database-tools', 'start - VACUUM SYS FULL ' + sid(t) );
        vacuumSysTab(0, sid(t));
        logToFile('database-tools', 'end - VACUUM SYS FULL ' + sid(t));
    } ELSE {
        runAndLogSQL('VACUUM FULL ' + sid(t));
    }
    IF deleteIndexes(t) THEN {
        createIndexes(t);
    }
    NEWSESSION {
        dataSize(t) <- [FORMULA NUMERIC[15,3] 'pg_table_size($1) /1024/1024.0'](lower(sid(t)));
        indexSize(t) <- [FORMULA NUMERIC[15,3] 'pg_indexes_size($1) /1024/1024.0'](lower(sid(t)));
        APPLY;
    }
} ASON CONTEXTMENU sid[DatabaseTable];

loadCurSize 'Заполнить размеры таблиц'(){
    INTERNAL DB 'SELECT tablename, CAST(pg_table_size(tablename::regclass)/1024/1024.0 AS numeric(15,3)) AS t_size, ' +
        'CAST(pg_indexes_size(tablename::regclass) /1024/1024.0 AS numeric(15,3)) AS i_size FROM pg_tables WHERE schemaname = \'public\''
        TO file;

    IMPORT TABLE FROM file() FIELDS STRING[100] table, NUMERIC[15,3] t_size, NUMERIC[15,3] i_size DO {
        curDataSize(Table t) <- t_size WHERE lower(sid(t)) == table;
        curIndexSize(Table t) <- i_size WHERE lower(sid(t)) == table;
    }
}

loadSystemCurSize 'Заполнить размеры системных таблиц'(){

    IF NOT (GROUP SUM 1 IF PgTable t IS PgTable) THEN NEWSESSION {
        INTERNAL DB 'SELECT tablename FROM pg_tables WHERE schemaname = \'pg_catalog\''
            TO file;

        IMPORT TABLE FROM file() FIELDS STRING[100] table DO {
            IF NOT table(table) THEN {
                NEW t = PgTable {
                    sid(t) <- table;
                    curDataSize(t) <- 5000;
                    curIndexSize(t) <- 5000;
                }
            }
        }
        APPLY;
    }

    INTERNAL DB 'SELECT tablename, CAST(pg_table_size(tablename::regclass)/1024/1024.0 AS numeric(15,3)) AS t_size, ' +
        'CAST(pg_indexes_size(tablename::regclass) /1024/1024.0 AS numeric(15,3)) AS i_size FROM pg_tables WHERE schemaname = \'pg_catalog\''
        TO file;

    IMPORT TABLE FROM file() FIELDS STRING[100] table, NUMERIC[15,3] t_size, NUMERIC[15,3] i_size DO {
        curDataSize(PgTable t) <- t_size WHERE lower(sid(t)) == table;
        curIndexSize(PgTable t) <- i_size WHERE lower(sid(t)) == table;
    }
}

dataVacuumCoeff = DATA NUMERIC[5,2]();
vacuumCoeff 'Коэффициент роста' () = OVERRIDE dataVacuumCoeff(), 0.1;
dataVacuumSize = DATA NUMERIC[5,2]();
vacuumSize 'Минимальный размер (МБ)' () = OVERRIDE dataVacuumSize(), 1.0;

dataGrow(DatabaseTable t) = grow(curDataSize(t), dataSize(t));
needVacuum(DatabaseTable t) = dataGrow(t) > vacuumCoeff() AND curDataSize(t) + curIndexSize(t) > vacuumSize() AND NOT large(t);
backgroundData(DatabaseTable t) = IF needVacuum(t) THEN RGB (255, 80, 80) ELSE RGB (255, 179, 179);

indexGrow(DatabaseTable t) = grow(curIndexSize(t), indexSize(t));
needReindex(DatabaseTable t) = indexGrow(t) > vacuumCoeff() AND curDataSize(t) + curIndexSize(t) > vacuumSize();
backgroundIndex(DatabaseTable t) = IF needReindex(t) THEN RGB (255, 80, 169) ELSE RGB (255, 179, 217);

CLASS VacuumOrderType 'Сортировка'{
    totalSize 'По возрастанию размера',
    growSizeDesc 'По убыванию прироста'
};
TABLE vacuumOrderType (VacuumOrderType);

name 'Наименование' (VacuumOrderType o) = staticCaption(o) IF o IS VacuumOrderType CHARWIDTH 15;

FORM dialogVacuumOrderTypes 'Сортировка'
    OBJECTS o = VacuumOrderType
    PROPERTIES(o) READONLY name

    LIST VacuumOrderType OBJECT o
;
dataVacuumOrderType = DATA VacuumOrderType();
vacuumOrderType() = OVERRIDE dataVacuumOrderType(), VacuumOrderType.totalSize;
nameVacuumOrderType 'Сортировка'() = name(vacuumOrderType());

vacuumOrder(DatabaseTable t) = CASE
    WHEN vacuumOrderType() == VacuumOrderType.totalSize THEN curDataSize(t) (+) curIndexSize(t)
    WHEN vacuumOrderType() == VacuumOrderType.growSizeDesc THEN (dataSize(t) (-) curDataSize(t)) (+) (indexSize(t) (-) curIndexSize(t))
;

smartVacuum 'Smart VACUUM'(BOOLEAN pgOnly) {
    logToFile('database-tools', 'Smart VACUUM - starting');

    IF NOT pgOnly THEN loadCurSize();
    loadSystemCurSize();

    EXPORT CSV '|' HEADER
        FROM sid(DatabaseTable t), vacuumOrder(t), skipVacuum(t), dataSize(t), curDataSize(t), dataGrow(t), indexSize(t), curIndexSize(t), indexGrow(t)
        WHERE (curDataSize(t) AND NOT curDataSize(t) >= dataSize(t)) OR (curIndexSize(t) AND NOT curIndexSize(t) >= indexSize(t)) TO file;

    IF file() THEN {
        logToFile('database-tools', 'Smart VACUUM - new stat for externaly shrinked tables:');
        logToFile('database-tools', file());
        NEWSESSION NESTED LOCAL {
            dataSize(DatabaseTable t) <- curDataSize(t) WHERE curDataSize(t) AND NOT curDataSize(t) >= dataSize(t);
            indexSize(DatabaseTable t) <- curIndexSize(t) WHERE curIndexSize(t) AND NOT curIndexSize(t) >= indexSize(t);
            APPLY NESTED LOCAL;
        }
    }

    EXPORT CSV '|' HEADER
        FROM sid(DatabaseTable t), vacuumOrder(t), skipVacuum(t), dataSize(t), curDataSize(t), dataGrow(t), indexSize(t), curIndexSize(t), indexGrow(t)
        WHERE curDataSize(t) AND (needVacuum(t) OR needReindex(t)) ORDER vacuumOrder(t), t TO file;
    IF file() THEN {
        logToFile('database-tools', 'Smart VACUUM - plan for today:');
        logToFile('database-tools', file());
    }

    FOR curDataSize(DatabaseTable t) AND NOT skipVacuum(t) AND (needVacuum(t) OR needReindex(t)) ORDER vacuumOrder(t), t DO {
        IF needVacuum(t) OR t IS PgTable THEN {
            vacuum(t);
        } ELSE {
            reindex(t);
        }
        IF isStopTime() THEN {
            logToFile('database-tools', 'Stopped after deadline');
            BREAK;
        }
    }

    logToFile('database-tools', 'Smart VACUUM - ended');
}
smartVacuum 'Smart VACUUM'(){
    smartVacuum(NULL);
}

//статистика

analyze 'ANALYZE' (Table t) {
    INTERNAL DB 'ANALYZE ' + lower(sid(t));
} ASON CONTEXTMENU sid[DatabaseTable];

percentNotNullStat 'Не null, % (стат)' = DATA LOCAL NESTED NUMERIC(TableColumn);
backgroundStatNotNull(TableColumn c) = IF changedCoeff(percentNotNullStat(c), percentNotNull(c)) >= 1.5 THEN RGB (51, 153, 51) ELSE RGB (198, 236, 198);
quantityStat 'Количество разновидностей (стат)' = DATA LOCAL NESTED LONG (TableColumn);
statisticTarget 'statistics_target' = DATA LOCAL NESTED INTEGER (TableColumn);
backgroundStat(TableColumn c) = IF changedCoeff(quantityStat(c), quantity(c)) >= 5 AND changedCoeff(quantityStat(c), quantityTop(c)) >= 5 THEN RGB (51, 153, 51) ELSE RGB (198, 236, 198);
quantityStat 'Количество разновидностей (стат)' = DATA LOCAL NESTED LONG (TableKey);
backgroundStat(TableKey c) = IF changedCoeff(quantityStat(c), quantity(c)) >= 5 AND changedCoeff(quantityStat(c), quantityTop(c)) >= 5 THEN RGB (51, 153, 51) ELSE RGB (198, 236, 198);
statisticTarget 'statistics_target' = DATA LOCAL NESTED INTEGER (TableKey);

loadCurRows 'Заполнить количество записей' (Table t) {
    curRows(t) <- [FORMULA LONG 'SELECT reltuples::BIGINT FROM pg_class WHERE relname =$1'](lower(sid(t)));
}

fillStats 'Получить статистику таблицы' (Table t) {

    loadCurRows(t);

    INTERNAL DB 'SELECT attname, CAST((1.0 - null_frac) * 100 AS numeric(11,8)) AS noNull, n_distinct::numeric(21,10) FROM pg_stats WHERE tablename = $1'
        PARAMS lower(sid(t))
        TO file;

    IMPORT TABLE FROM file() FIELDS STRING[100] attname, NUMERIC[11,8] noNull, NUMERIC[21,10] n_distinct DO {
        FOR table(TableKey tk) == t AND lower(name(tk)) == attname AND NUMERIC q == IF n_distinct >= 0 THEN n_distinct ELSE curRows(t) * -n_distinct DO {
            quantityStat(tk) <- safeInt(min(coeff(t) * q, rows(t))); //число разновидностей не всегда зависит от числа строк, но для упрощения считаем линейно
        }
        FOR table(TableColumn tc) == t AND lower(sid(tc)) == attname AND NUMERIC q == IF n_distinct >= 0 THEN n_distinct ELSE curRows(t) * -n_distinct DO {
            quantityStat(tc) <- safeInt(min(coeff(t) * q, rows(t)));
            percentNotNullStat(tc) <- noNull;
        }
    }

    LOCAL defStatTarget = INTEGER ();
    defStatTarget() <- [FORMULA INTEGER 'SELECT setting FROM pg_settings WHERE name = \'default_statistics_target\'']();

    INTERNAL DB 'SELECT attname, attstattarget FROM pg_attribute WHERE attrelid = $1::regclass AND attnum > 0  AND NOT attisdropped;'
        PARAMS lower(sid(t))
        TO file;
    
    LOCAL attname = STRING[100](INTEGER);
    LOCAL attstattarget = NUMERIC(INTEGER);
    
    
    IMPORT TABLE FROM file() TO attname, attstattarget;

    FOR table(TableKey tk) == t AND lower(name(tk)) == attname(INTEGER r) DO {
        statisticTarget(tk) <- IF attstattarget(r) == -1 THEN defStatTarget() ELSE attstattarget(r);
    }

    FOR table(TableColumn tc) == t AND lower(sid(tc)) == attname(INTEGER r) DO {
        statisticTarget(tc) <- IF attstattarget(r) == -1 THEN defStatTarget() ELSE attstattarget(r);
    }
}
stat = DATA LOCAL INTEGER ();
FORM statInput
    PROPERTIES stat();

setStat 'Set statistics_target' (TableKey k) {
    stat() <- OVERRIDE statisticTarget(k), 100;
    SHOW statInput ;
    INTERNAL DB 'ALTER TABLE '+lower(sid(table(k)))+' ALTER COLUMN '+lower(name(k))+' SET STATISTICS '+stat()+';' ;
    
    analyze(table(k));
    fillStats(table(k));
}
setStat 'Set statistics_target' (TableColumn c) {
    stat() <- OVERRIDE statisticTarget(c), 100;
    SHOW statInput ;
    INTERNAL DB 'ALTER TABLE '+lower(sid(table(c)))+' ALTER COLUMN '+lower(sid(c))+' SET STATISTICS '+stat()+';' ;
    
    analyze(table(c));
    fillStats(table(c));
}

loadCurRows 'Заполнить количество записей'(){
    INTERNAL DB 'SELECT pc.relname, reltuples::BIGINT FROM pg_class pc JOIN pg_tables pt ON pc.relname=pt.tablename AND pt.schemaname = \'public\''
        TO file;

    IMPORT TABLE FROM file() FIELDS STRING[100] table, LONG size DO {
        curRows(Table t) <- size WHERE lower(sid(t)) == table;
    }
}

setSkipStatistic 'Исключить из пересчета статистики'() {
    loadCurRows();
    notRecalculateStats(Table t) <- min(curRows(t), rows(t)) > 100000000 OR curRows(t) == rows(t) OR changedCoeff(curRows(t), rows(t)) < 2;
}

needStats(Table t) = changedCoeff(curRows(t), rows(t)) >= 5;
backgroundRows(Table t) = IF needStats(t) THEN RGB (51, 153, 51) ELSE RGB (198, 236, 198);

lastRecalculateStats 'Последний пересчет статистики' = DATA DATETIME (Table);
lastRecalculateStats 'Последний пересчет статистики' = DATA DATETIME (TableKey);
lastRecalculateStats 'Последний пересчет статистики' = DATA DATETIME (TableColumn);

//Через PARAMS не работает. Имена таблиц и колонок должны быть не строками а PARAMS подставляет их как строки с кавычками
//в 6 версии можно будет переделать на интерполяцию. 
notNullQuery() = 'SELECT COUNT(*) FROM $2 WHERE $1 IS NOT NULL';
distinctQuery() = 'SELECT COUNT(DISTINCT $1) FROM $2';
distinctTopQuery() ='WITH group_counts AS (SELECT $1 AS group_value, COUNT(*) AS count_per_group FROM $2 WHERE $1 IS NOT NULL GROUP BY $1), ranked_groups AS (SELECT group_value, count_per_group, SUM(count_per_group) OVER (ORDER BY count_per_group DESC, group_value ASC) AS cumulative_count FROM group_counts), filtered_groups AS (SELECT group_value FROM ranked_groups WHERE cumulative_count <= $3) SELECT COUNT(*) AS top_group_count FROM filtered_groups;';

qty = DATA LOCAL LONG ();
importQuantity(STRING command) {
    INTERNAL DB command TO file;
    IMPORT TABLE FROM file() TO () qty;
}

importQuantityAndLog(STRING command) {
    logToFile('database-tools', 'start - ' + command);
    IF skipExceptions() THEN {
        TRY {
            importQuantity(command);
        } CATCH {
            logToFile('database-tools', (CONCAT '\n', messageCaughtException(), javaStackTraceCaughtException(), lsfStackTraceCaughtException()));
        }
    } ELSE
        importQuantity(command);
    logToFile('database-tools', 'end - ' + command);
}

recalculateStats 'Пересчет статистики' (TableColumn c) {
    NEWSESSION {
        TRY { 
            logToFile('database-tools', 'start recalculateStats ' + sid(c));

            LOCAL quantity, quantityTop, notNullQuantity = LONG();

            importQuantityAndLog(replace(replace(notNullQuery(), '$1', sid(c)), '$2', sid(table(c))));
            notNullQuantity() <- qty();

            IF notNullQuantity() == 0 THEN {
                quantity() <- 0;
                quantityTop() <- 0;
            } ELSE {
                IF NOT return(c) == 'BOOLEAN' AND NOT return(c) LIKE '%FILE' THEN {
                    importQuantityAndLog(replace(replace(distinctQuery(), '$1', sid(c)), '$2', sid(table(c))));
                    quantity() <- qty();

                    importQuantityAndLog(replace(replace(replace(distinctTopQuery(), '$1', sid(c)), '$2', sid(table(c))), '$3', STRING(LONG(0.8 * notNullQuantity()))));
                    //нормализуем обратно к 100% 
                    //(qty() == 0 AND quantity() != 0) нужно на случай если одна группа больше 80%.текущий запрос возвращает 0. Известно что есть группы если quantity() != 0, не нужно уложнять запрос
                    quantityTop() <- min(notNullQuantity(), (IF qty() == 0 AND quantity() != 0 THEN 1 ELSE qty()) / 0.8);
                }
            }

            IF NOT curRows(table(c)) THEN {
                loadCurRows(table(c));
            }
            FOR c = tableColumn(Property pt) DO {
                quantity(pt) <- safeInt(min(coeff(table(c)) * quantity(), rows(table(c))));
                quantityTop(pt) <- safeInt(min(coeff(table(c)) * quantityTop(), rows(table(c))));
                notNullQuantity(pt) <- safeInt(min(coeff(table(c)) * notNullQuantity(), rows(table(c))));
            }

            lastRecalculateStats(c) <- currentDateTime();

            APPLY;
            logToFile('database-tools', 'end recalculateStats ' + sid(c));
        } CATCH {
            logToFile('database-tools', (CONCAT '\n', messageCaughtException(), lsfStackTraceCaughtException()));
            MESSAGE 'Ошибка пересчета статистики ' + messageCaughtException() NOWAIT;
        }
    }
}

singleKey(Table t) = (GROUP SUM 1 IF table(TableKey k) == t) == 1;

recalculateStats 'Пересчет статистики' (TableKey k) {
    NEWSESSION {
        TRY {
            logToFile('database-tools', 'start recalculateStats ' + sid(k));

            IF NOT curRows(table(k)) THEN {
                loadCurRows(table(k));
            }

            LOCAL quantity, quantityTop = LONG();

            IF singleKey(table(k)) THEN {
                importQuantityAndLog(replace(replace(notNullQuery(), '$1', sid(k)), '$2', sid(table(k))));
                quantity() <- safeInt(qty());
                quantityTop() <- safeInt(qty());
            } ELSE {
                importQuantityAndLog(replace(replace(distinctQuery(), '$1', sid(k)), '$2', sid(table(k))));
                quantity() <- qty();

                importQuantityAndLog(replace(replace(replace(distinctTopQuery(), '$1', sid(k)), '$2', sid(table(k))), '$3', STRING(LONG(0.8 * curRows(table(k))))));
                //нормализуем обратно к 100% 
                //(qty() == 0 AND quantity() != 0) нужно на случай если одна группа больше 80%.текущий запрос возвращает 0. Известно что есть группы если quantity() != 0, не нужно уложнять запрос
                quantityTop() <- min(curRows(table(k)), (IF qty() == 0 AND quantity() != 0 THEN 1 ELSE qty()) / 0.8);
            }

            quantity(k) <- safeInt(min(coeff(table(k)) * quantity(), rows(table(k))));
            quantityTop(k) <- safeInt(min(coeff(table(k)) * quantityTop(), rows(table(k))));

            lastRecalculateStats(k) <- currentDateTime();

            APPLY;
            logToFile('database-tools', 'end recalculateStats ' + sid(k));
        } CATCH {
            logToFile('database-tools', (CONCAT '\n', messageCaughtException(), lsfStackTraceCaughtException()));
            MESSAGE 'Ошибка пересчета статистики ' + messageCaughtException() NOWAIT;
        }
    }

}

recalculateStats 'Пересчет статистики' (Table t, BOOLEAN skipTime) {
    NEWSESSION {
        logToFile('database-tools', 'start recalculateStats ' + sid(t));

        INTERNAL DB 'ANALYZE ' + lower(sid(t));
        loadCurRows(t);

        importQuantityAndLog(replace(replace(notNullQuery(), '$1', 'key0'), '$2', sid(t)));
        rows(t) <- safeInt(qty());
        lastRecalculateStats(t) <- currentDateTime();

        IF singleKey(t) THEN {
            quantity(TableKey k) <- safeInt(qty()) WHERE table(k) == t;
            quantityTop(TableKey k) <- safeInt(qty()) WHERE table(k) == t;
            lastRecalculateStats(TableKey k) <- currentDateTime() WHERE table(k) == t;
            APPLY;
        } ELSE {
            APPLY;
            NEWEXECUTOR
                FOR table(TableKey k) == t DO
                    NEWTHREAD NEWSESSION NEWSQL {
                        IF isStopTime() AND skipTime THEN {
                            BREAK;
                        }
                        recalculateStats(k);
                    }
                THREADS countTreads();
        }

        NEWEXECUTOR
            FOR table(TableColumn c) == t DO
                NEWTHREAD NEWSESSION NEWSQL {
                    IF isStopTime() AND skipTime THEN {
                        BREAK;
                    }
                    recalculateStats(c);
                }
            THREADS countTreads();

        logToFile('database-tools', 'end recalculateStats ' + sid(t));
    }
}
recalculateStats 'Пересчет статистики' (Table t) {
    recalculateStats(t, NULL);
}

smartStats 'Smart Stats'() {
    //Resuming incomplete column recalculation
    NEWEXECUTOR
        FOR lastRecalculateStats(table(TableKey k)) AND NOT lastRecalculateStats(k) >= lastRecalculateStats(table(k)) DO
            NEWTHREAD NEWSESSION NEWSQL {
                IF isStopTime() THEN {
                    BREAK;
                }
                logToFile('database-tools', 'Smart Stats incomplete TableKey: ' + sid(table(k)) + '.' + sid(k));
                recalculateStats(k);
            }
        THREADS countTreads();

    IF isStopTime() THEN {
        logToFile('database-tools', 'Stopped after deadline ');
        RETURN;
    }

    NEWEXECUTOR
        FOR lastRecalculateStats(table(TableColumn c)) AND NOT lastRecalculateStats(c) >= lastRecalculateStats(table(c)) DO
            NEWTHREAD NEWSESSION NEWSQL {
                IF isStopTime() THEN {
                    BREAK;
                }
                logToFile('database-tools', 'Smart Stats incomplete TableColumn: ' + sid(table(c)) + '.' + sid(c));
                recalculateStats(c);
            }
        THREADS countTreads();

    IF isStopTime() THEN {
        logToFile('database-tools', 'Stopped after deadline ');
        RETURN;
    }

    //Significant non-null changes
    INTERNAL DB 'SELECT tablename, attname, CAST((1.0 - null_frac) * 100 AS numeric(11,8)) AS noNull FROM pg_stats WHERE schemaname = \'public\';' TO file;

    LOCAL tablename, attname = STRING (INTEGER);
    LOCAL noNull = NUMERIC (INTEGER);

    IMPORT TABLE FROM file() TO tablename, attname, noNull;

    NEWEXECUTOR
        FOR tablename(INTEGER r) == lower(sid(Table t)) AND attname(r) == lower(sid(TableColumn c)) AND NUMERIC nonull = noNull(r) AND
            NUMERIC coeff = changedCoeff(nonull, percentNotNull(c)) AND coeff > 1.5 AND rows(t) > 100 ORDER DESC coeff DO {
            NEWTHREAD NEWSESSION NEWSQL {
                IF isStopTime() THEN {
                    BREAK;
                }
                logToFile('database-tools', 'Smart Stats significantly changed column ' + sid(table(c)) + '.' + sid(c) + ' coeff ' + coeff + '(' + nonull + '/' + percentNotNull(c) + ')');
                recalculateStats(c);
            }
        }
        THREADS countTreads();

    IF isStopTime() THEN {
        logToFile('database-tools', 'Stopped after deadline ');
        RETURN;
    }

    //tables with significant rows changes
    loadCurRows();
    FOR changedCoeff(curRows(Table t), rows(t)) > 2 AND NOT notRecalculateStats(t) ORDER DESC changedCoeff(curRows(t), rows(t)) DO {
        IF isStopTime() THEN {
            logToFile('database-tools', 'Stopped after deadline');
            BREAK;
        }
        logToFile('database-tools', 'Smart Stats significantly changed table ' + sid(t) + ' coeff ' + changedCoeff(curRows(t), rows(t)) + '(' + curRows(t) + '/' + rows(t) + ')');
        recalculateStats(t, TRUE);
    }
}

EXTEND FORM tools
    OBJECTS t = DatabaseTable
    PROPERTIES (t) READONLY sid
    PROPERTIES (t) skipVacuum
    PROPERTIES (t) READONLY BACKGROUND backgroundData(t) dataSize, curDataSize
    PROPERTIES (t) READONLY BACKGROUND backgroundIndex(t) indexSize, curIndexSize, deleteIndexes CHANGEABLE, large CHANGEABLE
    PROPERTIES (t) READONLY BACKGROUND backgroundRows(t) notRecalculateStats CHANGEABLE, rows, curRows, lastRecalculateStats
    PROPERTIES (t) recalculateStats GRID
    PROPERTIES (t) TOOLBAR getIndexes, fillStats
    FILTERGROUP grow
        FILTER 'VACUUM' needVacuum(t)
        FILTER 'REINDEX' needReindex(t)
        FILTER 'Пересчет статистики' needStats(t)
        FILTER 'Любые' needVacuum(t) OR needReindex(t) OR needStats(t)

    FILTERGROUP system
        FILTER 'Системные' t IS PgTable

    OBJECTS tk = TableKey
    PROPERTIES(tk) READONLY class, classSID, name, quantity, quantityStat BACKGROUND backgroundStat(tk), quantityTop, statisticTarget, lastRecalculateStats
    PROPERTIES (tk) recalculateStats GRID, setStat TOOLBAR
    FILTERS table(tk) == t

    OBJECTS tc = TableColumn
    PROPERTIES(tc) READONLY sid, caption, return, quantity, quantityStat BACKGROUND backgroundStat(tc), quantityTop,
        notNullQuantity, percentNotNull, percentNotNullStat BACKGROUND backgroundStatNotNull(tc), statisticTarget, lastRecalculateStats
    PROPERTIES (tc) recalculateStats GRID, setStat TOOLBAR 
    FILTERS table(tc) == t

    OBJECTS i = Index
    PROPERTIES(i) READONLY name, definition, tablespace, isConstraint, indexSize, indexScans, indexReads, efficiency, relid, indisvalid, sidTable
    PROPERTIES(i) TOOLBAR invalidate SHOWIF indisvalid(i), validate SHOWIF NOT indisvalid(i), reindex
    FILTERGROUP index
        FILTER 'По таблице' table(i) = t DEFAULT

    PROPERTIES () loadCurSize, loadSystemCurSize, vacuumSize, vacuumCoeff, nameVacuumOrderType, smartVacuum, countTreads,
        loadCurRows, setSkipStatistic, reindexConcurrentlySize, skipExceptions, stopAfter, smartStats
;

DESIGN tools{
    pane{
        NEW dbMain{
            caption = 'Таблицы';
            horizontal = TRUE;
            NEW dbLeft{
                NEW common {
                    caption = 'Общие';
                    MOVE PROPERTY (skipExceptions());
                    MOVE PROPERTY (stopAfter());
                }
                NEW vacuum {
                    caption = 'Упаковка';
                    MOVE PROPERTY (loadCurSize());
                    MOVE PROPERTY (loadSystemCurSize());
                    MOVE PROPERTY (vacuumSize());
                    MOVE PROPERTY (vacuumCoeff());
                    MOVE PROPERTY (nameVacuumOrderType());
                    MOVE PROPERTY (countTreads());
                    MOVE PROPERTY (reindexConcurrentlySize());
                    MOVE PROPERTY (smartVacuum());
                }
                NEW stats{
                    caption = 'Статистика';
                    MOVE PROPERTY (loadCurRows());
                    MOVE PROPERTY (setSkipStatistic());
                    MOVE PROPERTY (smartStats());
                }
            }
            NEW dbRight{
                fill = 1;
                MOVE BOX (t);
                NEW dbColumns{
                    fill = 0.4;
                    tabbed = TRUE;
                    MOVE BOX (tc) {
                        PROPERTY (caption(tc)) {charWidth = 50;};
                        PROPERTY (return (tc)) {charWidth = 20;};
                        PROPERTY (percentNotNull(tc)) {pattern = '#,##0.##';};
                        PROPERTY (percentNotNullStat(tc)) {pattern = '#,##0.##';};
                    };
                    MOVE BOX (tk);
                    MOVE BOX (i);
                }
            }
        }
    }
}

WHEN LOCAL SET(ACTIVE TAB tools.dbMain) DO {
    loadCurSize();
    loadSystemCurSize();
    loadCurRows();
}

onStarted() + {
    // Автоматически VACUUM системных таблиц на запуске сервера
    IF NOT inDevMode() THEN {
        logToFile('database-tools', 'Started vacuuming system tables on start');
        smartVacuum(TRUE);
        logToFile('database-tools', 'Ended vacuuming system tables on start');
    }
}