MODULE DatabaseTools;

REQUIRE Tools, Reflection, SQLUtils, LogTools;

NAMESPACE Tools;

@defineLogRotate(databaseTools, 5, weekly,'database-tools');

dataSize 'Размер данных (МБ)' = DATA NUMERIC[15,3](Table);
indexSize 'Размер индексов (МБ)' = DATA NUMERIC[15,3](Table);

curDataSize 'Тек. размер данных (МБ)' = DATA LOCAL NESTED NUMERIC[15,3](Table);
curIndexSize 'Тек. размер индексов (МБ)' = DATA LOCAL NESTED NUMERIC[15,3](Table);
curRows 'Тек. количество записей' = DATA LOCAL NESTED LONG (Table);

deleteIndexes 'Удалять индексы при упаковке' = DATA BOOLEAN (Table);

CLASS Index 'Индекс';

table 'Таблица' = DATA Table (Index);
name 'Наименование' = DATA STRING (Index);
tablespace 'Tablespace' = DATA STRING (Index);
definition 'Скрипт' = DATA STRING (Index);
isConstraint 'Constraint' = DATA BOOLEAN (Index);

index = GROUP AGGR Index x BY name(x);

getIndexes 'Получить список индексов'(Table t) {
    NEWSESSION {
        EXTERNAL SQL 'LOCAL'
            EXEC 'SELECT indexname, tablespace, indexdef, pg_get_constraintdef(c.oid) from pg_indexes i left join pg_constraint c ON i.indexname = c.conname where tablename = $1' 
            PARAMS lower(sid(t))
            TO file;
            
        IMPORT TABLE FROM file() FIELDS STRING indexname, STRING tablespace NULL , STRING definition, STRING constraint NULL DO {
            IF NOT index(indexname) THEN NEW i = Index {
                name(i) <- indexname;
            }
            FOR name(Index i ) == indexname DO {
                table(i) <- t;
                tablespace(i) <- tablespace;
                definition(i) <- definition;
                isConstraint(i) <- TRUE IF constraint;
            }
        }
        
        APPLY;
        
    }
} ASON CONTEXTMENU sid[Table];

dropIndexes 'Удалить индексы' (Table t) {
    logToFile('database-tools', 'start - DROP INDEXES');
    runSQL(CONCAT '\n',
        ('ALTER TABLE ' + lower(sid(t)) + (GROUP CONCAT (' DROP CONSTRAINT ' + name(Index i)) IF isConstraint(i) AND table(i) == t, '\n') + ';'),
        (GROUP CONCAT ('DROP INDEX ' + name(Index i)) IF NOT isConstraint(i) AND table(i) == t, ';\n')
    );
}


dataCountTreads = DATA INTEGER ();
countTreads 'Количество потоков'() = OVERRIDE dataCountTreads(), 4;

createIndexes 'Создать индексы' (Table t) {
    NEWEXECUTOR 
        FOR table(Index i) == t DO 
            NEWTHREAD NEWSESSION NEWSQL {
                TRY {
                    logToFile('database-tools', 'start - ' + definition(i));
                    runSQL(definition(i)); 
                } CATCH {
                    logToFile('database-tools', (CONCAT '', 'error - ' + definition(i) + ': \n', messageCaughtException() ));
                }
                logToFile('database-tools', 'end - ' + definition(i) );
            } 
	THREADS countTreads();
    
    FOR isConstraint(Index i) AND table(i) == t DO {
        TRY {
            logToFile('database-tools', 'start - ADD CONSTRAINT  '+ name(i) );
            //пока полагаемся что у нас только PRIMARY KEY иначе нужно будет проверять что pg_get_constraintdef
            runSQL('ALTER TABLE ' + lower(sid(t)) + ' ADD CONSTRAINT ' + name(i) + ' PRIMARY KEY USING INDEX ' + name(i)); 
        } CATCH {
            logToFile('database-tools', (CONCAT '', 'error - ADD CONSTRAINT ' + name(i) + ': \n', messageCaughtException() ));
        }
        logToFile('database-tools', 'end - ADD CONSTRAINT  '+ name(i));
    } 
}

reindexConcurrently 'REINDEX CONCURRENTLY' = DATA BOOLEAN ();
skipExceptions 'Пропускать ошибки' = DATA BOOLEAN ();
stopAfter 'Не запускать после' = DATA TIME();

reindex 'REINDEX' (Table t) {
    IF deleteIndexes(t) THEN {
        getIndexes(t);
        dropIndexes(t);
        createIndexes(t);
    } ELSE {
        logToFile('database-tools', 'start - REINDEX TABLE ' + sid(t) );
        IF skipExceptions() THEN {
            TRY {
                runSQL('REINDEX TABLE ' + (IF reindexConcurrently() THEN 'CONCURRENTLY ' ELSE '') + sid(t));
            } CATCH {
                logToFile('database-tools', (CONCAT '\n', messageCaughtException(), javaStackTraceCaughtException(), lsfStackTraceCaughtException()));
            }
        } ELSE 
            runSQL('REINDEX TABLE ' + (IF reindexConcurrently() THEN 'CONCURRENTLY ' ELSE '') + sid(t));
        logToFile('database-tools', 'end - REINDEX TABLE ' + sid(t));
    }
    NEWSESSION {
        indexSize(t) <- [FORMULA NUMERIC[15,3] 'pg_indexes_size($1) /1024/1024.0'](lower(sid(t)));
        APPLY;
    }
} ASON CONTEXTMENU sid[Table];

vacuum 'VACUUM FULL' (Table t) {
    IF deleteIndexes(t) THEN {
        getIndexes(t);
        dropIndexes(t);
    }
    logToFile('database-tools', 'start - VACUUM FULL ' + sid(t) );
    IF skipExceptions() THEN {
        TRY {
            runSQL('VACUUM FULL ' + sid(t));
        } CATCH {
            logToFile('database-tools', (CONCAT '\n', messageCaughtException(), javaStackTraceCaughtException(), lsfStackTraceCaughtException()));
        }
    } ELSE 
        runSQL('VACUUM FULL ' + sid(t));
    logToFile('database-tools', 'end - VACUUM FULL ' + sid(t));
    IF deleteIndexes(t) THEN {
        createIndexes(t);
    }    
    NEWSESSION {
        dataSize(t) <- [FORMULA NUMERIC[15,3] 'pg_table_size($1) /1024/1024.0'](lower(sid(t)));
        indexSize(t) <- [FORMULA NUMERIC[15,3] 'pg_indexes_size($1) /1024/1024.0'](lower(sid(t)));
        APPLY;
    }
} ASON CONTEXTMENU sid[Table];

loadCurSize 'Заполнить размеры таблиц'(){
    EXTERNAL SQL 'LOCAL'
        EXEC 'SELECT tablename, CAST(pg_table_size(tablename::regclass)/1024/1024.0 AS numeric(15,3)) AS t_size, ' +
             'CAST(pg_indexes_size(tablename::regclass) /1024/1024.0 AS numeric(15,3)) AS i_size FROM pg_tables WHERE schemaname = \'public\''
        TO file;
    
    IMPORT TABLE FROM file() FIELDS STRING[100] table, NUMERIC[15,3] t_size, NUMERIC[15,3] i_size DO {
        curDataSize(Table t) <- t_size WHERE lower(sid(t)) == table;
        curIndexSize(Table t) <- i_size WHERE lower(sid(t)) == table;
    }
}

grow = [NUMERIC[12,3](OVERRIDE (((OVERRIDE A, 0.001)-(OVERRIDE B, 0.001))/(OVERRIDE B, 0.001)), 0.0)](a,b);
dataVacuumCoeff = DATA NUMERIC[5,2]();
vacuumCoeff 'Коэффициент роста' () = OVERRIDE dataVacuumCoeff(), 0.1;
dataVacuumSize = DATA NUMERIC[5,2]();
vacuumSize 'Минимальный размер (МБ)' () = OVERRIDE dataVacuumSize(), 1.0;

dataGrow(Table t) = grow(curDataSize(t), dataSize(t));
needVacuum(Table t) = dataGrow(t) > vacuumCoeff() AND curDataSize(t) + curIndexSize(t) > vacuumSize();
backgroundData(Table t) = IF needVacuum(t) THEN RGB (255, 80, 80) ELSE RGB (255, 179, 179);

indexGrow(Table t) = grow(curIndexSize(t), indexSize(t));
needReindex(Table t) = indexGrow(t) > vacuumCoeff() AND curDataSize(t) + curIndexSize(t) > vacuumSize();
backgroundIndex(Table t) = IF needReindex(t) THEN RGB (255, 80, 169) ELSE RGB (255, 179, 217);

CLASS VacuumOrderType 'Сортировка'{
    totalSize 'По возрастанию размера',
    growSizeDesc 'По убыванию прироста'
};
TABLE vacuumOrderType (VacuumOrderType);

name 'Наименование' (VacuumOrderType o) = staticCaption(o) IF o IS VacuumOrderType CHARWIDTH 15;

FORM dialogVacuumOrderTypes 'Сортировка'
    OBJECTS o = VacuumOrderType
    PROPERTIES(o) READONLY name
    
    LIST VacuumOrderType OBJECT o
;
dataVacuumOrderType = DATA VacuumOrderType();
vacuumOrderType() = OVERRIDE dataVacuumOrderType(), VacuumOrderType.totalSize;
nameVacuumOrderType 'Сортировка'() = name(vacuumOrderType());

vacuumOrder(Table t) = CASE 
    WHEN vacuumOrderType() == VacuumOrderType.totalSize THEN curDataSize(t) (+) curIndexSize(t)
    WHEN vacuumOrderType() == VacuumOrderType.growSizeDesc THEN (dataSize(t) (-) curDataSize(t)) (+) (indexSize(t) (-) curIndexSize(t))
    ;

smartVacuum 'Smart VACUUM'() {
    logToFile('database-tools', 'Smart VACUUM - starting');
    
    loadCurSize();
    
    EXPORT CSV '|' HEADER 
        FROM sid(Table t), vacuumOrder(t), skipVacuum(t), dataSize(t), curDataSize(t), dataGrow(t), indexSize(t), curIndexSize(t), indexGrow(t)
        WHERE curDataSize(t) AND (needVacuum(t) OR needReindex(t)) ORDER vacuumOrder(t), t TO file;
    IF file() THEN {
        logToFile('database-tools', 'Smart VACUUM - plan for today:');
        logToFile('database-tools', file());
    }
    
    FOR curDataSize(Table t)  AND NOT skipVacuum(t) AND (needVacuum(t) OR needReindex(t)) ORDER vacuumOrder(t), t DO {
        IF needVacuum(t) THEN {
            vacuum(t);
        } ELSE {
            reindex(t);
        }
        IF currentTime() > stopAfter() THEN {
            logToFile('database-tools', 'Stopped after deadline');
            BREAK;
        }
    }
    
    logToFile('database-tools', 'Smart VACUUM - ended');
}


//статистика
CLASS StatisticGrowType 'Вид роста статистики'{
    proportional 'Пропорционально',
    fixed 'Не изменяется'
}
targetStatistic 'Фикс. количество записей' = DATA INTEGER (Table);

dataStatisticGrowType = DATA StatisticGrowType (TableKey);
statisticGrowType(TableKey tk) = OVERRIDE dataStatisticGrowType (tk), StatisticGrowType.proportional;
nameStatisticGrowType 'Вид роста статистики' (TableKey tk) = staticCaption(statisticGrowType(tk)) CHARWIDTH 20;

dataStatisticGrowType = DATA StatisticGrowType (TableColumn);
statisticGrowType(TableColumn tc) = OVERRIDE dataStatisticGrowType (tc), StatisticGrowType.proportional;
nameStatisticGrowType 'Вид роста статистики' (TableColumn tc) = staticCaption(statisticGrowType(tc)) CHARWIDTH 20;

recalculateStatsQ 'Пересчет статистики (быстрый)' (Table t) {
    NEWSESSION {
        
        LOCAL quantityTopNew  = INTEGER (TableKey);
        LOCAL quantityNew = INTEGER (TableKey);
        LOCAL quantityTopNew = INTEGER (TableColumn);
        LOCAL quantityNew = INTEGER (TableColumn);
        
        IF targetStatistic(t) THEN {
            curRows(t) <- targetStatistic(t);
        } ELSE {
            EXTERNAL SQL 'LOCAL' EXEC 'ANALYZE ' + lower(sid(t));
            
            curRows(t) <- [FORMULA INTEGER 'SELECT reltuples::BIGINT FROM pg_class WHERE relname =$1'](lower(sid(t)));
            
            EXTERNAL SQL 'LOCAL'
                EXEC 'SELECT attname, CAST (1.0-null_frac::numeric(11,10) AS numeric(11,10)) AS noNull, n_distinct::numeric(21,10),' +
                     'array_to_string(most_common_freqs, E\'|\') AS most_common_freqs, CASE WHEN n_distinct = null_frac - 1.0 THEN 1 END AS unique FROM pg_stats WHERE tablename =$1' PARAMS lower(sid(t))
                TO file;
            
            IMPORT TABLE FROM file() FIELDS STRING[100] attname, NUMERIC[11,10] noNull, NUMERIC[21,10] n_distinct, TEXT most_common_freqs, INTEGER unique DO {
                
                LOCAL freq = NUMERIC[11,10](INTEGER );
                freq(INTEGER i) <- NUMERIC[11,10](getWord(most_common_freqs, '|', i)) IF count(i, wordCount(most_common_freqs, '|'));
                
                FOR table(TableKey tk) == t AND lower(name(tk)) == attname DO {
                    quantityNew(tk) <- IF n_distinct >= 0 THEN n_distinct ELSE curRows(t) * -n_distinct;
                    quantityTopNew(tk) <- CASE WHEN (GROUP SUM 1 IF table(TableKey tkk) == t) == 1 OR unique == 1 //количество разновидностей значений == количеству строк
                                                    THEN curRows(t) * noNull 
                                               WHEN (GROUP SUM freq(INTEGER i)) >= noNull * 0.8 
                                                    THEN ((GROUP SUM 1 IF (PARTITION SUM freq( INTEGER i) ORDER i) < noNull * 0.8) (+) 1) / 0.8  ;
                }
                
                FOR table(TableColumn  tc) == t AND lower(sid(tc)) == attname AND NOT return(tc) == 'BOOLEAN' DO {
                    quantityNew(tc) <- IF n_distinct >= 0 THEN n_distinct ELSE curRows(t) * -n_distinct;
                    quantityTopNew(tc) <- CASE WHEN unique == 1 //количество разновидностей значений == количеству строк
                                                    THEN curRows(t) * noNull 
                                               WHEN (GROUP SUM freq(INTEGER i)) >= noNull * 0.8 
                                                    THEN ((GROUP SUM 1 IF (PARTITION SUM freq( INTEGER i) ORDER i) < noNull * 0.8) (+) 1) /0.8  ;
                }
                
                notNullQuantity(Property pt) <- curRows(t) * noNull WHERE tableSID(pt) == sid(t) AND lower(dbName(pt)) == attname;
            }
        }
            
        quantityNew(TableKey tk) <- IF statisticGrowType(tk) == StatisticGrowType.fixed THEN quantity(tk) ELSE NUMERIC[21,10](curRows(t)) / rows(t) * quantity(tk)
            WHERE table(tk) == t AND NOT quantityTopNew(tk);    
        quantityTopNew(TableKey tk) <- IF statisticGrowType(tk) == StatisticGrowType.fixed THEN quantityTop(tk) ELSE NUMERIC[21,10](curRows(t)) / rows(t) * quantityTop(tk)
            WHERE table(tk) == t AND NOT quantityTopNew(tk);
            
        quantityNew(TableColumn tc) <- IF statisticGrowType(tc) == StatisticGrowType.fixed THEN quantity(tc) ELSE NUMERIC[21,10](curRows(t)) / rows(t) * quantity(tc)
            WHERE table(tc) == t AND NOT quantityTopNew(tc) AND NOT return(tc) == 'BOOLEAN'; 
        quantityTopNew(TableColumn tc) <- IF statisticGrowType(tc) == StatisticGrowType.fixed THEN quantityTop(tc) ELSE NUMERIC[21,10](curRows(t)) / rows(t) * quantityTop(tc)
            WHERE table(tc) == t AND NOT quantityTopNew(tc) AND NOT return(tc) == 'BOOLEAN'; 
        
        quantity(TableKey tk) <- quantityNew(tk) WHERE table(tk) == t;
        quantityTop(TableKey tk) <- quantityTopNew(tk) WHERE table(tk) == t;
        
        FOR TableColumn tc = tableColumn(Property pt) AND table(tc) == t DO {
            quantity(pt) <- quantityNew(tc);
            quantityTop(pt) <- quantityTopNew(tc);
        }
            
        notNullQuantity(Property pt) <-  NUMERIC[21,10](curRows(t)) / rows(t) * notNullQuantity(pt)
             WHERE tableSID(pt) == sid(t) AND targetStatistic(t);
        
        rows(t) <- curRows(t);
        
        APPLY;
    }
} ASON CONTEXTMENU sid[Table];

loadCurRows 'Заполнить количество записей'(){
    EXTERNAL SQL 'LOCAL'
        EXEC 'SELECT pc.relname, reltuples::BIGINT FROM pg_class pc JOIN pg_tables pt ON pc.relname=pt.tablename AND pt.schemaname = \'public\''
        TO file;
    
    IMPORT TABLE FROM file() FIELDS STRING[100] table, LONG size DO {
        curRows(Table t) <- size WHERE lower(sid(t)) == table;
    }
}

setSkipStatistic 'Исключить из пересчета статистики'() {
    loadCurRows();
    notRecalculateStats(Table t) <-  rows(t) > 100000000 OR max(curRows(t), rows(t))/(OVERRIDE min(curRows(t), rows(t)), 1l) < 2;
}

needStats(Table t) = max(curRows(t), rows(t))/(OVERRIDE min(curRows(t), rows(t)), 1) >= 5;
backgroundRows(Table t) = IF needStats(t) THEN RGB (51, 153, 51) ELSE RGB (198, 236, 198);

EXTEND FORM tools
    OBJECTS t =  Table
    PROPERTIES (t) READONLY sid
    PROPERTIES (t) skipVacuum
    PROPERTIES (t) READONLY BACKGROUND backgroundData(t) dataSize, curDataSize
    PROPERTIES (t) READONLY BACKGROUND backgroundIndex(t) indexSize, curIndexSize, deleteIndexes CHANGEABLE 
    PROPERTIES (t) READONLY BACKGROUND backgroundRows(t) notRecalculateStats CHANGEABLE, rows, curRows, targetStatistic CHANGEABLE
    FILTERGROUP grow
        FILTER 'VACUUM' needVacuum(t)
        FILTER 'REINDEX' needReindex(t)
        FILTER 'Пересчет статистики' needStats(t)
        FILTER 'Любые' needVacuum(t) OR needReindex(t) OR needStats(t)
        
    OBJECTS tk=TableKey
    PROPERTIES(tk) READONLY class, classSID, name, nameStatisticGrowType CHANGEABLE, quantity, quantityTop
    FILTERS table(tk)==t

    OBJECTS tc=TableColumn
    PROPERTIES(tc) READONLY sid, caption, return, nameStatisticGrowType CHANGEABLE, quantity, quantityTop, notNullQuantity , percentNotNull
    FILTERS table(tc)==t
    
    OBJECTS i=Index
    PROPERTIES(i)  READONLY name, definition, isConstraint
    FILTERS table(i)==t
    
    PROPERTIES () loadCurSize, vacuumSize, vacuumCoeff, nameVacuumOrderType, smartVacuum, loadCurRows, countTreads, 
                  reindexConcurrently, skipExceptions, stopAfter
;

DESIGN tools{
    pane{
        NEW dbMain{
            caption = 'Таблицы';
            type = CONTAINERH;
            NEW dbLeft{
                NEW vacuum {
                    caption = 'Упаковка';
                    MOVE PROPERTY (loadCurSize());
                    MOVE PROPERTY (vacuumSize());
                    MOVE PROPERTY (vacuumCoeff());
                    MOVE PROPERTY (nameVacuumOrderType());
                    MOVE PROPERTY (countTreads());
                    MOVE PROPERTY (reindexConcurrently());
                    MOVE PROPERTY (skipExceptions());
                    MOVE PROPERTY (stopAfter());
                    MOVE PROPERTY (smartVacuum());
                }
                NEW stats{
                    caption = 'Статистика';
                    MOVE PROPERTY (loadCurRows());
                }
            }
            NEW dbRight{
                fill = 1;
                type = SPLITV;
                MOVE BOX (t);
                NEW dbColumns{
                    fill = 0.4;
                    type = TABBED;
                    MOVE BOX (tc);
                    MOVE BOX (tk);
                    MOVE BOX (i);
                }
            }
        }
    }
}

WHEN LOCAL SET(ACTIVE TAB tools.dbMain) DO {
    loadCurSize();
    loadCurRows();
}