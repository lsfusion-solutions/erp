MODULE FitCashRegister;

REQUIRE NativeMachinery, CashRegister, Store, ZReportDiscountCard, SkuRu, MachineryPriceTransactionStockTax;

NAMESPACE Fit;

idVat 'Код ставки' (NUMERIC[10,5] v) = CASE
    WHEN v = 20.0 THEN '01'
    WHEN v = 10.0 THEN '02'
;

loadDefaultCashRegisterModels() + {  EXEC loadDefaultCashRegisterModel('SPAR FIT', 'fit', 'lsf.Fit.Beta', NULL, TRUE, NULL, NULL ); };

isFit (CashRegisterModel m) = left(handler(m), 8) = 'lsf.Fit.';
isFit (GroupCashRegister g) = isFit(cashRegisterModel(g));
isFit (CashRegister cr) = isFit(groupCashRegister(cr));
isFit (Receipt r) = isFit(cashRegister(r));

haveFit (DepartmentStore d) = GROUP MAX isFit(GroupCashRegister g) IF stock(g) = d;

stringToGzip  INTERNAL 'lsfusion.erp.integration.fit.StringToGzip' (TEXT);

notResponcedTransaction() = GROUP LAST MachineryPriceTransaction t ORDER dateTime(t), t
    IF process(t) AND isFit(groupMachinery(t)) AND NOT dateTimeProcessing(t);

countActiveMachineries 'Кол-во оборудования в группе' (gm) =GROUP SUM 1 IF NOT inactive(Machinery m) BY groupMachinery(m);

WHEN SET (countSucceededMachineries(MachineryPriceTransaction t) == countActiveMachineries(groupMachinery(t))) AND isFit(groupMachinery(t)) DO {
    NEWSESSION {
        succeeded(t) <- TRUE;
        dateTimeSucceeded(t) <- currentDateTime();
    } 
}

returnExchange = DATA LOCAL BOOLEAN (CashRegister);

pathPut 'Путь выгрузки' (CashRegister cr) = CONCAT '', rtrim((OVERRIDE dataDirectory(cr) IF ignoreCashRegisterServerCashRegisterModel(groupCashRegister(cr)), directory(groupCashRegister(cr))), '/'), '/franprix/bck/out/';
pathGet 'Путь загрузки' (CashRegister cr) = CONCAT '', rtrim((OVERRIDE dataDirectory(cr) IF ignoreCashRegisterServerCashRegisterModel(groupCashRegister(cr)), directory(groupCashRegister(cr))), '/'), '/franprix/bck/in/';

fitErrorMessage (CashRegister cr, STRING message) = OVERRIDE System.messageCaughtException(), CONCAT ' ', 'fit', '(' + shortDescription(cr) + ')', ': ' + message;

put (CashRegister cr, STRING[8] name, TEXT t) {
    returnExchange(cr) <- TRUE;
    TRY {
        fileExists(pathPut(cr) + name +'.adr');
        IF NOT fileExists() THEN { 
            fileExists(pathPut(cr) + name + '.log');
            IF fileExists() THEN
                delete(pathPut(cr) + name + '.log');
            stringToFile(t, 'cp866', '');
            WRITE resultFile() TO CONCAT '', pathPut(cr), name + '.dat';
            stringToFile('Ok\n', 'cp866', '');
            WRITE resultFile() TO CONCAT '', pathPut(cr), name + '.adr';
            returnExchange(cr) <- NULL;
        } ELSE {
            System.messageCaughtException() <- fitErrorMessage(cr, 'One of previous transactions failed');
        }
    } CATCH {
        System.messageCaughtException() <- fitErrorMessage(cr, 'File exchange failed');   
    }
}

alpha 'Тип alpha' (STRING s, INTEGER i) = rpad(s, i, ' ');
char 'Тип char' (STRING s, INTEGER i) = lpad(s, i, '0');
charSpace 'Тип char (с пробелами)' (STRING s, INTEGER i) = lpad(s, i, ' ');
numeric 'Тип numeric' (INTEGER n, INTEGER i) = lpad(STRING (n), i, '0');      

pluString (MachineryPriceTransaction t, Barcode b) =
    charSpace(id(b), 16) +                      // 1. Код товара
    '001' +                                     // 2. Код группы
    (OVERRIDE idVat(VAT(t, b)), '03') +         // 3. Код налоговой ставки    
    alpha(name(t, b), 20) +                     // 4. Наименование товара
    numeric(INTEGER(price(t, b) * 100), 12) +   // 5. Цена товара
    '00' +                                      // 6.1 Время начала "Счастливого часа"
    '00' +                                      // 6.2 Время окончания "Счастливого часа"
    '00000' +                                   // 6.3 Множитель цены
    '0' +                                       // 6.4 Дополнительный признак
    currentTimeText() +                         // 6.5 Дата время формирования
    'A' +                                       // 7. Код движения
    (IF split(t, b) THEN '2' ELSE '0') +        // 8. Признак весового товара
    numeric(0, 11) +                            // 9. Количество
    '0' +                                       // 10. Код валюты
    '001' +                                     // 11. Секция
    '00' +                                      // 12. Код налога 1
    '00' +                                      // 13. Код налога 2
    '00' +                                      // 14. Код налога 3
    '00' +                                      // 15. Код налога 4
    '00' +                                      // 16. Код налога 5
    numeric(INTEGER(price(t, b) * 100), 12) +   // 17. Цена 1
    numeric(INTEGER(price(t, b) * 100), 12) +   // 18. Цена 2
    numeric(INTEGER(price(t, b) * 100), 12) +   // 19. Цена 3
    numeric(INTEGER(price(t, b) * 100), 12) +   // 20. Цена 4
    numeric(INTEGER(price(t, b) * 100), 12) +   // 21. Цена 5
    '000000000' +                               // 22. Абсолютная скидка
    '000000' +                                  // 23. Процентная скидки
    '000000000' +                               // 24. Количественный порог
    '0' +                                       // 25. Тип скидки
    '0' +                                       // 26. Признак флаерса товара
    '00000' +                                   // 27. Вес тары
    alpha(name(t, b), 60) +                     // 28. Наименование товара
    '0000' +                                    // 29. Время начала интервала
    '0000' +                                    // 30. Время окончания интервала
    '0' +                                       // 31. Самостоятельное подтверждение возраста
    '00' +                                      // 32. Минимальный возраст
    '0' +                                       // 33. Необходим вес
    '0' +                                       // 34. Необходимо количество
    '0' +                                       // 35. Необходима цена
    '0' +                                       // 36. Визуальное подтверждение
    '0' +                                       // 37. Признак ЕГАИС
    '0' +                                       // 38. Запрет ручного ввода количества
    alpha('', 3) +                              // 39. Код вида алкогольной продукции
    alpha('', 64) +                             // 40. Наименование товарной позиции
    alpha('', 7) +                              // 41. Крепость
    alpha('', 8) +                              // 42. Объем тары
    numeric(0, 3) +                             // 43. Количество товара в упаковке
    numeric(0, 3) +                             // 44. Код скидки скидочного штрих-кода
    alpha('', 12) +                             // 45. Код агента
    numeric(0, 12) +                            // 46. Минимальная цена
    alpha('', 22) +                             // 47. ТН ВЭД
    '0' +                                       // 48. Признак маркированной продукции
    '    ' +                                    // 49. Тип маркированной продукции
    numeric(INTEGER(trim(OVERRIDE sid(country(b)), sid(defaultCountry()))), 3) + // 50. Код страны происхождения
    numeric(0, 9) +                             // 51. Акциз
    numeric(0, 32) +                            // 52. Номер таможенной декларации
    '  ' +                                      // 53. Признак предмета расчета
    '  ' +                                      // 54. Признак способа расчета
    charSpace(trim(OVERRIDE id[Item](sku(b)), id(b)), 16) + // 55. Локальный код товара
    alpha('', 32) +                             // 56. Имя графического файла с изображением товара
    alpha('', 32) +                             // 57. Имя звукового файла с изображением товара
    alpha(STRING(measureQOC(sku(b))), 3) +      // 58. Мера количества предмета расчета
    numeric(0, 6) +                             // 59. Код уровня альтернативого классификатора
    '\r\n'
;

pluString (MachineryPriceTransaction t) = GROUP CONCAT pluString(t, Barcode b), '' IF in(t, b) ORDER b;

checkPut 'Проверить передачу' (CashRegister cr, STRING[8] name) {
    returnExchange(cr) <- TRUE;
    LOCAL firstLine = STRING ();
    LOCAL logExist = BOOLEAN ();
    TRY {
        fileExists(pathPut(cr) + name + '.log');
        IF fileExists() THEN { 
            READ pathPut(cr) + name + '.log' TO importFile;
            fileToString(importFile(), 'cp866');
            firstLine() <- getWord(resultString(), '\n', 1);
            returnExchange(cr) <- NOT getWord(firstLine(), ',', 1) = 'OK';
        } ELSE {
            returnExchange(cr) <- TRUE;
            resultString() <- fitErrorMessage(cr, 'One of previous transactions failed');
        }
    }
}

sendToFit (MachineryPriceTransaction t) {
    NEWSESSION {
        FOR isFit(CashRegister cr) AND NOT inactive(cr) AND NOT in(t, cr) DO {
            put(cr, 'plu', pluString(t));
            IF returnExchange(cr) THEN {
                addMachineryError(t);
            } ELSE {
                dateTimeProcessing(t) <- currentDateTime();
            }
            in (t, cr) <- NOT returnExchange(cr);
        }
        APPLY;
    }
    NEWSESSION {
        FOR in(t, CashRegister cr) AND NOT succeeded(cr, t) DO {
            checkPut(cr, 'plu');
            succeeded(cr, t) <- NOT returnExchange(cr);
            dateTimeSucceeded(cr, t) <- currentDateTime() IF NOT returnExchange(cr);
            IF returnExchange(cr) THEN
                FOR iterate(INTEGER i, 1, wordCount(resultString(), '\n')) DO {
                    addMachineryError(t, getWord(resultString(), '\n', i));
                } 
        }
    APPLY;
    }
}

succeeded(MachineryPriceTransaction t) <- TRUE WHEN SET (countSucceededMachineries(t) = countMachineries(groupMachinery(t)));
dateTimeSucceeded(MachineryPriceTransaction t) <- currentDateTime() WHEN SET (countSucceededMachineries(t) = countMachineries(groupMachinery(t))); 

sendMachineryPriceTransaction(MachineryPriceTransaction t) + {
    IF isFit(groupMachinery(t)) AND NOT canceled(t) THEN {
        sendToFit(t);
    }
}

isReceipt(STRING s) = left(s, 2) = '01' AND substr(s, 46, 2) < '03';

receiptString = DATA LOCAL STRING (INTEGER);
fitOverImport ABSTRACT LIST (CashRegister);
fitOverParse ABSTRACT LIST (CashRegister);

receiveFromFit (CashRegister cr) {
    TRY {
        fileExists(CONCAT '', pathPut(cr), 'spool.adr');
        IF NOT fileExists() THEN {
            NEWSESSION {
                listFiles(pathGet(cr));
                FOR ISTRING fn = fileName(INTEGER i) AND NOT fileIsDirectory(i) AND [FORMULA NULL BOOLEAN PG 'CASE WHEN $1 ~ \'ll[0-9]{6}\\.[0-9]{3}\' THEN 1 ELSE NULL END'](fn) DO {
                    READ pathGet(cr) + fn TO importFile;
                    IMPORT CSV NOHEADER CHARSET 'cp866' FROM importFile() TO receiptString;
                    fitOverImport(cr);
                    FOR INTEGER line = [GROUP MIN INTEGER k IF left(receiptString(k), 2) = '01' BY substr(receiptString(k), 15, 12)](STRING card) AND NOT card = '000000000000' AND NOT discountNumber(STRING[48](card)) DO NEW c = DiscountCard {
                        number(c) <- STRING[48](card);
                    }
                    FOR INTEGER line = [GROUP MIN INTEGER k IF left(receiptString(k), 2) = '01' BY substr(receiptString(k), 92, 4)](STRING str) AND NOT zReport(STRING[100](str  + lpad(STRING(cr), 18, '0'))) DO NEW z = ZReport {
                        id(z) <- STRING[100](str  + lpad(STRING(cr), 18, '0'));
                        number(z) <- STRING[48](lpad(STRING(INTEGER(str) (+) 1), 4, '0'));
                        cashRegister(z) <- cr;
                        date(z) <- toDateFormat(substr(receiptString(line), 96, 8), 'DDMMYYYY');
                        time(z) <- TIME (toDateTimeFormat(substr(receiptString(line), 48, 5), 'HH24:MI'));
                        isPosted(z) <- TRUE;
                    }
                    FOR STRING str = receiptString(INTEGER j) AND isReceipt(str) AND NOT receipt(substr(str, 92, 4) + lpad(STRING(cr), 18, '0') + substr(str, 3, 12)) DO NEW r = Receipt {
                        employee(r) <- OVERRIDE employee(substr(str, 40, 4)), employee(STRING[4](INTEGER(substr(str, 40, 4))));
                        number(r) <- INTEGER(substr(str, 56, 12));
                        id(r) <- STRING[100](substr(str, 92, 4) + lpad(STRING(cr), 18, '0') + substr(str, 3, 12));
                        zReport(r) <- zReport(substr(str, 92, 4) + lpad(STRING(cr), 18, '0'));
                    }
                    FOR STRING str = receiptString(INTEGER j) AND isReceipt(str) AND Receipt r = receipt(substr(str, 92, 4) + lpad(STRING(cr), 18, '0') + substr(str, 3, 12)) DO {
                        date(r) <- toDateFormat(substr(str, 96, 8), 'DDMMYYYY');
                        time(r) <- TIME (toDateTimeFormat(substr(str, 48, 5), 'HH24:MI'));
                        discountCard(r) <- discountNumber(STRING[48](substr(str, 15, 12)));
                    }
                    
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '12' AND substr(srl, 77, 1) = '+' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        Receipt r = receipt(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12))) AND
                        NOT receiptDetail(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'))) AS ReceiptSaleDetail
                            ORDER j DO NEW d = ReceiptSaleDetail {
                                id(d) <- STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'));
                                receipt(d) <- r;
                    }
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '12' AND substr(srl, 77, 1) = '+' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        ReceiptSaleDetail d = receiptDetail(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'))) AS ReceiptSaleDetail DO {
                            idBarcode(d) <- STRING[15](ltrim(substr(srl, 5, 16)));
                            sku(d) <- sku(barcode(STRING[15](ltrim(substr(srl, 5, 16)))));
                            price(d) <- NUMERIC[16,4](NUMERIC(substr(srl, 85, 14)) / 100);
                            quantity(d) <- NUMERIC[16,5](NUMERIC(substr(srl, 78, 7)) / 1000);
                            discountSum(d) <- NUMERIC[18,4](-NUMERIC(substr(srl, 40, 11)) / 100);
                    }
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '12' AND substr(srl, 77, 1) = '-' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        Receipt r = receipt(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12))) AND
                        NOT receiptDetail(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'))) AS ReceiptReturnDetail
                            ORDER j DO NEW d = ReceiptReturnDetail {
                                id(d) <- STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'));
                                receipt(d) <- r;
                    }
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '12' AND substr(srl, 77, 1) = '-' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        ReceiptReturnDetail d = receiptDetail(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'))) AS ReceiptReturnDetail DO {
                            idBarcode(d) <- STRING[15](ltrim(substr(srl, 5, 16)));
                            sku(d) <- sku(barcode(STRING[15](ltrim(substr(srl, 5, 16)))));
                            price(d) <- NUMERIC[16,4](abs(NUMERIC(substr(srl, 85, 14)) / 100));
                            quantity(d) <- NUMERIC[16,5](NUMERIC(substr(srl, 78, 7)) / 1000);
                            discountSum(d) <- NUMERIC[18,4](-NUMERIC(substr(srl, 40, 11)) / 100);
                    }
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '04' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        Receipt r = receipt(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12))) AND
                        NOT payment(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0')))
                            ORDER j DO NEW p = Payment {
                                id(p) <- STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'));
                                receipt(p) <- r;
                    }
                    FOR STRING srl = receiptString(INTEGER j) AND left(srl, 2) = '04' AND
                        INTEGER sl = (GROUP MAX INTEGER l IF left(receiptString(l), 2) = '01' AND l < j) AND
                        STRING rs = receiptString(sl) AND
                        Payment p =  payment(STRING[100](substr(rs, 92, 4) + lpad(STRING(cr), 18, '0') + substr(rs, 3, 12) + lpad(STRING(j (-) sl), 10, '0'))) DO {
                            sum(p) <- NUMERIC[18,4](NUMERIC(substr(srl, 85, 14)) / 100);
                            paymentType(p) <- IF substr(srl, 3, 2) = '13' THEN typePaymentSID('cash') ELSE typePaymentSID('card');
                    }
                    fitOverParse(cr);
                }
                APPLY NESTED LOCAL;
                LOCAL succeessDir = STRING ();
                IF NOT System.canceled() THEN {
                    succeessDir() <- pathGet(cr) + 'succeess-' + currentTimeText(); 
                    mkdir(succeessDir());    
                    FOR STRING fn = fileName(INTEGER i) AND NOT fileIsDirectory(i) AND NOT System.canceled() AND [FORMULA NULL BOOLEAN PG 'CASE WHEN $1 ~ \'ll[0-9]{6}\\.[0-9]{3}\' THEN 1 ELSE NULL END'](fn) DO {
                        move(pathGet(cr) + fn, succeessDir() + '/' + fn);
                    }
                }
            }
        }
        IF NOT System.canceled() THEN {
            stringToFile('Ok\n', 'cp866', '');
            WRITE resultFile() TO CONCAT '', pathPut(cr), 'spool.adr';
        }
    } CATCH {
        MESSAGE fitErrorMessage(cr, System.messageCaughtException());
    }
}

receiveGroupMachinery(GroupMachinery g) + {
    IF isFit(g) THEN {
        FOR groupCashRegister(CashRegister cr) = g AND NOT inactive(cr) AND NOT disableSales(cr) DO {
            receiveFromFit(cr);
        } 
    }
}

dataInactive 'Неактивна' = DATA BOOLEAN (CashRegister);
overInactive (CashRegister cr) += dataInactive(cr);

EXTEND FORM cashRegister
    PROPERTIES (c) SHOWIF isFit(c) AND ignoreCashRegisterServerCashRegisterModel(groupCashRegister(c)) dataInactive AFTER disableSales(c)
;

EXTEND FORM groupCashRegister
    PROPERTIES (c) SHOWIF isFit(c) AND ignoreCashRegisterServerCashRegisterModel(groupCashRegister(c)) dataInactive AFTER disableSales(c)
;

EXTEND FORM groupsCashRegister
    PROPERTIES (c) READONLY SHOWIF isFit(c) AND ignoreCashRegisterServerCashRegisterModel(groupCashRegister(c)) inactive AFTER disableSales(c)
;

EXTEND FORM machineryPriceTransaction
    PROPERTIES (m) READONLY SHOWIF isFit(m) AND ignoreCashRegisterServerCashRegisterModel(groupCashRegister(m)) inactive
;