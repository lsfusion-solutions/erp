MODULE EDocumentTopBy;

REQUIRE EDocumentEDSTopBy, CTT;

NAMESPACE EDI;

confirmNotFoundDocuments 'Подтверждать ответы по которым не найден документ' = DATA BOOLEAN ();

overReceiveBlrapn(INTEGER i, STRING[100] login, STRING[100] password, TEXT url, STRING[100] archiveDir, BOOLEAN disableConfirmation, STRING[100] provider) + {
    IF (lower(blrapnReferenceDocumentType()) == 'blrapn' AND eDocumentNumberDate(blrapnDeliveryNoteId(),blrapnDeliveryNoteDate()))
       OR lower(blrapnReferenceDocumentType()) == 'blrdoc' THEN {
        LOCAL eDocument = EDocument();
        eDocument() <- OVERRIDE eDocument(blrapnShipper() + '/' + blrapnReferenceDocumentId()), eDocumentNumberDate(blrapnDeliveryNoteId(),blrapnDeliveryNoteDate());
        IF eDocument() THEN {
            NEWSESSION NESTED LOCAL {
                IF NOT eDocumentMessage(eDocument(), blrapnDocumentNumber(), EInvoiceMessageKind.in) THEN NEW m = EDocumentMessage {
                    number(m) <- blrapnDocumentNumber();
                    eDocument(m) <- eDocument();
                    kind(m) <- EInvoiceMessageKind.in;
                }
                FOR EDocumentMessage m == eDocumentMessage(eDocument(), blrapnDocumentNumber(), EInvoiceMessageKind.in) DO {
                    dateTime(m) <- blrapnDateTime();
                    code(m) <- blrapnCode();
                    description(m) <- OVERRIDE blrapnDescription(), description(blrapnCode());
                    type(m) <- CASE
                        WHEN lower(blrapnReferenceDocumentType()) == 'blrapn' THEN EInvoiceMessageType.blrapn_blrapn
                        WHEN lower(blrapnReferenceDocumentType()) == 'blrdoc' THEN EInvoiceMessageType.blrapn_blrdoc;
                    XMLPath(m) <- archiveDir + '/received/' + toChar(currentDate(),'yyyyMMdd') + '/' + id(i);
                    APPLY NESTED LOCAL;
                    IF canceled() THEN {
                        logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' failed: ' + applyMessage());
                        documentMessagesFailed() <- documentMessagesFailed() + 1;
                    } ELSE {
                        IF NOT disableConfirmation THEN {
                            LOCAL xml = XMLFILE();
                            EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO xml;
                            sendRequestEDI(url, xml());
                            logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                            importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                            IF requestError() THEN {
                                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                                MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                            } ELSE {
                                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                            }
                        }
                        logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' succeeded');
                        documentMessagesSucceeded() <- documentMessagesSucceeded() + 1;
                    }
                }
            }
        } ELSE {
            IF confirmNotFoundDocuments() THEN {
                IF NOT disableConfirmation THEN {
                    LOCAL xml = XMLFILE();
                    EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO xml;
                    sendRequestEDI(url, xml());
                    logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                    importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                    IF requestError() THEN {
                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                        MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                    } ELSE {
                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                    }
                    messagesConfirmed() <- messagesConfirmed() + 1;
                }
            } ELSE {
                
            }
            logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' failed: ' + 'EDocument ' + (OVERRIDE documentNumber(), 'NULL') + ' not found');
            documentMessagesFailed() <- documentMessagesFailed() + 1;
        }
        RETURN;
    }
}

//Для документов пока дублируем системные сообщения. Поскольку есть apn, возможно есть смысл тоже убрать
overReceiveSystemMessage(INTEGER i, STRING[100] login, STRING[100] password, TEXT url, STRING[100] archiveDir, BOOLEAN disableConfirmation, STRING[100] provider) + {
    IF documentType() == 'BLRDOC' THEN {
        LOCAL eDocument = EDocument();
        //провайдер не присылает системный номер документа в systemMessage а юридический номер не уникальный
        eDocument() <- GROUP MAX EDocument e IF number(e) == documentNumber() AND date(e) == DATE(documentDate()) AND glnReceiver(e) == messageBuyerGLN();
        IF eDocument() THEN {
            NEWSESSION NESTED LOCAL {
                IF NOT eDocumentMessage(eDocument(), 'm' + messageDocumentNumber(), EInvoiceMessageKind.in) THEN NEW m = EDocumentMessage {
                    number(m) <- 'm' + messageDocumentNumber();
                    eDocument(m) <- eDocument();
                    kind(m) <- EInvoiceMessageKind.in;
                }
                FOR EDocumentMessage m == eDocumentMessage(eDocument(), 'm' + messageDocumentNumber(), EInvoiceMessageKind.in) DO {
                    dateTime(m) <- messageDocumentDate();
                    code(m) <- code();
                    description(m) <- OVERRIDE description(), description(code());
                    type(m) <- EInvoiceMessageType.systemmessage_blrdoc;
                    XMLPath(m) <- archiveDir + '/received/' + toChar(currentDate(),'yyyyMMdd') + '/' + id(i);
                    APPLY NESTED LOCAL;
                    IF canceled() THEN {
                        logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' failed: ' + applyMessage());
                        documentMessagesFailed() <- documentMessagesFailed() + 1;
                    } ELSE {
                        IF NOT disableConfirmation THEN {
                            LOCAL xml = XMLFILE();
                            EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO xml;
                            sendRequestEDI(url, xml());
                            logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                            importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                            IF requestError() THEN {
                                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                                MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                            } ELSE {
                                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                            }
                        }
                        logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' succeeded');
                        documentMessagesSucceeded() <- documentMessagesSucceeded() + 1;
                    }
                }
            }
        } ELSE {
            IF confirmNotFoundDocuments() THEN {
                IF NOT disableConfirmation THEN {
                    LOCAL xml = XMLFILE();
                    EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO xml;
                    sendRequestEDI(url, xml());
                    logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                    importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                    IF requestError() THEN {
                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                        MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                    } ELSE {
                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                    }
                    messagesConfirmed() <- messagesConfirmed() + 1;
                }
            } ELSE {
                
            }
            logToFile('edi', provider + ' (' + login + ') Import EDocumentMessage ' + id(i) + ' failed: ' + 'EDocument ' + (OVERRIDE documentNumber(), 'NULL') + ' not found');
            documentMessagesFailed() <- documentMessagesFailed() + 1;
        }
        RETURN;
    }
    IF documentType() == 'BLRAPN' OR documentType() == 'SYSTEMMESSAGE' THEN {
        logToFile('edi', provider + ' (' + login + ') Parse Document Message ' + id(i) + ' skipped for documentType ' + documentType());
        IF NOT disableConfirmation THEN {
            LOCAL xml = XMLFILE();
            EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO xml;
            sendRequestEDI(url, xml());
            logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
            importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
            IF requestError() THEN {
                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
            }
            messagesConfirmed() <- messagesConfirmed() + 1;
        }
        RETURN;
    }
}

//GROUP messageHeader EXTID 'MessageHeader';
blrdocMessageID = DATA LOCAL NESTED STRING[35]();
blrdocMsgDateTime = DATA LOCAL NESTED DATETIME();
blrdocMsgReceiverID = DATA LOCAL NESTED STRING[13]();
blrdocUserID = DATA LOCAL NESTED STRING[35]();
GROUP document EXTID 'Document';
blrdocDocumentID = DATA LOCAL NESTED STRING[35]();
blrdocCreationDateTime = DATA LOCAL NESTED DATETIME();
blrdocFunctionCode = DATA LOCAL NESTED STRING[3]();
blrdocNumber = DATA LOCAL NESTED STRING[25]();
blrdocDate = DATA LOCAL NESTED DATE();
blrdocType = DATA LOCAL NESTED STRING[255]();
blrdocDocument = DATA LOCAL NESTED RAWFILE();
blrdocDocumentName = DATA LOCAL NESTED STRING[255]();
blrdocDocumentRoute = DATA LOCAL NESTED STRING[1]();
GROUP blrdocSender EXTID 'Sender' : document;
blrdocSenderGLN = DATA LOCAL NESTED STRING[13]();
GROUP blrdocReceiver EXTID 'Receiver' : document;
blrdocReceiverGLN = DATA LOCAL NESTED STRING[13]();

FORM blrdoc
    PROPERTIES IN messageHeader blrdocMessageID() EXTID 'MessageID',
                                blrdocMsgDateTime() EXTID 'MsgDateTime',
                                blrdocMsgReceiverID() EXTID 'MsgReceiverID',
                                blrdocUserID() EXTID 'UserID'
    PROPERTIES IN document blrdocDocumentID() EXTID 'DocumentID',
                           blrdocCreationDateTime() EXTID 'CreationDateTime',
                           blrdocFunctionCode() EXTID 'FunctionCode',
                           blrdocNumber() EXTID 'eDocumentNumber',
                           blrdocDate() EXTID 'eDocumentDate',
                           blrdocType() EXTID 'eDocumentType',
                           blrdocDocument() EXTID 'eDocument',
                           blrdocDocumentName() EXTID 'eDocumentName',
                           blrdocDocumentRoute() EXTID 'eDocumentRoute'
    PROPERTIES IN blrdocSender blrdocSenderGLN() EXTID 'GLN'
    PROPERTIES IN blrdocReceiver blrdocReceiverGLN() EXTID 'GLN'
;

overImportBlrdoc ABSTRACT ();
skipBlrdoc = DATA LOCAL NESTED BOOLEAN();
overCreateEDocumentBlrdoc ABSTRACT LIST (EDocument);

overReceiveMessages(INTEGER i, STRING[100] login, STRING[100] password, TEXT url, STRING[100] archiveDir, BOOLEAN disableConfirmation, STRING[100] provider) + {
    IF lower(documentType(i)) == 'blrdoc' AND provider == 'TopBy' THEN {
        TRY {
            IMPORT blrdoc XML FROM data(i);
            skipBlrdoc() <- NULL;
            overImportBlrdoc();
            IF NOT skipBlrdoc() THEN {
                NEWSESSION NESTED LOCAL {
                    LOCAL isCancel = BOOLEAN();
                    isCancel() <- TRUE IF blrdocFunctionCode() == '1';
                    FOR EDocument ed = eDocument(blrdocSenderGLN() + '/' + blrdocDocumentID()) DO {
                        importedSender(ed) <- TRUE WHERE blrdocMsgReceiverID() == blrdocSenderGLN();
                        importedReceiver(ed) <- TRUE WHERE blrdocMsgReceiverID() == blrdocReceiverGLN();
                        IF isCancel() THEN {
                            isCancel(ed) <- TRUE;
                            numberSenderCancel(ed) <- blrdocMessageID();
                            dateSenderCancel(ed) <- blrdocMsgDateTime();
                            exportedBlrapnReceiver(ed) <- NULL;
                        } ELSE {
                            xmlFile(ed) <- data(i);
                            numberSender(ed) <- blrdocMessageID();
                            dateSender(ed) <- blrdocMsgDateTime();
                        }
                    } ELSE NEW ed = EDocument {
                        importedSender(ed) <- TRUE WHERE blrdocMsgReceiverID() == blrdocSenderGLN();
                        importedReceiver(ed) <- TRUE WHERE blrdocMsgReceiverID() == blrdocReceiverGLN();
                        id(ed) <- blrdocSenderGLN() + '/' + blrdocDocumentID();
                        xmlFile(ed) <- data(i) IF NOT isCancel();
                        numberSender(ed) <- blrdocMessageID() IF NOT isCancel();
                        dateSender(ed) <- blrdocMsgDateTime() IF NOT isCancel();
                        numberSenderCancel(ed) <- blrdocMessageID() IF isCancel();
                        dateSenderCancel(ed) <- blrdocMsgDateTime() IF isCancel();
                        documentID(ed) <- blrdocDocumentID();
                        creationDateTime(ed) <- blrdocCreationDateTime();
                        number(ed) <- blrdocNumber();
                        date(ed) <- blrdocDate();
                        type(ed) <- blrdocType();
                        file(ed) <- blrdocDocument();
                        name(ed) <- blrdocDocumentName();
                        route(ed) <- OVERRIDE (GROUP MAX EDocumentRoute r IF id(r) == blrdocDocumentRoute()), EDocumentRoute.route0;
                        isCancel(ed) <- isCancel();
                        sender(ed) <- legalEntityGLN(blrdocSenderGLN());
                        receiver(ed) <- legalEntityGLN(blrdocReceiverGLN());
                        overCreateEDocumentBlrdoc(ed);
                        XMLPath(ed) <- archiveDir + '/received/' + toChar(currentDate(),'yyyyMMdd') + '/' + id(i);
                    }
                    FOR EDocument ed = eDocument(blrdocSenderGLN() + '/' + blrdocDocumentID()) DO {
                        IF NOT eDocumentMessage(ed, 'doc' + blrdocMessageID(), EInvoiceMessageKind.in) THEN NEW m = EDocumentMessage {
                            number(m) <- 'doc' + blrdocMessageID();
                            eDocument(m) <- ed;
                            kind(m) <- EInvoiceMessageKind.in;
                        }
                        FOR EDocumentMessage m == eDocumentMessage(ed, 'doc' + blrdocMessageID(), EInvoiceMessageKind.in) DO {
                            dateTime(m) <- blrdocMsgDateTime();
                            code(m) <- blrdocFunctionCode();
                            type(m) <- EInvoiceMessageType.blrdoc;
                            XMLPath(m) <- archiveDir + '/received/' + toChar(currentDate(),'yyyyMMdd') + '/' + id(i);
                        }
                    }
                    APPLY NESTED LOCAL;
                    IF canceled() THEN {
                        logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' failed: ' + applyMessage());
                        eDocumentsFailed() <- eDocumentsFailed() + 1;
                    } ELSE {
                        FOR EDocument ed == eDocument(blrdocSenderGLN() + '/' + blrdocDocumentID()) DO {
                            IF NOT disableAutoBlrapn() AND isCancel() AND blrdocMsgReceiverID() == blrdocReceiverGLN() THEN { //подтверждаем только отмену
                                LOCAL contentSubXML = FILE();
                                blrapnDateTime() <- currentDateTimeMillis();
                                blrapnMsgSender() <- glnReceiver(ed);
                                blrapnMsgReceiver() <- glnSender(ed);
                                //blrapnUserID() <- userIDSupplierStock(ed);
                                blrapnDeliveryNoteId() <- number(ed);
                                blrapnDeliveryNoteDate() <- date(ed);
                                blrapnReferenceDocumentType() <- 'BLRDOC';
                                blrapnReferenceDocumentId() <- blrdocDocumentID();
                                blrapnReferenceDocumentDate() <- blrdocCreationDateTime();
                                blrapnShipper() <- glnSender(ed);
                                blrapnReceiver() <- glnReceiver(ed);
                                blrapnCode() <- '2650';
                                blrapnDescription() <- NULL;
                                toMilliseconds(blrapnDateTime());
                                EXPORT exportBlrapnNew XML TO contentSubXML;
                                IF archiveDir THEN {
                                    TRY{ mkdir(archiveDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd')); }
                                    WRITE contentSubXML() TO archiveDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                                }
                                IF EDSServiceReceiver(provider,ed) THEN {
                                    name() <- 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                                    documentType() <- 'BLRAPN';
                                    getSignedDocumentReceiver(provider, ed, contentSubXML(), NULL);
                                    IF signError() THEN {
                                        logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' error: BLRAPN ' + documentID(ed) + ' не подписан. Ошибка: ' + signError());
                                    }
                                    ELSE IF signResult() THEN {
                                        LOCAL ixml = XMLFILE();
                                        envelopeLogin() <- login;
                                        envelopePassword() <- password;
                                        envelopeFilename() <- CONCAT '', 'document', documentID(ed);
                                        envelopeDocumentDate() <- blrapnDateTime();
                                        envelopeDocumentNumber() <- documentID(ed);
                                        envelopeSender() <- glnReceiver(ed);
                                        envelopeReceiver() <- glnSender(ed);
                                        //envelopeDeliveryPoint() <- glnSender(ed);
                                        envelopeDocumentType() <- 'BLRAPN';                                        
                                        envelopeContent() <- signResult();
                                        EXPORT envelope XML TO ixml;
                                        sendRequestEDI(url, ixml());
                                        logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) +' request sent');
                                        importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'SendDocumentResponse');
                                        IF requestError() THEN {
                                            logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) + ': ' + requestError());
                                            MESSAGE provider + ' (' + login + ') Извещение о прочтении отмены документа ' + documentID(ed) + ' не выгружено: ' + requestError() NOWAIT;
                                        } ELSE {
                                            logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) + ' request succeeded');
                                            IF NOT disableConfirmation THEN {
                                                LOCAL cxml = XMLFILE();
                                                EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO cxml;
                                                sendRequestEDI(url, cxml());
                                                logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                                                importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                                                IF requestError() THEN {
                                                    logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                                                    MESSAGE  provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                                                } ELSE {
                                                    logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                                                }
                                            }
                                            logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' succeeded');
                                            eDocumentsSucceeded() <- eDocumentsSucceeded() + 1;
                                            NEWSESSION NESTED LOCAL {
                                                exportedBlrapnReceiver(ed) <- TRUE;
                                                NEW em = EDocumentMessage {
                                                    number(em) <- STRING[35](resultMilliseconds());
                                                    eDocument(em) <- ed;
                                                    dateTime(em) <- toDateTimeFormat(toChar(blrapnDateTime(),'yyyy-MM-ddThh24:mi:ss'),'yyyy-MM-ddThh24:mi:ss');
                                                    code(em) <- blrapnCode();
                                                    kind(em) <- EInvoiceMessageKind.out;
                                                    type(em) <- EInvoiceMessageType.blrapn_blrdoc;
                                                    XMLPath(em) <- archiveDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                                                }
                                                APPLY NESTED LOCAL;
                                            }
                                        }
                                    }
                                } ELSE {
                                    logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' error: не заданы параметры EDSService');
                                }
                            } ELSE {
                                IF NOT disableConfirmation THEN {
                                    LOCAL cxml = XMLFILE();
                                    EXPORT confirmDocument OBJECTS login = login, password = password, documentId = id(i) XML TO cxml;
                                    sendRequestEDI(url, cxml());
                                    logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request sent');
                                    importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'ConfirmDocumentReceivedResponse');
                                    IF requestError() THEN {
                                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': ' + requestError());
                                        MESSAGE provider + ' (' + login + ') Документ ' + id(i) + ' не помечен как обработанный: ' + requestError() NOWAIT;
                                    } ELSE {
                                        logToFile('edi', provider + ' (' + login + ') ConfirmDocumentReceived document ' + id(i) + ': request succeeded');
                                    }
                                }
                                logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' succeeded');
                                eDocumentsSucceeded() <- eDocumentsSucceeded() + 1;
                            }
                        }
                    }  
                }
            }  ELSE {
                logToFile('edi', provider + ' (' + login + ') Import EDocument ' + id(i) + ' skipped: ' + skipBlrdoc());
            }
        } CATCH {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') Parse EDocument ' + id(i) + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE  'Ошибка при импорте документа ' + id(i) +'. Обратитесь к администратору' NOWAIT;
            eDocumentsFailed() <- eDocumentsFailed() + 1;
        }
    }
}


exportBlrdocDateTime = DATA LOCAL NESTED DATETIME();

GROUP sender EXTID 'Sender';
GROUP receiver EXTID 'Receiver';
GROUP eDocument EXTID 'eDocument';

hideMessageHeaderBlrdoc = DATA LOCAL BOOLEAN ();

FORM exportBlrdoc FORMEXTID 'BLRDOC'
    PROPERTIES ATTR ='0.1' IF NOT hideMessageHeaderBlrdoc() EXTID 'version'
    OBJECTS ed = EDocument PANEL
    
    OBJECTS edh = EDocument EXTID 'MessageHeader'
    FILTERS (edh == ed AND NOT hideMessageHeaderBlrdoc()) OR NOT edh IS EDocument
    PROPERTIES DRAW edh messageId = resultMilliseconds() EXTID 'MessageID',
                        msgDateTime = toChar(exportBlrdocDateTime(),'YYYYMMDDHH24MISS') EXTID 'MsgDateTime',
                        messageType = 'BLRDOC' EXTID 'MessageType',
                        glnSender(edh) EXTID 'MsgSenderID',
                        glnReceiver(edh) EXTID 'MsgReceiverID'//,
                        //userIDCustomerStock(eih) EXTID 'UserID',
                        //testIndicator = IF isTest(edh) THEN '1' EXTID 'TestIndicator'
    
    OBJECTS edd = EDocument EXTID 'Document'
    FILTERS edd == ed
    PROPERTIES DRAW edd documentID = (OVERRIDE documentID(edd), STRING[35](resultMilliseconds())) EXTID 'DocumentID',
                        creationDateTime = toChar((OVERRIDE creationDateTime(edd) IF NOT isCancel(edd), exportBlrdocDateTime()),'YYYYMMDDHH24MISS') EXTID 'CreationDateTime',
                        functionCode = (IF isCancel(edd) THEN '1' ELSE '9') EXTID 'FunctionCode',
                        number(edd) EXTID 'eDocumentNumber',
                        date = toChar(date(edd),'YYYYMMDD') EXTID 'eDocumentDate',
                        type = (OVERRIDE type(edd), 'ORIGINAL') EXTID 'eDocumentType'
    PROPERTIES DRAW edd IN sender glnSender(edd) EXTID 'GLN',
                                  nameSender(edd) EXTID 'Name',
                                  addressSender(edd) EXTID 'Address',
                                  unpSender(edd) EXTID 'VATRegistrationNumber'
    PROPERTIES DRAW edd IN receiver glnReceiver(edd) EXTID 'GLN',
                                    nameReceiver(edd) EXTID 'Name',
                                    addressReceiver(edd) EXTID 'Address',
                                    unpReceiver(edd) EXTID 'VATRegistrationNumber'
    PROPERTIES DRAW edd IN eDocument file(edd) EXTID 'eDocumentFile',
                                     name(edd) EXTID 'eDocumentName'
    PROPERTIES DRAW edd route = OVERRIDE idRoute(edd), '0' EXTID 'eDocumentRoute'
;

signAndSendSenderEDocument (EDocument ed, STRING[100] login, STRING[100] password, TEXT url, STRING[100] outputDir , STRING[100] provider) {
    checkIsServer();
    IF isServer() THEN {
        TRY {
            IF login AND password THEN {
                IF EDSServiceSender(provider,ed) THEN {
                    LOCAL error = TEXT();
                    error() <- '';
                    IF NOT length(glnSender(ed)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(ed), documentID(ed), '') + ': Не заполнено поле \'GLN отправителя\'\n';
                    IF NOT length(glnReceiver(ed)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(ed), documentID(ed), '') + ': Не заполнено поле \'GLN получателя\'\n';
                    IF NOT length(number(ed)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(ed), documentID(ed), '') + ': Не заполнено поле \'Номер электронного документа (юридический)\'\n';
                    IF NOT date(ed) THEN error() <- error() + 'EDocument ' + (OVERRIDE number(ed), documentID(ed), '') + ': Не заполнено поле \'Дата электронного документа (юридический)\'\n';
                    IF NOT length(name(ed)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(ed), documentID(ed), '') + ': Не заполнено поле \'Имя файла\'\n';
                    
                    IF error() == '' THEN {
                        LOCAL contentSubXML = FILE();
                        exportBlrdocDateTime() <- currentDateTimeMillis();
                        toMilliseconds(exportBlrdocDateTime());
                        EXPORT exportBlrdoc OBJECTS ed = ed XML TO contentSubXML;
                        
                        name() <- 'blrdoc-' + toChar(exportBlrdocDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                        documentType() <- 'BLRDOC';
                        IF outputDir THEN {
                            TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd')); }
                            WRITE contentSubXML() TO outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + name();
                        }
                        
                        IF route(ed) == EDocumentRoute.route2 THEN {
                            fileToString(contentSubXML());
                            encodeBase64(resultString());
                            signResult() <- encodedBase64();
                        } ELSE {
                            getSignedDocumentSender(provider, ed, contentSubXML(), TRUE);
                            IF signError() THEN {
                                logToFile('edi', provider + ' (' + login + ') SendEDocument error: BLRDOC ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError());
                                MESSAGE provider + ' (' + login + ') Документ не выгружен: BLRDOC ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                            }
                        }
                        IF signResult() THEN {
                            LOCAL ixml = XMLFILE();
                            envelopeLogin() <- login;
                            envelopePassword() <- password;
                            envelopeFilename() <- CONCAT '', 'document', (OVERRIDE documentID(ed), STRING[35](resultMilliseconds()));
                            envelopeDocumentDate() <- (OVERRIDE creationDateTime(ed), exportBlrdocDateTime());
                            envelopeDocumentNumber() <- (OVERRIDE documentID(ed), STRING[35](resultMilliseconds()));
                            envelopeSender() <- glnSender(ed);
                            envelopeReceiver() <- glnReceiver(ed);
                            //envelopeDeliveryPoint() <- glnReceiver(ed);
                            envelopeDocumentType() <- 'BLRDOC';
                            envelopeContent() <- signResult();
                            EXPORT envelope XML TO ixml;
                            sendRequestEDI(url, ixml());
                            logToFile('edi', provider + ' (' + login + ') SendEDocument ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) +' request sent');
                            importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'SendDocumentResponse');
                            IF requestError() THEN {
                                logToFile('edi', provider + ' (' + login + ') SendEDocument ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + ': ' + requestError());
                                MESSAGE provider + ' (' + login + ') Документ ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + ' не выгружен: ' + requestError() NOWAIT;
                            } ELSE {
                                logToFile('edi', provider + ' (' + login + ') SendEDocument ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + ' request succeeded');
                                MESSAGE provider + ' (' + login + ') Документ ' + (OVERRIDE number(ed), documentID(ed), STRING[35](resultMilliseconds())) + (IF isCancel(ed) THEN ' (отмена)' ELSE '') + ' выгружен' NOWAIT;
                                //NEWSESSION NESTED LOCAL {
                                    exportedSender(ed) <- TRUE;
                                    documentID(ed) <- STRING[35](resultMilliseconds()) WHERE NOT documentID(ed);
                                    creationDateTime(ed) <- exportBlrdocDateTime() WHERE NOT creationDateTime(ed);
                                    id(ed) <- (glnSender(ed) + '/' + documentID(ed)) WHERE NOT id(ed);
                                    IF isCancel(ed) THEN {
                                        numberSenderCancel(ed) <- STRING[35](resultMilliseconds());
                                        dateSenderCancel(ed) <- exportBlrdocDateTime();
                                    } ELSE {
                                        numberSender(ed) <- STRING[35](resultMilliseconds());
                                        dateSender(ed) <- exportBlrdocDateTime();
                                    }
                                    NEW em = EDocumentMessage {
                                        number(em) <- 'doc' + STRING[35](resultMilliseconds());
                                        eDocument(em) <- ed;
                                        dateTime(em) <- toDateTimeFormat(toChar(exportBlrdocDateTime(),'yyyy-MM-ddThh24:mi:ss'),'yyyy-MM-ddThh24:mi:ss');
                                        code(em) <- (IF isCancel(ed) THEN '1' ELSE '9');
                                        kind(em) <- EInvoiceMessageKind.out;
                                        type(em) <- EInvoiceMessageType.blrdoc;
                                        XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + name();
                                    }
                                    APPLY NESTED LOCAL;
                                //}
                            }
                        }
                    } ELSE {
                        logToFile('edi', provider + ' (' + login + ') SendEDocument: Не все поля заполнены. ' + error());
                        MESSAGE provider + ' (' + login + ') Документ не выгружен: Не все поля заполнены ' + error() NOWAIT;
                    }
                    
                } ELSE {
                    logToFile('edi', provider + ' (' + login + ') SendEDocument: не заданы параметры EDSService');
                    MESSAGE provider + ' (' + login + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') SendEDocument: не заданы имя пользователя / пароль / хост / порт');
                MESSAGE provider + ' (' + login + ') Документ не выгружен: не заданы имя пользователя / пароль / хост / порт' NOWAIT;
            }
        } CATCH {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE 'Документ не выгружен. Обратитесь к администратору' NOWAIT;
        }
    } ELSE {
        logToFile('edi', provider + ' (' + login + ') error: ' + 'SendEDocument disabled, change serverComputer() to enable');
        MESSAGE  provider + ' (' + login + ') error: ' + 'SendEDocument disabled, change serverComputer() to enable' NOWAIT;
    }
}

GROUP documentAttributes EXTID 'DocumentAttributes';
GROUP eDocumentType : documentAttributes;
GROUP sender2 EXTID 'Sender' : documentAttributes;
GROUP legalPerson EXTID 'LegalPerson' : sender2;
GROUP receiver2 EXTID 'Receiver' : documentAttributes;
GROUP legalPerson1 EXTID 'LegalPerson' : receiver2;

responseIndicator = DATA LOCAL STRING ();

FORM exportBlrdocV2 FORMEXTID 'BLRDOC'
    PROPERTIES ATTR = '2.0' IF NOT hideMessageHeaderBlrdoc() EXTID 'version'
    PROPERTIES ATTR = responseIndicator() EXTID 'responseIndicator'

    OBJECTS ed = EDocument IN documentAttributes
    PROPERTIES DRAW ed documentID = (OVERRIDE documentID(ed), STRING[35](resultMilliseconds())) EXTID 'DocumentID',
        creationDateTime = toChar((OVERRIDE creationDateTime(ed) IF NOT isCancel(ed), exportBlrdocDateTime()), 'YYYYMMDDHH24MISS') EXTID 'CreationDateTime',
        functionCode(ed) EXTID 'FunctionCode',
        route = OVERRIDE idRoute(ed), '0' EXTID 'eDocumentRoute',
        number(ed) EXTID 'eDocumentNumber',
        date = toChar(date(ed), 'YYYYMMDD') EXTID 'eDocumentDate'
    PROPERTIES (ed) IN eDocumentType nameDocumentType EXTID 'TypeName', codeDocumentType EXTID 'TypeCode'

    PROPERTIES DRAW ed IN legalPerson glnSender(ed) EXTID 'GLN',
        nameSender(ed) EXTID 'Name',
        addressSender(ed) EXTID 'Address',
        unpSender(ed) EXTID 'VATRegistrationNumber'
    PROPERTIES DRAW ed IN legalPerson1 glnReceiver(ed) EXTID 'GLN',
        nameReceiver(ed) EXTID 'Name',
        addressReceiver(ed) EXTID 'Address',
        unpReceiver(ed) EXTID 'VATRegistrationNumber'

    PROPERTIES (ed) IN document file EXTID 'eDocumentFile', typeFile EXTID 'eDocumentFileType', name EXTID 'eDocumentName'
;

GROUP receiver3 EXTID 'receiver';
id = DATA LOCAL STRING ();
documentID1 = DATA LOCAL STRING();
creationDateTime1 = DATA LOCAL STRING ();

FORM exportBlrdocJSON
    OBJECTS d = EDocument PANEL
    PROPERTIES (d) number EXTID 'eDocumentNumber', date EXTID 'eDocumentDate', codeDocumentType EXTID 'eDocumentTypeCode', nameDocumentType EXTID 'eDocumentTypeName',
        idFunctionCode EXTID 'functionCode', idRoute EXTID 'route'
    PROPERTIES IN receiver3 id = id(receiver(d), sender(d))
    PROPERTIES (d) IN receiver3 nameReceiver EXTID 'name', glnReceiver EXTID 'gln', unpReceiver EXTID 'unp'
;

xmlBody = DATA LOCAL STRING();
xmlByteDate = DATA LOCAL STRING(INTEGER);
errorDescription = DATA LOCAL STRING();
xmlBase64 = DATA LOCAL STRING();
documentId = DATA LOCAL STRING();
publicId = DATA LOCAL STRING();
successful = DATA LOCAL BOOLEAN();

FORM importSignDoc
    PROPERTIES() xmlBody, errorDescription, documentType, xmlBase64, documentId, id, publicId, subjectName, successful

    OBJECTS xmlByteDate = INTEGER
    PROPERTIES(xmlByteDate) xmlByteDate EXTID 'value'
    FILTERS imported(xmlByteDate)
;

signAndSendSenderEDocumentV2(EDocument d, LegalEntity le, STRING[100] outputDir, STRING[100] provider) {
    LOCAL result = FILE ();
    TRY {
        IF profile(le) THEN {
            IF EDSServiceSender(provider, d) THEN {
                LOCAL error = TEXT();
                error() <- '';
                IF NOT functionCode(d) THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Функциональный код\'\n';
                IF NOT route(d) THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Маршрут документа\'\n';
                IF NOT length(number(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Номер электронного документа (юридический)\'\n';
                IF NOT date(d) THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Дата электронного документа (юридический)\'\n';
                IF NOT eDocumentType(d) THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Тип электронного документа\'\n';
                IF NOT length(glnSender(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'GLN отправителя\'\n';
                IF NOT length(unpSender(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'УНП отправителя\'\n';
                IF NOT length(glnReceiver(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'GLN получателя\'\n';
                IF NOT length(unpReceiver(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'УНП получателя\'\n';
                IF NOT length(file(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Файл\'\n';
                IF NOT length(name(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Имя файла\'\n';
                IF NOT length(typeFile(d)) > 0 THEN error() <- error() + 'EDocument ' + (OVERRIDE number(d), documentID(d), '') + ': Не заполнено поле \'Тип файла\'\n';

                IF error() == '' THEN {
                    LOCAL headers = STRING(STRING);
                    authenticate(profile(le));
                    headers('Authorization') <- token();

                    IF token() THEN {
                        //Получить id reciever'a
                        IF NOT id(receiver(d), sender(d)) THEN {
                            EXPORT JSON FROM unp = UNP(receiver(d)), status = 'ACTIVE';
                            EXTERNAL HTTP POST url(profile(sender(d))) + 'organization/partners/list' HEADERS headers PARAMS exportFile() TO result;
                            IMPORT JSON FROM result() TO id = id;

                            id(receiver(d), sender(d)) <- id(0);
                        }

                        EXPORT exportBlrdocJSON OBJECTS d = d JSON;
                        EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() HEADERS headers PARAMS exportFile() TO result;
                        IMPORT JSON FROM result() TO() id = id, documentID1 = documentID;
                        id(d) <- id();
                        documentID(d) <- documentID1();
                        creationDateTime(d) <- DATETIME(creationDateTime1());
                        dateTimeCreated(d) <- DATETIME(creationDateTime1());

                        exportBlrdocDateTime() <- currentDateTimeMillis();
                        toMilliseconds(exportBlrdocDateTime());
                        name() <- 'blrdoc-' + toChar(exportBlrdocDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS');
                        documentType() <- 'BLRDOC';
                        IF outputDir THEN {
                            TRY { mkdir(outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd')); }
                            WRITE exportFile() TO outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + name();
                        }
                        LOCAL base64File = STRING ();
                        //base64File() <- encodeBase64(file(d));

                        EXPORT JSON FROM content = base64File(), fileName = name(d);
                        EXTERNAL HTTP PUT url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/file/base64' HEADERS headers PARAMS exportFile() TO result;
                        IF statusHttp() = 200 THEN fileAddedToDraft(d) <- TRUE;

                        IF idRoute(d) = '0' OR idRoute(d) = '1' THEN {
                            EXTERNAL HTTP GET url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/signed?base64=true' HEADERS headers TO result;
                            IMPORT importSignDoc JSON FROM result();
                            IF errorDescription() != '' THEN {
                                MESSAGE errorDescription();
                            } ELSE {
                                stringToFile(xmlBase64());
                                getSignedDocumentSender(provider, d, resultFile(), TRUE);
                                IF signError() THEN {
                                    logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument error: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError());
                                    MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                                }
                                IF base64Signature() THEN {
                                    EXPORT JSON FROM id = id(d), signatureBase64 = base64Signature(), xmlBody = xmlBase64();
                                    EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + 'saveSigned' HEADERS headers PARAMS exportFile() TO result;
                                }
                                IF statusHttp() = 200 THEN signedBySender(d) <- TRUE;
                            }
                        }

                        EXPORT JSON FROM id = id(d);
                        EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/send' HEADERS headers PARAMS exportFile() TO result;

                        IF statusHttp() = 200 THEN {
                            logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' request succeeded');
                            MESSAGE provider + ' (' + loginProfile(le) + ') Документ ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + (IF isCancel(d) THEN ' (отмена)' ELSE '') + ' выгружен' NOWAIT;

                            exportedSender(d) <- TRUE;
                            creationDateTime(d) <- exportBlrdocDateTime() WHERE NOT creationDateTime(d);
                            numberSender(d) <- STRING[35](resultMilliseconds());
                            dateSender(d) <- exportBlrdocDateTime();

                            NEW em = EDocumentMessage {
                                number(em) <- 'doc' + STRING[35](resultMilliseconds());
                                eDocument(em) <- d;
                                dateTime(em) <- toDateTimeFormat(toChar(exportBlrdocDateTime(), 'yyyy-MM-ddThh24:mi:ss'), 'yyyy-MM-ddThh24:mi:ss');
                                code(em) <- '9';
                                kind(em) <- EInvoiceMessageKind.out;
                                type(em) <- EInvoiceMessageType.blrdoc;
                                XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + name() + '.json';
                            }
                        }
                        APPLY;
                    } ELSE {
                        logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument: ошибка при аутентификации');
                        MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: ошибка при аутентификации' NOWAIT;
                    }
                } ELSE {
                    logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument: Не все поля заполнены. ' + error());
                    MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: Не все поля заполнены ' + error() NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument: не заданы параметры EDSService');
                MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendEDocument: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(result(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + loginProfile(le) + ') error:' + requestError());
            MESSAGE provider + '(' + loginProfile(le) + ') Документ не выгружен. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документ не отправлен:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
    }
}

signAndSendSender(EDocument d) + {
    IF EDIProviderDocument(receiver(d), sender(d)) == EDIProvider.topBy THEN {
        newNS() <- TRUE;
        IF exportedSender(d) THEN
            MESSAGE 'Документ (отправитель) уже отправлен';
        ELSE {
            IF useV2(receiver(d)) THEN {
                signAndSendSenderEDocumentV2(d, sender(d), outputDirTopBy(), 'TopBy');
            } ELSE signAndSendSenderEDocument(d, loginTopBy(sender(d)), passwordTopBy(sender(d)), ('http://' + hostTopBy(sender(d)) + ':' + portTopBy(sender(d)) + '/DmcService'), outputDirTopBy(), 'TopBy');
        }
    }
}

idBlrapn = DATA STRING (EDocument);

signAndSendBlrapnSenderEDocumentV2(EDocument d, LegalEntity le, STRING[100] outputDir, STRING[100] provider) {
    LOCAL result = FILE ();
    TRY {
        IF profile(le) THEN {
            IF EDSServiceSender(provider, d) THEN {
                LOCAL headers = STRING(STRING);
                authenticate(profile(le));
                headers('Authorization') <- token();

                IF token() THEN {
                    EXPORT JSON FROM id = id(d);
                    EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/blrapn/cancel?base64=true' HEADERS headers PARAMS exportFile() TO result;

                    IMPORT importSignDoc JSON FROM result();

                    IF errorDescription() != '' THEN {
                        MESSAGE errorDescription();
                    } ELSE {
                        blrapnDateTime() <- currentDateTimeMillis();
                        toMilliseconds(exportBlrdocDateTime());
                        IF outputDir THEN {
                            TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd')); }
                            WRITE result() TO outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS');
                        }
                        idBlrapn(d) <- id();
                        stringToFile(xmlBase64());
                        getSignedDocumentSender(provider, d, resultFile(), TRUE);
                        IF signError() THEN {
                            logToFile('edi', provider + ' (' + loginProfile(le) + ') SendBlrapnEDocument error: BLRAPN ' + (OVERRIDE number(d), idBlrapn(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError());
                            MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: BLRAPN ' + (OVERRIDE number(d), idBlrapn(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                        }
                        EXPORT JSON FROM id = idBlrapn(d), signatureBase64 = base64Signature(), xmlBody = xmlBase64();
                        EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + 'blrapn/saveSignedAndSend' HEADERS headers PARAMS exportFile() TO result;

                        numberSenderCancel(d) <- STRING[35](resultMilliseconds());
                        dateSenderCancel(d) <- blrapnDateTime();

                        NEW em = EDocumentMessage {
                            number(em) <- STRING[35](resultMilliseconds());
                            eDocument(em) <- d;
                            dateTime(em) <- toDateTimeFormat(toChar(blrapnDateTime(), 'yyyy-MM-ddThh24:mi:ss'), 'yyyy-MM-ddThh24:mi:ss');
                            code(em) <- '1';
                            kind(em) <- EInvoiceMessageKind.out;
                            type(em) <- EInvoiceMessageType.blrapn_blrdoc;
                            XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS') + '.json';
                        }
                        exportedSender(d) <- TRUE; //оставить пока используется старая версия 
                        APPLY;
                    }
                } ELSE {
                    logToFile('edi', provider + ' (' + loginProfile(le) + ') SendBlrapnEDocument: ошибка при аутентификации');
                    MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: ошибка при аутентификации' NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + loginProfile(le) + ') SendBlrapnEDocument: не заданы параметры EDSService');
                MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendBlrapnEDocument: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(result(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + loginProfile(le) + ') error:' + requestError());
            MESSAGE provider + '(' + loginProfile(le) + ') Документ не выгружен. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документ не отправлен:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
        isCancel(d) <- NULL;
        exportedSender(d) <- TRUE;
        APPLY;
    }
}

signAndSendSenderCancel(EDocument d) + {
    IF EDIProviderDocument(receiver(d), sender(d)) == EDIProvider.topBy THEN {
        newNS() <- TRUE;
        IF exportedSender(d) THEN
            MESSAGE 'Документ (отправитель) уже отправлен';
        ELSE {
            IF useV2(receiver(d)) THEN {
                signAndSendBlrapnSenderEDocumentV2(d, sender(d), outputDirTopBy(), 'TopBy');
            } ELSE signAndSendSenderEDocument(d, loginTopBy(sender(d)), passwordTopBy(sender(d)), ('http://' + hostTopBy(sender(d)) + ':' + portTopBy(sender(d)) + '/DmcService'), outputDirTopBy(), 'TopBy');
        }
    }
}

signAndSendBlrapnReceiverEDocument (EDocument ed, STRING[100] login, STRING[100] password, TEXT url, STRING[100] outputDir , STRING[100] provider) {
    checkIsServer();
    IF isServer() THEN {
        TRY {
            IF login AND password THEN {
                IF EDSServiceReceiver(provider,ed) THEN {
                    LOCAL contentSubXML = FILE();
                    blrapnDateTime() <- currentDateTimeMillis();
                    blrapnMsgSender() <- glnReceiver(ed);
                    blrapnMsgReceiver() <- glnSender(ed);
                    //blrapnUserID() <- userIDSupplierStock(ed);
                    blrapnDeliveryNoteId() <- number(ed);
                    blrapnDeliveryNoteDate() <- date(ed);
                    blrapnReferenceDocumentType() <- 'BLRDOC';
                    blrapnReferenceDocumentId() <- documentID(ed);
                    blrapnReferenceDocumentDate() <- dateSenderCancel(ed);
                    blrapnShipper() <- glnSender(ed);
                    blrapnReceiver() <- glnReceiver(ed);
                    blrapnCode() <- '2650';
                    blrapnDescription() <- NULL;
                    toMilliseconds(blrapnDateTime());
                    EXPORT exportBlrapnNew XML TO contentSubXML;
                    IF outputDir THEN {
                        TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd')); }
                        WRITE contentSubXML() TO outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                    }
                    name() <- 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                    documentType() <- 'BLRAPN';
                    getSignedDocumentReceiver(provider, ed, contentSubXML(), TRUE);
                    IF signError() THEN {
                        logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument error: BLRAPN ' + documentID(ed) + ' не подписан. Ошибка: ' + signError());
                        MESSAGE provider + ' (' + login + ') Извещение о прочтении отмены документа не выгружено: BLRAPN ' + documentID(ed) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                    }
                    ELSE IF signResult() THEN {
                        LOCAL ixml = XMLFILE();
                        envelopeLogin() <- login;
                        envelopePassword() <- password;
                        envelopeFilename() <- CONCAT '', 'document', documentID(ed);
                        envelopeDocumentDate() <- blrapnDateTime();
                        envelopeDocumentNumber() <- numberSenderCancel(ed);
                        envelopeSender() <- glnReceiver(ed);
                        envelopeReceiver() <- glnSender(ed);
                        //envelopeDeliveryPoint() <- glnSender(ed);
                        envelopeDocumentType() <- 'BLRAPN';
                        envelopeContent() <- signResult();
                        EXPORT envelope XML TO ixml;
                        sendRequestEDI(url, ixml());
                        logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) +' request sent');
                        importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'SendDocumentResponse');
                        IF requestError() THEN {
                            logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) + ': ' + requestError());
                            MESSAGE provider + ' (' + login + ') Извещение о прочтении отмены документа ' + documentID(ed) + ' не выгружено: ' + requestError() NOWAIT;
                        } ELSE {
                            logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument ' + documentID(ed) + ' request succeeded');
                            MESSAGE provider + ' (' + login + ') Извещение о прочтении отмены документа ' + documentID(ed) + ' выгружено' NOWAIT;
                            exportedBlrapnReceiver(ed) <- TRUE;
                            NEW em = EDocumentMessage {
                                number(em) <- STRING[35](resultMilliseconds());
                                eDocument(em) <- ed;
                                dateTime(em) <- toDateTimeFormat(toChar(blrapnDateTime(),'yyyy-MM-ddThh24:mi:ss'),'yyyy-MM-ddThh24:mi:ss');
                                code(em) <- blrapnCode();
                                kind(em) <- EInvoiceMessageKind.out;
                                type(em) <- EInvoiceMessageType.blrapn_blrdoc;
                                XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrapn-' + toChar(blrapnDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                            }
                            APPLY NESTED LOCAL;
                        }
                    }
                } ELSE {
                    logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument: не заданы параметры EDSService');
                    MESSAGE provider + ' (' + login + ') Извещение о прочтении не выгружено: не заданы параметры EDSService' NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') SendBlrapnEDocument: не заданы имя пользователя / пароль / хост / порт');
                MESSAGE provider + ' (' + login + ') Извещение о прочтении не выгружено: не заданы имя пользователя / пароль / хост / порт' NOWAIT;
            }
        } CATCH {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE 'Извещение о прочтении не выгружено. Обратитесь к администратору' NOWAIT;
        }
    } ELSE {
        logToFile('edi', provider + ' (' + login + ') error: ' + 'SendBlrapnEDocument disabled, change serverComputer() to enable');
        MESSAGE provider + ' (' + login + ') error: ' + 'SendBlrapnEDocument disabled, change serverComputer() to enable' NOWAIT;
    }
}

signAndSendBlrapnReceiverEDocumentV2(EDocument d, LegalEntity le, STRING[100] outputDir, STRING[100] provider) {
    LOCAL result = FILE ();
    TRY {
        IF profile(le) THEN {
            IF EDSServiceReceiver(provider, d) THEN {
                LOCAL headers = STRING(STRING);
                authenticate(profile(le));
                headers('Authorization') <- token();

                IF token() THEN {
                    EXPORT JSON FROM id = id(d);
                    EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/blrapn/denySignature?base64=true' HEADERS headers PARAMS exportFile() TO result;

                    IMPORT importSignDoc JSON FROM result();
                    IF errorDescription() != '' THEN {
                        MESSAGE errorDescription();
                    } ELSE {
                        stringToFile(xmlBase64());
                        getSignedDocumentReceiver(provider, d, resultFile(), TRUE);
                        IF signError() THEN {
                            logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument error: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError());
                            MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                        }
                        IF base64Signature() THEN {
                            EXPORT JSON FROM id = id(d), signatureBase64 = base64Signature(), xmlBody = xmlBase64();
                            EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + 'blrapn/saveSignedAndSend' HEADERS headers PARAMS exportFile() TO result;

                            exportBlrdocDateTime() <- currentDateTimeMillis();
                            toMilliseconds(exportBlrdocDateTime());
                            IF outputDir THEN {
                                TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd')); }
                                WRITE exportFile() TO outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS');
                            }

                            exportedBlrapnReceiver(d) <- TRUE;
                            creationDateTime(d) <- exportBlrdocDateTime() WHERE NOT creationDateTime(d);
                            numberReceiver(d) <- STRING[35](resultMilliseconds());
                            dateReceiver(d) <- exportBlrdocDateTime();
                            NEW em = EDocumentMessage {
                                number(em) <- 'doc' + STRING[35](resultMilliseconds());
                                eDocument(em) <- d;
                                dateTime(em) <- toDateTimeFormat(toChar(exportBlrdocDateTime(), 'yyyy-MM-ddThh24:mi:ss'), 'yyyy-MM-ddThh24:mi:ss');
                                code(em) <- '9';
                                kind(em) <- EInvoiceMessageKind.out;
                                type(em) <- EInvoiceMessageType.blrapn_blrdoc;
                                XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS') + '.json';
                            }
                        }
                    }

                    EXPORT JSON FROM id = id(d);
                    EXTERNAL HTTP POST url(profile(sender(d))) + blrdocUrlStt() + id(d) + '/saveSignedAndSend ' HEADERS headers PARAMS exportFile() TO result;

                } ELSE {
                    logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument: ошибка при аутентификации');
                    MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: ошибка при аутентификации' NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocument: не заданы параметры EDSService');
                MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendEDocument: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(result(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + loginProfile(le) + ') error:' + requestError());
            MESSAGE provider + '(' + loginProfile(le) + ') Документ не выгружен. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документ не отправлен:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
    }
}

signAndSendBlrapnReceiver(EDocument d) + {
    IF EDIProviderDocument(sender(d), receiver(d)) == EDIProvider.topBy THEN {
        newNS() <- TRUE;
        IF exportedBlrapnReceiver(d) THEN
            MESSAGE 'Извещение о прочтении отмены (получатель) уже отправлено';
        ELSE {
            IF useV2(sender(d)) THEN {
                signAndSendBlrapnReceiverEDocumentV2(d, sender(d), outputDirTopBy(), 'TopBy');
            } ELSE signAndSendBlrapnReceiverEDocument(d, loginTopBy(receiver(d)), passwordTopBy(receiver(d)), ('http://' + hostTopBy(receiver(d)) + ':' + portTopBy(receiver(d)) + '/DmcService'), outputDirTopBy(), 'TopBy');
        }
    }
}

signAndSendReceiverEDocument (EDocument ed, STRING[100] login, STRING[100] password, TEXT url, STRING[100] outputDir , STRING[100] provider) {
    checkIsServer();
    IF isServer() THEN {
        TRY {
            IF login AND password THEN {
                IF EDSServiceReceiver(provider,ed) THEN {
                    IF NOT isCancel(ed) THEN {
                        LOCAL error = TEXT();
                        error() <- '';
                        IF NOT xmlFile(ed) THEN error() <- error() + 'EDocument ' + documentID(ed) + ': Отсутствует в базе xml файл от отправителя\n';

                        IF error() == '' THEN {
                            LOCAL contentSubXML = FILE();
                            exportBlrdocDateTime() <- currentDateTimeMillis();
                            toMilliseconds(exportBlrdocDateTime());
                            fileToString(FILE(xmlFile(ed)),'UTF-8');
                            resultString() <- replace(resultString(),(CONCAT '','<MessageID>',numberSender(ed)),(CONCAT '','<MessageID>',STRING[35](resultMilliseconds())));
                            resultString() <- replace(resultString(),(CONCAT '','<MsgDateTime>',toChar(dateSender(ed),'YYYYMMDDHH24MISS')),(CONCAT '','<MsgDateTime>',toChar(exportBlrdocDateTime(),'YYYYMMDDHH24MISS')));
                            resultString() <- replace(resultString(),(CONCAT '','<MsgSenderID>',glnSender(ed)),(CONCAT '','<MsgSenderID>',glnReceiver(ed)));
                            resultString() <- replace(resultString(),(CONCAT '','<MsgReceiverID>',glnReceiver(ed)),(CONCAT '','<MsgReceiverID>',glnSender(ed)));
                            stringToFile(resultString(),'UTF-8','xml');
                            contentSubXML() <- resultFile();
                            IF outputDir THEN {
                                TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd')); }
                                WRITE contentSubXML() TO outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                            }
                            name() <- 'blrdoc-' + toChar(exportBlrdocDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                            documentType() <- 'BLRDOC';
                            
                            IF route(ed) == EDocumentRoute.route1 THEN {
                                fileToString(contentSubXML());
                                encodeBase64(resultString());
                                signResult() <- encodedBase64();
                            } ELSE {
                                getSignedDocumentReceiver(provider, ed, contentSubXML(), TRUE);
                                IF signError() THEN {
                                    logToFile('edi', provider + ' (' + login + ') SendEDocument error: BLRDOC ' + documentID(ed) + ' не подписан. Ошибка: ' + signError());
                                    MESSAGE provider + ' (' + login + ') Документ не выгружен: BLRDOC ' + documentID(ed) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                                }
                            }
                            IF signResult() THEN {
                                LOCAL ixml = XMLFILE();
                                envelopeLogin() <- login;
                                envelopePassword() <- password;
                                envelopeFilename() <- CONCAT '', 'document', documentID(ed);
                                envelopeDocumentDate() <- exportBlrdocDateTime();
                                envelopeDocumentNumber() <- numberSender(ed);
                                envelopeSender() <- glnReceiver(ed);
                                envelopeReceiver() <- glnSender(ed);
                                //envelopeDeliveryPoint() <- glnSender(ed);
                                envelopeDocumentType() <- 'BLRDOC';
                                envelopeContent() <- signResult();
                                EXPORT envelope XML TO ixml;
                                sendRequestEDI(url, ixml());
                                logToFile('edi', provider + ' (' + login + ') SendEDocument ' + documentID(ed) +' request sent');
                                importRequestResult(sendRequestEDIResponse(), sendRequestEDIStatus(), 'SendDocumentResponse');
                                IF requestError() THEN {
                                    logToFile('edi', provider + ' (' + login + ') SendEDocument ' + documentID(ed) + ': ' + requestError());
                                    MESSAGE provider + ' (' + login + ') Документ ' + documentID(ed) + ' не выгружен: ' + requestError() NOWAIT;
                                } ELSE {
                                    logToFile('edi', provider + ' (' + login + ') SendEDocument ' + documentID(ed) + ' request succeeded');
                                    MESSAGE provider + ' (' + login + ') Документ ' + documentID(ed) + (IF isCancel(ed) THEN ' (отмена)' ELSE '') + ' выгружен' NOWAIT;
                                    exportedReceiver(ed) <- TRUE;
                                    toMilliseconds(exportBlrdocDateTime());
                                    numberReceiver(ed) <- STRING[35](resultMilliseconds());
                                    dateReceiver(ed) <- exportBlrdocDateTime();
                                    NEW em = EDocumentMessage {
                                        number(em) <- 'doc' + STRING[35](resultMilliseconds());
                                        eDocument(em) <- ed;
                                        dateTime(em) <- toDateTimeFormat(toChar(exportBlrdocDateTime(),'yyyy-MM-ddThh24:mi:ss'),'yyyy-MM-ddThh24:mi:ss');
                                        code(em) <- '9';
                                        kind(em) <- EInvoiceMessageKind.out;
                                        type(em) <- EInvoiceMessageType.blrdoc;
                                        XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(),'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(),'YYYY-MM-DD-HH24-MI-SS-MS');
                                    }
                                    APPLY NESTED LOCAL;
                                }
                            }
                        } ELSE {
                            logToFile('edi', provider + ' (' + login + ') SendEDocument: Не все поля заполнены ' + error());
                            MESSAGE provider + ' (' + login + ') Документ не выгружен: Не все поля заполнены ' + error() NOWAIT;
                        }
                    } ELSE {
                        logToFile('edi', provider + ' (' + login + ') SendEDocument: Нельзя подписывать отмененный документ');
                        MESSAGE provider + ' (' + login + ') Документ не выгружен: Нельзя подписывать отмененный документ' NOWAIT;
                        //logToFile('edi', provider + ' (' + login + ') SendEDocument ' + documentID(ed) + ' request succeeded');
                        //MESSAGE provider + ' (' + login + ') Документ ' + documentID(ed) + (IF isCancel(ed) THEN ' (отмена)' ELSE '') + ' выгружен' NOWAIT;
                        //exportedReceiver(ed) <- TRUE;
                        //APPLY NESTED LOCAL;
                    }
                } ELSE {
                    logToFile('edi', provider + ' (' + login + ') SendEDocument: не заданы параметры EDSService');
                    MESSAGE provider + ' (' + login + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
                }
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') SendEDocument: не заданы имя пользователя / пароль / хост / порт');
                MESSAGE provider + ' (' + login + ') Документ не выгружен: не заданы имя пользователя / пароль / хост / порт' NOWAIT;
            }
        } CATCH {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE 'Документ не выгружен. Обратитесь к администратору' NOWAIT;
        }
    } ELSE {
        logToFile('edi', provider + ' (' + login + ') error: ' + 'SendEDocument disabled, change serverComputer() to enable');
        MESSAGE provider + ' (' + login + ') error: ' + 'SendEDocument disabled, change serverComputer() to enable' NOWAIT;
    }
}

signAndSendReceiverEDocumentV2(EDocument d, LegalEntity le, STRING[100] outputDir, STRING[100] provider) {
    LOCAL result = FILE ();
    TRY {
        IF profile(le) THEN {
            LOCAL responseId = STRING ();
            
            IF EDSServiceReceiver(provider, d) THEN {
                LOCAL headers = STRING(STRING);
                authenticate(profile(le));
                headers('Authorization') <- token();

                IF token() THEN {
                    EXPORT exportBlrdocJSON OBJECTS d = d JSON;
                    EXTERNAL HTTP POST url(profile(receiver(d))) + blrdocUrlStt() + id(d) + '/response' HEADERS headers PARAMS exportFile() TO result;
                    fileToString(result());
                    responseId() <- resultString();
                    
                    IF idRoute(d) = '0' OR idRoute(d) = '2' THEN {
                        EXTERNAL HTTP GET url(profile(receiver(d))) + blrdocUrlStt() + responseId() + '/signed?base64=true' HEADERS headers TO result;
                        IMPORT importSignDoc JSON FROM result();
                        IF errorDescription() != '' THEN {
                            MESSAGE errorDescription();
                        } ELSE {
                            stringToFile(xmlBase64());
                            getSignedDocumentReceiver(provider, d, resultFile(), TRUE);
                            IF signError() THEN {
                                logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocumentResponse error: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError());
                                MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: BLRDOC ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' не подписан. Ошибка: ' + signError() NOWAIT;
                            }
                            IF base64Signature() THEN {
                                EXPORT JSON FROM id = responseId(), signatureBase64 = base64Signature(), xmlBody = xmlBase64();
                                EXTERNAL HTTP POST url(profile(receiver(d))) + blrdocUrlStt() + 'saveSigned' HEADERS headers PARAMS exportFile() TO result;

                                exportBlrdocDateTime() <- currentDateTimeMillis();
                                toMilliseconds(exportBlrdocDateTime());
                                IF outputDir THEN {
                                    TRY{ mkdir(outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd')); }
                                    WRITE exportFile() TO outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS') + '.json';
                                }
                            }
                        }
                    }

                    EXPORT JSON FROM id = responseId();
                    EXTERNAL HTTP POST url(profile(receiver(d))) + blrdocUrlStt() + responseId() + '/send' HEADERS headers PARAMS exportFile() TO result;

                    IF statusHttp() = 200 THEN {
                        logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocumentResponse ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + ' request succeeded');
                        MESSAGE provider + ' (' + loginProfile(le) + ') Документ ' + (OVERRIDE number(d), id(d), STRING[35](resultMilliseconds())) + (IF isCancel(d) THEN ' (отмена)' ELSE '') + ' выгружен' NOWAIT;

                        exportedReceiver(d) <- TRUE;
                        creationDateTime(d) <- exportBlrdocDateTime() WHERE NOT creationDateTime(d);
                        numberReceiver(d) <- STRING[35](resultMilliseconds());
                        dateReceiver(d) <- exportBlrdocDateTime();
                        NEW em = EDocumentMessage {
                            number(em) <- 'doc' + STRING[35](resultMilliseconds());
                            eDocument(em) <- d;
                            dateTime(em) <- toDateTimeFormat(toChar(exportBlrdocDateTime(), 'yyyy-MM-ddThh24:mi:ss'), 'yyyy-MM-ddThh24:mi:ss');
                            code(em) <- '9';
                            kind(em) <- EInvoiceMessageKind.out;
                            type(em) <- EInvoiceMessageType.blrdoc;
                            XMLPath(em) <- outputDir + '/sent/documents/' + toChar(currentDate(), 'yyyyMMdd') + '/' + 'blrdoc-' + toChar(exportBlrdocDateTime(), 'YYYY-MM-DD-HH24-MI-SS-MS') + '.json';
                        }
                    }
                    APPLY;
                } ELSE {
                    logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocumentResponse: ошибка при аутентификации');
                    MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: ошибка при аутентификации' NOWAIT;
                }

            } ELSE {
                logToFile('edi', provider + ' (' + loginProfile(le) + ') SendEDocumentResponse: не заданы параметры EDSService');
                MESSAGE provider + ' (' + loginProfile(le) + ') Документ не выгружен: не заданы параметры EDSService' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendEDocumentResponse: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(result(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + loginProfile(le) + ') error:' + requestError());
            MESSAGE provider + '(' + loginProfile(le) + ') Документ не выгружен. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документ не отправлен:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
    }
}

signAndSendReceiver(EDocument d) + {
    IF EDIProviderDocument(sender(d), receiver(d)) == EDIProvider.topBy THEN {
        newNS() <- TRUE;
        IF exportedReceiver(d) THEN
            MESSAGE 'Документ (получатель) уже отправлен';
        ELSE {
            IF useV2(sender(d)) THEN {
                signAndSendReceiverEDocumentV2(d, receiver(d), outputDirTopBy(), 'TopBy');
            } ELSE signAndSendReceiverEDocument(d, loginTopBy(receiver(d)), passwordTopBy(receiver(d)), ('http://' + hostTopBy(receiver(d)) + ':' + portTopBy(receiver(d)) + '/DmcService'), outputDirTopBy(), 'TopBy');
        }
    }
}

CLASS FilterPageStatus {
    ALL_ 'Все',
    AT_PARTNER 'У контрагента',
    COMPLETED 'Завершённые',
    WAITING_FOR_PROCESSING 'Ждёт обработки'
}

id (FilterPageStatus s) = CASE
    WHEN s == FilterPageStatus.ALL_ THEN 'ALL'
    WHEN s == FilterPageStatus.AT_PARTNER THEN 'AT_PARTNER'
    WHEN s == FilterPageStatus.COMPLETED THEN 'COMPLETED'
    WHEN s == FilterPageStatus.WAITING_FOR_PROCESSING THEN 'WAITING_FOR_PROCESSING'
;

filterPageStatus = DATA LOCAL NESTED FilterPageStatus ();
filterPageStatusName 'Статус документов' () = staticCaption(filterPageStatus()) CHARWIDTH 30;

documentDateStart 'Дата с' = DATA LOCAL NESTED DATETIME ();
documentDateEnd 'Дата по' = DATA LOCAL NESTED DATETIME ();

GROUP processingStatus;

last = DATA LOCAL BOOLEAN();
totalPages = DATA LOCAL INTEGER();
idContent = DATA LOCAL STRING(INTEGER);
dateTime = DATA LOCAL STRING(INTEGER);
documentNumber = DATA LOCAL STRING(INTEGER);
name1 = DATA LOCAL STRING(INTEGER);
id1 = DATA LOCAL STRING(INTEGER);

FORM importBlrdocs
    PROPERTIES() last, totalPages

    OBJECTS content = INTEGER
    PROPERTIES(content) id, dateTime, documentNumber
    PROPERTIES(content) IN processingStatus name1 EXTID 'name', id1 EXTID 'id'
    FILTERS imported(content)
;

GROUP receiver1 EXTID 'receiver';
GROUP sender1 EXTID 'sender';

id3 = DATA LOCAL STRING();
fileName1 = DATA LOCAL STRING();
gln = DATA LOCAL STRING();
functionCode1 = DATA LOCAL STRING();
fieldName = DATA LOCAL STRING(INTEGER);
fieldCode = DATA LOCAL STRING(INTEGER);
fieldValue = DATA LOCAL STRING(INTEGER);
referenceDocumentList = DATA LOCAL STRING(INTEGER);
id1 = DATA LOCAL STRING();
name1 = DATA LOCAL STRING();
route = DATA LOCAL STRING();
edocumentDate = DATA LOCAL STRING();
gln1 = DATA LOCAL STRING();
edocumentNumber = DATA LOCAL STRING();
edocumentTypeCode = DATA LOCAL STRING();

FORM importBlrdoc
    PROPERTIES() id3 EXTID 'id', creationDateTime1, route, functionCode1 EXTID 'functionCode', documentID1 EXTID 'documentID',
        edocumentNumber, edocumentDate, edocumentTypeCode, fileName1 EXTID 'fileName'

    PROPERTIES() IN sender1 gln1 EXTID 'gln'
    PROPERTIES() IN receiver1 gln

    OBJECTS extraFieldList = INTEGER
    PROPERTIES(extraFieldList) fieldName, fieldCode, fieldValue
    FILTERS imported(extraFieldList)

    PROPERTIES() IN processingStatus id1 EXTID 'id', name1 EXTID 'name'

    OBJECTS referenceDocumentList = INTEGER
    PROPERTIES(referenceDocumentList) referenceDocumentList EXTID 'value'
    FILTERS imported(referenceDocumentList)
;

eDocumentStatus 'Статус документа' = DATA STRING (EDocument);

getBlrdocFilteredPage(LegalEntity le, STRING login, STRING[100] archiveDir, BOOLEAN disableConfirmation, STRING[100] provider) {
    LOCAL response = FILE ();
    LOCAL file = RAWFILE ();
    TRY {
        IF profile(le) THEN {
            authenticate(profile(le));
            IF token() THEN {
                LOCAL NESTED page = INTEGER ();
                LOCAL headers = STRING(STRING);
                headers('Authorization') <- token();
                EXPORT JSON FROM documentDateStart = ZDATETIME(documentDateStart()), documentDateEnd = ZDATETIME(documentDateEnd());
                WHILE TRUE DO {
                    timeoutHttp() <- 300000;
                    page() <- page() (+) 1;

                    logToFile('edi', provider + ' (' + login + ') ReceiveMessages request sent. POST /api/v1/BLRDOC/' + filterPageStatusName() + '/filteredPage?page=' + page());
                    EXTERNAL HTTP POST url(profile(le)) + blrdocUrlStt() + id(filterPageStatus()) + '/filteredPage?page=' + page() HEADERS headers PARAMS exportFile() TO response;

                    IMPORT importBlrdocs JSON FROM response();
                    FOR id(INTEGER i) AND NOT eDocument(id(i)) AND NOT (GROUP MIN EDocument dd IF documentID(dd) = documentNumber(i) AND dateTimeCreated(dd) = DATETIME(dateTime(i))) DO {
                        logToFile('edi', provider + ' (' + login + ') ReceiveMessages request sent. GET /api/v1/BLRDOC/{id}');
                        EXTERNAL HTTP GET url(profile(le)) + blrdocUrlStt() + id(i) HEADERS headers TO response;

                        IMPORT importBlrdoc JSON FROM response();

                        NEW d = EDocument {
                            id(d) <- id3();
                            route(d) <- eDocumentRoute(route());
                            functionCode(d) <- eDocumentFunctionCode(functionCode1());
                            documentID(d) <- documentID1();
                            dateTimeCreated(d) <- DATETIME(creationDateTime1());
                            creationDateTime(d) <- DATETIME(creationDateTime1());
                            number(d) <- edocumentNumber();
                            date(d) <- DATE(edocumentDate());
                            type(d) <- edocumentTypeCode();
                            eDocumentType(d) <- eDocumentType(edocumentTypeCode());
                            sender(d) <- legalEntityGLN(gln1());
                            receiver(d) <- legalEntityGLN(gln());
                            eDocumentStatus(d) <- name1();
                            
                            IF id1() = 'CANCELED' THEN isCancel(d) <- TRUE;
                            IF receiver(d) = le THEN {
                                importedReceiver(d) <- TRUE;
                                IF id1() = 'TRANSFERRED' THEN exportedSender(d) <- TRUE;
                            }

                            IF fileName1() THEN {
                                logToFile('edi', provider + ' (' + login + ') Receive BLRDOC file request sent. GET /api/v1/BLRDOC/{id}/file');
                                EXTERNAL HTTP GET url(profile(le)) + blrdocUrlStt() + id(d) + '/file' HEADERS headers TO file;
                                file(d) <- file();
                                name(d) <- fileName1();
                            }

                            //                            FOR fieldCode(INTEGER j) DO {
                            //                                NEW dd = EDocumentDetail {
                            //                                    senderItemDescription(dd) <- fieldName(j);
                            //                                    senderItemCode(dd) <- fieldCode(j);
                            //                                    invoiceQuantity(dd) <- fieldValue(j);
                            //
                            //                                    eDocument(dd) <- d;
                            //                                }
                            //                            }
                        }
                    }
                    IF totalPages() == page() OR last() THEN BREAK;
                }
                APPLY;
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') ReceiveMessages: ошибка при аутентификации');
                MESSAGE provider + ' (' + login + ') Сообщения не получены: ошибка при аутентификации' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendEDocument: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(sendRequestEDIResponse(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') error:' + requestError());
            MESSAGE provider + '(' + login + ') Документы не получены. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документы не получены:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
    }
}

updateEDocuments 'Обновить документы' (LegalEntity le, STRING login, STRING[100] archiveDir, BOOLEAN disableConfirmation, STRING[100] provider) {
    LOCAL response = FILE ();
    LOCAL file = RAWFILE ();
    TRY {
        IF profile(le) THEN {
            authenticate(profile(le));
            IF token() THEN {
                LOCAL NESTED page = INTEGER ();
                LOCAL headers = STRING(STRING);
                headers('Authorization') <- token();
                EXPORT JSON FROM documentDateStart = ZDATETIME(documentDateStart()), documentDateEnd = ZDATETIME(documentDateEnd());
                WHILE TRUE DO {
                    timeoutHttp() <- 300000;
                    page() <- page() (+) 1;

                    logToFile('edi', provider + ' (' + login + ') ReceiveMessages request sent. POST /api/v1/BLRDOC/' + filterPageStatusName() + '/filteredPage?page=' + page());
                    EXTERNAL HTTP POST url(profile(le)) + blrdocUrlStt() + id(filterPageStatus()) + '/filteredPage?page=' + page() HEADERS headers PARAMS exportFile() TO response;

                    IMPORT importBlrdocs JSON FROM response();
                    FOR id(INTEGER i) AND EDocument doc = eDocument(id(i)) OR (GROUP MIN EDocument dd IF documentID(dd) = documentNumber(i) AND dateTimeCreated(dd) = DATETIME(dateTime(i))) = doc DO {
                        eDocumentStatus(doc) <- name1(i);
                        IF id1(i) = 'CANCELED' THEN isCancel(doc) <- TRUE;
                        IF receiver(doc) = le THEN {
                            importedReceiver(doc) <- TRUE;
                            IF id1(i) = 'TRANSFERRED' THEN exportedSender(doc) <- TRUE;
                        }
                    }
                    IF totalPages() == page() OR last() THEN BREAK;
                }
                APPLY;
            } ELSE {
                logToFile('edi', provider + ' (' + login + ') ReceiveMessages: ошибка при аутентификации');
                MESSAGE provider + ' (' + login + ') Сообщения не получены: ошибка при аутентификации' NOWAIT;
            }
        } ELSE {
            logToFile('edi', provider + ' SendEDocument: не задан профиль организации отправителя');
            MESSAGE provider + ' Документ не выгружен: не задан профиль организации отправителя' NOWAIT;
        }
    } CATCH {
        importRequestResult(sendRequestEDIResponse(), statusHttp());
        IF requestError() THEN {
            logToFile('edi', CONCAT '\n', provider + ' (' + login + ') error:' + requestError());
            MESSAGE provider + '(' + login + ') Документы не получены. Ошибка: ' + requestError() NOWAIT;
        } ELSE {
            logToFile('edi', CONCAT '\n', provider + ' error:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException());
            MESSAGE CONCAT ' ', provider + ' Документы не получены:', messageCaughtException(), javaStackTraceCaughtException() IF logStackForException(), lsfStackTraceCaughtException();
        }
    }
}

receiveBlrdocDocuments (STRING s) {
    IF NOT documentDateStart() OR NOT documentDateEnd() OR NOT filterPageStatus() THEN {
        MESSAGE 'Не заполнены параметры для импорта';
    } ELSE {
        FOR LegalEntity le == [GROUP MIN LegalEntity l BY loginProfile(l)](STRING login) AND password(profile(le)) DO {
            NEWSESSION {
                lockTopBy(login);
                IF lockResultTopBy() THEN {
                    TRY {
                        IF s = 'get' THEN getBlrdocFilteredPage(le, login, archiveDirTopBy(), disableConfirmationTopBy(), 'TopBy');
                        IF s = 'update' THEN updateEDocuments(le, login, archiveDirTopBy(), disableConfirmationTopBy(), 'TopBy');
                        APPLY;
                    } FINALLY {
                        unlockTopBy(login);
                    }
                } ELSE {
                    MESSAGE 'Уже выполняется получение документов CTT для ' + login + '. Подождите...' NOWAIT;
                }
            }
        }
    }
}

getBlrdoc 'Импорт документов' () {
    receiveBlrdocDocuments('get');
}

updateBlrdoc 'Обновление документов' () {
    receiveBlrdocDocuments('update');
}

EXTEND FORM eDocuments
    PROPERTIES (d) READONLY eDocumentStatus AFTER id(d)
    PROPERTIES () documentDateStart, documentDateEnd, filterPageStatusName, getBlrdoc, updateBlrdoc
;

DESIGN eDocuments {
    actionContainer {
        NEW importDocs BEFORE sender {
            caption = 'Импорт';
            horizontal = FALSE;
            MOVE PROPERTY(documentDateStart());
            MOVE PROPERTY(documentDateEnd());
            MOVE PROPERTY(filterPageStatusName());
            MOVE PROPERTY(getBlrdoc());
            MOVE PROPERTY(updateBlrdoc());
        }
    }
}